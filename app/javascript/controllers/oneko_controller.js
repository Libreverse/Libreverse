// Generated by CoffeeScript 2.7.0
var _class,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

import {
  Controller
} from "@hotwired/stimulus";

export default _class = (function() {
  var STORAGE_KEY, _Class;

  _Class = class extends Controller {
    constructor() {
      super(...arguments);
      this.connect = this.connect.bind(this);
      this.disconnect = this.disconnect.bind(this);
      this.startNeko = this.startNeko.bind(this);
      this.stopNeko = this.stopNeko.bind(this);
      this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
      // Saves oneko state to localStorage
      this.saveNekoState = this.saveNekoState.bind(this);
      
      // Loads oneko state from localStorage
      this.loadNekoState = this.loadNekoState.bind(this);
      this.initNeko = this.initNeko.bind(this);
      this.loop = this.loop.bind(this);
      this.updateNeko = this.updateNeko.bind(this);
      this.idle = this.idle.bind(this);
      this.setSprite = this.setSprite.bind(this);
      this.resetIdleAnimation = this.resetIdleAnimation.bind(this);
      this.updatePos = this.updatePos.bind(this);
      this.setSkin = this.setSkin.bind(this);
      // Heart explosion effect when neko is clicked
      this.explodeHearts = this.explodeHearts.bind(this);
    }

    connect() {
      boundMethodCheck(this, _class);
      this.running = false;
      this.requestId = void 0;
      this.nekoEl = this.element;
      
      // Bind methods for event listeners
      this.saveNekoState = this.saveNekoState.bind(this);
      this.loadNekoState = this.loadNekoState.bind(this);
      this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
      
      // Add event listeners for state preservation
      document.addEventListener('turbo:before-visit', this.saveNekoState);
      document.addEventListener('turbo:load', this.loadNekoState);
      window.addEventListener('beforeunload', this.saveNekoState);
      window.addEventListener('pagehide', this.saveNekoState);
      document.addEventListener('visibilitychange', this.handleVisibilityChange);
      
      // Load saved state first
      this.loadNekoState();
      
      // Start oneko automatically (not just in distraction mode)
      return this.startNeko();
    }

    disconnect() {
      var ref;
      boundMethodCheck(this, _class);
      // Save state before disconnecting
      this.saveNekoState();
      
      // Clean up event listeners
      document.removeEventListener('turbo:before-visit', this.saveNekoState);
      document.removeEventListener('turbo:load', this.loadNekoState);
      window.removeEventListener('beforeunload', this.saveNekoState);
      window.removeEventListener('pagehide', this.saveNekoState);
      document.removeEventListener('visibilitychange', this.handleVisibilityChange);
      
      // Remove click event listener if element exists
      if ((ref = this.nekoEl) != null) {
        ref.removeEventListener('click', this.explodeHearts);
      }
      if (this.requestId) {
        
        // Cancel animation
        return cancelAnimationFrame(this.requestId);
      }
    }

    startNeko() {
      var isReducedMotion, ref;
      boundMethodCheck(this, _class);
      if (this.running) {
        return;
      }
      isReducedMotion = (ref = globalThis.matchMedia("(prefers-reduced-motion: reduce)")) != null ? ref.matches : void 0;
      if (isReducedMotion) {
        return;
      }
      this.running = true;
      this.nekoEl.classList.remove("oneko-hidden");
      this.initNeko();
      return this.loop();
    }

    stopNeko() {
      boundMethodCheck(this, _class);
      this.running = false;
      this.nekoEl.classList.add("oneko-hidden");
      if (this.requestId) {
        cancelAnimationFrame(this.requestId);
      }
      return this.requestId = void 0;
    }

    handleVisibilityChange() {
      boundMethodCheck(this, _class);
      if (document.visibilityState === 'hidden') {
        return this.saveNekoState();
      }
    }

    saveNekoState() {
      var e, nekoState;
      boundMethodCheck(this, _class);
      if (!this.running) { // Only save if oneko is running
        return;
      }
      nekoState = {
        nekoPosX: this.nekoPosX,
        nekoPosY: this.nekoPosY,
        mousePosX: this.mousePosX,
        mousePosY: this.mousePosY,
        idleTime: this.idleTime,
        idleAnimation: this.idleAnimation,
        idleAnimationFrame: this.idleAnimationFrame,
        frameCount: this.frameCount,
        running: this.running,
        timestamp: Date.now()
      };
      try {
        return localStorage.setItem(STORAGE_KEY, JSON.stringify(nekoState));
      } catch (error) {
        e = error;
        return console.error("Failed to save oneko state to localStorage", e);
      }
    }

    loadNekoState() {
      var currentTime, e, savedState, state, timeDifference, timestamp;
      boundMethodCheck(this, _class);
      try {
        savedState = localStorage.getItem(STORAGE_KEY);
        if (!savedState) {
          return;
        }
        state = JSON.parse(savedState);
        
        // Get the timestamp of the saved state
        timestamp = state.timestamp || 0;
        currentTime = Date.now();
        timeDifference = currentTime - timestamp;
        
        // If the saved state is recent (less than 2 seconds old), use it
        // This likely means we're navigating between pages on the site
        if (timeDifference < 2000 && state.running) {
          // Use the saved state
          this.nekoPosX = state.nekoPosX || 32;
          this.nekoPosY = state.nekoPosY || 32;
          this.mousePosX = state.mousePosX || 0;
          this.mousePosY = state.mousePosY || 0;
          this.idleTime = state.idleTime || 0;
          this.idleAnimation = state.idleAnimation;
          this.idleAnimationFrame = state.idleAnimationFrame || 0;
          this.frameCount = state.frameCount || 0;
          
          // Apply position if oneko element exists
          if (this.nekoEl) {
            // use transform instead of left/top for smoother GPU-accelerated movement
            return this.updatePos();
          }
        }
      } catch (error) {
        e = error;
        return console.error("Failed to load oneko state from localStorage", e);
      }
    }

    initNeko() {
      boundMethodCheck(this, _class);
      if (this.nekoPosX == null) {
        // Only initialize values that weren't loaded from saved state
        this.nekoPosX = 32;
      }
      if (this.nekoPosY == null) {
        this.nekoPosY = 32;
      }
      if (this.mousePosX == null) {
        this.mousePosX = 0;
      }
      if (this.mousePosY == null) {
        this.mousePosY = 0;
      }
      if (this.frameCount == null) {
        this.frameCount = 0;
      }
      if (this.idleTime == null) {
        this.idleTime = 0;
      }
      if (this.idleAnimation == null) {
        this.idleAnimation = null;
      }
      if (this.idleAnimationFrame == null) {
        this.idleAnimationFrame = 0;
      }
      this.lastFrameTimestamp = void 0;
      this.nekoSpeed = 10;
      this.spriteSets = {
        idle: [[-3, -3]],
        alert: [[-7, -3]],
        scratchSelf: [[-5, 0], [-6, 0], [-7, 0]],
        scratchWallN: [[0, 0], [0, -1]],
        scratchWallS: [[-7, -1], [-6, -2]],
        scratchWallE: [[-2, -2], [-2, -3]],
        scratchWallW: [[-4, 0], [-4, -1]],
        tired: [[-3, -2]],
        sleeping: [[-2, 0], [-2, -1]],
        N: [[-1, -2], [-1, -3]],
        NE: [[0, -2], [0, -3]],
        E: [[-3, 0], [-3, -1]],
        SE: [[-5, -1], [-5, -2]],
        S: [[-6, -3], [-7, -2]],
        SW: [[-5, -3], [-6, -1]],
        W: [[-4, -2], [-4, -3]],
        NW: [[-1, 0], [-1, -1]]
      };
      this.nekoEl.id = "oneko";
      this.nekoEl.ariaHidden = true;

      // Use transform for positioning (GPU-accelerated), disable transitions that interfere
      Object.assign(this.nekoEl.style, {
        position: 'fixed', // keep it fixed relative to viewport
        left: '0px', // keep valid CSS but we will position with transform
        top: '0px',
        transition: 'none', // prevent CSS transitions interfering with JS frame updates
        willChange: 'transform, background-position', // hint the browser for optimizations
        transform: `translate3d(${this.nekoPosX - 16}px, ${this.nekoPosY - 16}px, 0)`,
        // ...other existing style keys if any...
      });
      
      // Add click event for heart explosion
      this.nekoEl.addEventListener("click", this.explodeHearts);
      
      // Listen for skin change events
      document.addEventListener("oneko:skin-changed", (event) => {
        return this.setSkin(event.detail.skin);
      });
      document.addEventListener("mousemove", (event) => {
        this.mousePosX = event.clientX;
        return this.mousePosY = event.clientY;
      });
      return document.addEventListener("wheel", (event) => {
        this.nekoPosY -= event.deltaY / 10;
        return this.updatePos();
      });
    }

    loop(timestamp) {
      boundMethodCheck(this, _class);
      if (!this.running) {
        return;
      }
      // Safety check - stop if neko element is removed from DOM
      if (!this.nekoEl.isConnected) {
        return;
      }
      if (!this.lastFrameTimestamp) {
        this.lastFrameTimestamp = timestamp;
      }
      if (timestamp - this.lastFrameTimestamp > 100) {
        this.lastFrameTimestamp = timestamp;
        this.updateNeko();
      }
      return this.requestId = globalThis.requestAnimationFrame(this.loop);
    }

    updateNeko() {
      var currentTime, diffX, diffY, direction, distance;
      boundMethodCheck(this, _class);
      diffX = this.nekoPosX - this.mousePosX;
      diffY = this.nekoPosY - this.mousePosY;
      distance = Math.hypot(diffX, diffY);
      if (distance < this.nekoSpeed || distance < 48) {
        this.idle();
        return;
      }
      this.idleAnimation = null;
      this.idleAnimationFrame = 0;
      if (this.idleTime > 1) {
        this.setSprite("alert", 0);
        this.idleTime = Math.min(this.idleTime, 7);
        this.idleTime--;
        return;
      }
      direction = "";
      if (diffY / distance > 0.5) {
        direction = "N";
      }
      if (diffY / distance < -0.5) {
        direction += "S";
      }
      if (diffX / distance > 0.5) {
        direction += "W";
      }
      if (diffX / distance < -0.5) {
        direction += "E";
      }
      this.setSprite(direction, this.frameCount++);
      this.nekoPosX -= (diffX / distance) * this.nekoSpeed;
      this.nekoPosY -= (diffY / distance) * this.nekoSpeed;
      this.nekoPosX = Math.min(Math.max(16, this.nekoPosX), window.innerWidth - 16);
      this.nekoPosY = Math.min(Math.max(16, this.nekoPosY), window.innerHeight - 16);
      this.updatePos();
      if (this.lastSaveTime == null) {
        // Throttled save - only save state occasionally to avoid performance issues
        this.lastSaveTime = 0;
      }
      currentTime = Date.now();
      if (currentTime - this.lastSaveTime > 1000) { // Save every 1 second
        this.saveNekoState();
        return this.lastSaveTime = currentTime;
      }
    }

    idle() {
      var availableAnims;
      boundMethodCheck(this, _class);
      this.idleTime++;
      if (this.idleTime > 10 && Math.floor(Math.random() * 200) === 0 && !this.idleAnimation) {
        availableAnims = ["sleeping", "scratchSelf"];
        if (this.nekoPosX < 32) {
          availableAnims.push("scratchWallW");
        }
        if (this.nekoPosY < 32) {
          availableAnims.push("scratchWallN");
        }
        if (this.nekoPosX > window.innerWidth - 32) {
          availableAnims.push("scratchWallE");
        }
        if (this.nekoPosY > window.innerHeight - 32) {
          availableAnims.push("scratchWallS");
        }
        this.idleAnimation = availableAnims[Math.floor(Math.random() * availableAnims.length)];
      }
      switch (this.idleAnimation) {
        case "sleeping":
          if (this.idleAnimationFrame < 8) {
            this.setSprite("tired", 0);
          } else {
            this.setSprite("sleeping", Math.floor(this.idleAnimationFrame / 4));
          }
          if (this.idleAnimationFrame > 192) {
            this.resetIdleAnimation();
          }
          break;
        case "scratchWallN":
        case "scratchWallS":
        case "scratchWallE":
        case "scratchWallW":
        case "scratchSelf":
          this.setSprite(this.idleAnimation, this.idleAnimationFrame);
          if (this.idleAnimationFrame > 9) {
            this.resetIdleAnimation();
          }
          break;
        default:
          this.setSprite("idle", 0);
          return;
      }
      return this.idleAnimationFrame++;
    }

    setSprite(name, frameNumber) {
      var sprite;
      boundMethodCheck(this, _class);
      sprite = this.spriteSets[name][frameNumber % this.spriteSets[name].length];
      return this.nekoEl.style.backgroundPosition = `${sprite[0] * 32}px ${sprite[1] * 32}px`;
    }

    resetIdleAnimation() {
      boundMethodCheck(this, _class);
      this.idleAnimation = void 0;
      return this.idleAnimationFrame = 0;
    }

    updatePos() {
      boundMethodCheck(this, _class);
      // Use translate3d for smooth GPU-accelerated movement and avoid layout thrash
      this.nekoEl.style.transform = `translate3d(${this.nekoPosX - 16}px, ${this.nekoPosY - 16}px, 0)`;
      return;
    }

    setSkin(skin) {
      var url, urls;
      boundMethodCheck(this, _class);
      skin = skin || 'default';
      urls = JSON.parse(this.element.dataset.skinUrls);
      url = urls[skin];
      if (url) {
        return this.nekoEl.style.backgroundImage = `url('${url}')`;
      } else {
        return console.warn(`No URL for skin ${skin}`);
      }
    }

    explodeHearts() {
      var centerX, centerY, heart, i, j, offsetX, offsetY, parent, rect, results, scrollLeft, scrollTop;
      boundMethodCheck(this, _class);
      parent = this.nekoEl.parentElement;
      rect = this.nekoEl.getBoundingClientRect();
      scrollLeft = window.scrollX || document.documentElement.scrollLeft;
      scrollTop = window.scrollY || document.documentElement.scrollTop;
      centerX = rect.left + rect.width / 2 + scrollLeft;
      centerY = rect.top + rect.height / 2 + scrollTop;
      results = [];
      if (!this._heartMap) this._heartMap = new WeakMap();
      document.addEventListener('turbo:before-cache', () => {
        document.querySelectorAll('.heart').forEach(heart => heart.remove());
        this._heartMap = null; // Optional: Reset for next session (WeakMap auto-GCs)
      });
      for (i = j = 0; j < 20; i = ++j) {
        heart = document.createElement('div');
        heart.className = 'heart';
        // Use custom SVG heart instead of text emoji
        heart.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36"><path fill="#e45c9c" d="M35.885 11.833c0-5.45-4.418-9.868-9.867-9.868-3.308 0-6.227 1.633-8.018 4.129-1.791-2.496-4.71-4.129-8.017-4.129-5.45 0-9.868 4.417-9.868 9.868 0 .772.098 1.52.266 2.241C1.751 22.587 11.216 31.568 18 34.034c6.783-2.466 16.249-11.447 17.617-19.959.17-.721.268-1.469.268-2.242z" /></svg>';
        offsetX = (Math.random() - 0.5) * 50;
        offsetY = (Math.random() - 0.5) * 50;
        heart.style.left = `${centerX}px`;
        heart.style.top = `${centerY}px`;
        heart.style.transform = '';

        // Set randomized CSS variables for slow rotation & skew (CSS animation consumes these)
        var startRot = Math.floor(Math.random() * 360); // initial rotation in degrees
        var rotRange = (Math.random() * 40 - 20); // -20..20 degrees variation
        var rotDuration = (Math.random() * 6 + 4).toFixed(2); // 4..10 seconds
        var skewX = (Math.random() * 24 - 12).toFixed(2); // -12..12 deg
        var skewY = (Math.random() * 16 - 8).toFixed(2); // -8..8 deg
        var burstX = (offsetX * 2).toFixed(2); // double offset for burst
        var burstY = (offsetY * 2).toFixed(2); // double offset for burst

        heart.style.setProperty('--start-rot', `${startRot}deg`);
        heart.style.setProperty('--rot-range', `${rotRange}deg`);
        heart.style.setProperty('--rot-duration', `${rotDuration}s`);
        heart.style.setProperty('--skew-x', `${skewX}deg`);
        heart.style.setProperty('--skew-y', `${skewY}deg`);
        heart.style.setProperty('--burst-x', `${burstX}px`);
        heart.style.setProperty('--burst-y', `${burstY}px`);
        heart.style.animationDelay = '0s';
        parent.appendChild(heart);
        this._heartMap.set(heart, { created: Date.now(), burstX, burstY, startRot, rotRange });
        results.push(setTimeout(() => {
          if (heart.parentElement) {
            parent.removeChild(heart);
            this._heartMap.delete(heart);
          }
        }, 1000));
      }
      return results;
    }

  };

  STORAGE_KEY = 'oneko-state';

  return _Class;

}).call(this);
