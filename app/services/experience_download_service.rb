# frozen_string_literal: true

require "zip"

# Service to find and prepare experiences for offline download
class ExperienceDownloadService
  def self.find_experience_by_title(title)
    return nil if title.blank?

    # Search for experiences by title (case insensitive, partial match)
    experience = Experience.approved
                           .offline_available
                           .where("lower(title) LIKE ?", "%#{title.downcase}%")
                           .first

    return unless experience

      format_experience_for_email(experience)
  end

  def self.find_experience_object_by_title(title)
    return nil if title.blank?

    # Search for experiences by title (case insensitive, partial match)
    Experience.approved
              .offline_available
              .where("lower(title) LIKE ?", "%#{title.downcase}%")
              .first
  end

  def self.find_all_offline_experiences
    experiences = Experience.approved
                            .offline_available
                            .order(:title)
                            .limit(50) # Reasonable limit for email listing

    experiences.map { |exp| format_experience_for_email(exp) }
  end

  def self.suggest_similar_experiences(title)
    return [] if title.blank?

    # Try to find similar experiences for suggestions
    Experience.approved
              .offline_available
              .where("lower(title) LIKE ? OR lower(description) LIKE ?",
                     "%#{title.downcase}%", "%#{title.downcase}%")
              .limit(5)
              .map { |exp| format_experience_for_email(exp) }
  end

  def self.generate_zip_file(experience)
    return nil unless experience&.offline_available? && experience.html_file.attached?

    begin
      # Create an in-memory ZIP file to avoid writing decrypted data to disk
      zip_io = StringIO.new

      # Create the ZIP file in memory using the correct API
      Zip::OutputStream.write_buffer(zip_io) do |zos|
        # Add the main HTML file
        html_content = experience.html_file.download
        zos.put_next_entry("#{sanitize_filename(experience.title)}.html")
        zos.write(html_content)

        # Add any additional assets if they exist
        if experience.respond_to?(:assets) && experience.assets.any?
          index = 0
          while index < experience.assets.length
            asset = experience.assets[index]
            index += 1
            next unless asset.attached?

            # Get the asset content and add to ZIP
            asset_content = asset.download
            extension = File.extname(asset.filename.to_s)
            filename = "assets/asset_#{index - 1}#{extension}"
            zos.put_next_entry(filename)
            zos.write(asset_content)
          end
        end

        # Add a README file with instructions
        readme_content = generate_readme_content(experience)
        zos.put_next_entry("README.txt")
        zos.write(readme_content)
      end

      # Return the StringIO object positioned at the beginning
      zip_io.rewind
      zip_io
    rescue StandardError => e
      Rails.logger.error "Failed to generate ZIP file for experience #{experience.id}: #{e.message}"
      nil
    end
  end

  def self.format_experience_for_email(experience)
    {
      id: experience.id,
      title: experience.title,
      author: experience.author,
      description: experience.description,
      url: generate_experience_url(experience),
      content: extract_experience_content(experience),
      offline_available: experience.offline_available,
      created_at: experience.created_at
    }
  end

  class << self
    private

    def sanitize_filename(filename)
      # Remove or replace characters that are problematic in filenames
      filename.gsub(/[^\w\-_.]/, "_").gsub(/_+/, "_").strip
    end

    def generate_readme_content(experience)
      <<~README
        LibreVerse Offline Experience
        ============================

        Title: #{experience.title}
        Author: #{experience.author}
        Downloaded: #{Time.current.strftime('%B %d, %Y at %l:%M %p')}

        Description:
        #{experience.description}

        Instructions:
        1. Open the HTML file in any web browser to view the experience
        2. All necessary files are included in this ZIP package
        3. No internet connection required for viewing

        For more experiences, visit: #{generate_experience_url(experience).split('/experiences').first}

        ---
        This offline package was generated by LibreVerse
        #{generate_experience_url(experience).split('/experiences').first}
      README
    end

    def generate_experience_url(experience)
      protocol = LibreverseInstance.force_ssl? ? "https" : "http"
      "#{protocol}://#{LibreverseInstance.instance_domain}/experiences/#{experience.id}"
    end

    def extract_experience_content(experience)
      return "" unless experience.html_file.attached?

      begin
        # Read the HTML file content
        html_content = experience.html_file.download

        # Clean up for offline use (remove any external dependencies)
        clean_html_for_offline(html_content)
      rescue StandardError => e
        Rails.logger.error "Failed to extract experience content: #{e.message}"
        "<p>Error: Could not extract experience content</p>"
      end
    end

    def clean_html_for_offline(html_content)
      # Basic HTML cleaning for offline use
      # This could be expanded to handle more complex cases

      # Convert relative URLs to absolute if needed
      # Remove or inline external resources
      # For now, return as-is since experiences should already be self-contained

      html_content
    end
  end
end
