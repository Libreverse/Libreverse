#!/usr/bin/env perl

use strict;
use warnings;
use File::Temp qw(tempfile tempdir);
use File::Path qw(remove_tree);
use File::Copy qw(copy);
use Cwd        qw(abs_path);
use IPC::Open3;
use Symbol qw(gensym);

# Arrays to store status for internal tracking
my @sequential_status;
my @sequential_tools;
my @parallel_tools;
my @tool_log_files;
my @tool_exit_codes;
my @parallel_status;
my @pids;

print "Running static analysis tasks...\n";

# Define RUBYOPT for reuse
my $rubyopt = "--yjit --yjit-exec-mem-size=2 --yjit-mem-size=3 --yjit-call-threshold=1 --yjit-cold-threshold=1000000 --yjit-code-gc";

# --- Sequential Tasks --- Function to run and check command
sub run_command {
  my ($tool_name, @cmd) = @_;
  my $status = "[OK]";
  my @output;
  my $exit_code = 0;    # Default to success

  push @sequential_tools, $tool_name;

  # Use IPC::Open3 to capture STDOUT and STDERR separately
  my $stdout_fh = gensym;    # Create anonymous filehandles
  my $stderr_fh = gensym;
  # We don't need to write to child's STDIN
  my $child_pid = open3(undef, $stdout_fh, $stderr_fh, @cmd);

  unless ($child_pid) {
    warn "Failed to execute $tool_name: $!\n";
    print "$tool_name [NOTOK] (Execution failed)\n";
    push @sequential_status, "[NOTOK]";
    return;
  }

  # Read output from both handles
  my $stdout_content = do { local $/; <$stdout_fh> };
  my $stderr_content = do { local $/; <$stderr_fh> };
  push @output, $stdout_content if defined $stdout_content;
  push @output, $stderr_content if defined $stderr_content;

  # Wait for the child process and get exit status
  waitpid($child_pid, 0);
  $exit_code = $? >> 8;

  if ($exit_code != 0) {
    print "$tool_name [NOTOK] (Exit Code: $exit_code)\n";
    if (@output) {
      print "--- Output for $tool_name ---\n";
      print @output;
      print "\n" unless $output[-1] =~ /\n$/;
      print "--- End Output for $tool_name ---\n";
    }
    $status = "[NOTOK]";
  } else {
    print "$tool_name [OK]\n";
    $status = "[OK]";
  }
  push @sequential_status, $status;
}

# Run Prettier first (without timeout)
my $prettier_tool_name = "Prettier";
push @sequential_tools, $prettier_tool_name;
my $prettier_status = "[OK]";
my ($prettier_fh, $prettier_output_log) = tempfile(UNLINK => 1);  # Auto-cleanup

my $prettier_cmd = ["bun", "prettier", "--write", "."];
my $prettier_exit_code;
my @prettier_raw_output;

# Removed alarm timeout
eval {
  open(my $prettier_out_fh, "-|", @$prettier_cmd)
    or die "Failed to run Prettier: $!";
  @prettier_raw_output = <$prettier_out_fh>;
  close $prettier_out_fh;
  $prettier_exit_code = $? >> 8;
};

if ($@) {
  warn "$@";
  $prettier_exit_code = 1;
}

# Filter output
my @prettier_filtered_output = grep { !/unchanged/ } @prettier_raw_output;

if ($prettier_exit_code != 0) {
  print "$prettier_tool_name [NOTOK] (Exit Code: $prettier_exit_code)\n";
  if (@prettier_filtered_output) {
    print "--- Output for $prettier_tool_name ---\n";
    print @prettier_filtered_output;
    print "--- End Output for $prettier_tool_name ---\n";
  }
  $prettier_status = "[NOTOK]";
} else {
  print "$prettier_tool_name [OK]\n";
  $prettier_status = "[OK]";
}
push @sequential_status, $prettier_status;

# Run scripts/remove_frozen.pl before Rubocop
run_command("Remove Frozen", "perl", "scripts/remove_frozen.pl");

# Run other sequential commands with RUBYOPT for Ruby commands
run_command("Rubocop", "sh", "-c",
  "RUBYOPT='$rubyopt' bin/rubocop -A");

run_command("HAML Whitespace Cleanup", "sh", "-c",
  "find . -name '*.haml' -not -path './node_modules/*' -not -path './.git/*' -exec sed -i '' 's/[[:space:]]*\$//' {} +");

run_command("haml-lint", "sh", "-c",
  "RUBYOPT='$rubyopt' bundle exec haml-lint --auto-correct .");

# ERB formatting and linting with RUBYOPT
run_command("ERB Format", "sh", "-c",
  "command -v bundle >/dev/null && bundle exec erb-format --help >/dev/null 2>&1 && RUBYOPT='$rubyopt' find app -name '*.erb' -not -path 'app/views/layouts/mailer.html.erb' -print0 | xargs -0 -r bundle exec erb-format --write || true");

run_command("ERB Lint", "sh", "-c",
  "command -v bundle >/dev/null && bundle exec erblint --version >/dev/null 2>&1 && RUBYOPT='$rubyopt' bundle exec erblint --config .erb-lint.yml app/views || true");

run_command("Perltidy", "sh", "-c",
  q{if find . -type f \( -name '*.pl' -o -name '*.pm' -o -name '*.t' -o -name '*.psgi' \) \
                     -not -path './vendor/*' -not -path './node_modules/*' -not -path './.git/*' -print -quit | grep -q .; then
    find . -type f \( -name '*.pl' -o -name '*.pm' -o -name '*.t' -o -name '*.psgi' \) \
           -not -path './vendor/*' -not -path './node_modules/*' -not -path './.git/*' -print0 \
           | xargs -0 perltidy -pro=.perltidyrc -b -opath=/tmp/;
    exit $?;
else
    exit 0;
fi});

run_command("shfmt", "sh", "-c",
  q{if find . -type f -name '*.sh' -not -path './vendor/*' -not -path './node_modules/*' -not -path './.git/*' -print -quit | grep -q .; then
    find . -type f -name '*.sh' \
           -not -path './vendor/*' -not -path './node_modules/*' -not -path './.git/*' -print0 \
           | xargs -0 shfmt -w;
else
    exit 0;
fi});

run_command("eslint", "bun", "eslint", ".", "--fix");

run_command("Stylelint", "sh", "-c", "bun stylelint '**/*.scss' --fix");

run_command("Coffeelint Fix", "sh", "-c",
  "command -v bun >/dev/null && bun coffeelint --help >/dev/null 2>&1 && find . -name '*.coffee' -not -path './node_modules/*' -print0 | xargs -0 -r bun coffeelint --fix -f coffeelint.json || true");

run_command("markdownlint", "sh", "-c",
  "bun markdownlint-cli2 '**/*.md' '!**/node_modules/**' '!**/licenses/**' '!**/.codeql/**' --fix --config .markdownlint-cli2.jsonc");

run_command("bundle update", "sh", "-c",
  "RUBYOPT='$rubyopt' bundle update");

run_command("bun update", "bun", "update");

run_command("i18n Validation", "sh", "-c",
  "RUBYOPT='$rubyopt' ruby scripts/i18n_validate.rb");

# --- Parallel Execution Setup ---
my $log_dir = tempdir(CLEANUP => 1);    # Auto-cleanup

# Function to run a command in the background and log output
sub run_in_background {
  my ($tool_index, $tool_name, @cmd) = @_;

  my $log_filename = $tool_name;
  $log_filename =~ tr/A-Z/a-z/;
  $log_filename =~ tr/ /_/s;
  my $log_file = "$log_dir/${log_filename}.log";

  $tool_log_files[$tool_index] = $log_file;

  my $pid = fork();
  die "Cannot fork for $tool_name: $!" unless defined $pid;

  if ($pid == 0) {
    # Child process
    open STDOUT, ">", $log_file
      or die "Cannot redirect STDOUT to $log_file: $!";
    open STDERR, ">&", STDOUT or die "Cannot dup STDOUT for STDERR: $!";
    select((select(STDOUT), $| = 1)[0]);    # Autoflush
    select((select(STDERR), $| = 1)[0]);    # Autoflush

    print STDOUT "--------------------------------------------------\n";
    print STDOUT "--- $tool_name Results ---\n";
    print STDOUT "--------------------------------------------------\n";

    system(@cmd);
    my $child_exit_code = $? >> 8;

    print STDOUT "\n--------------------------------------------------\n";
    print STDOUT
      "--- End of $tool_name Results (Exit Code: $child_exit_code) ---\n";
    print STDOUT "--------------------------------------------------\n";

    exit $child_exit_code;
  }
  # Parent process
  $pids[$tool_index] = $pid;
}

# --- Define and run parallel commands ---
@parallel_tools = ("Fasterer", "Typos", "Jest", "Brakeman", "Rails Tests", "hadolint");
my $num_tools = scalar @parallel_tools;

for my $i (0 .. $num_tools - 1) {
  my $tool_name = $parallel_tools[$i];
  $tool_exit_codes[$i] = -1;         # Initialize placeholder
  $parallel_status[$i] = "[PEND]";

  my @cmd;
  if ($tool_name eq "Fasterer") {
    @cmd = ("sh", "-c", "RUBYOPT='$rubyopt' fasterer");
  } elsif ($tool_name eq "Typos") {
    @cmd = ("typos");
  } elsif ($tool_name eq "Jest") {
    @cmd = (
      "sh", "-c",
      "NODE_OPTIONS='--experimental-vm-modules' npx jest --coverage=false"
    );
  } elsif ($tool_name eq "Brakeman") {
    @cmd = (
      "sh", "-c",
      "RUBYOPT='$rubyopt' brakeman -A --except WeakHash --quiet --no-summary --no-pager"
    );
  } elsif ($tool_name eq "Rails Tests") {
    @cmd = (
      "sh", "-c",
      "RUBYOPT='$rubyopt' bin/parallel_test"
    );
  } elsif ($tool_name eq "hadolint") {
    @cmd = (
      "sh", "-c",
      "command -v hadolint >/dev/null && hadolint Dockerfile || true"
    );
  }

  run_in_background($i, $tool_name, @cmd);
}

# --- Wait for all background jobs and collect exit codes ---
for my $i (0 .. $num_tools - 1) {
  my $pid       = $pids[$i];
  my $tool_name = $parallel_tools[$i];

  next if defined $pid && $pid == 0;    # Skip tasks marked as skipped
  unless (defined $pid) {               # Handle case where task wasn't launched
    warn "No PID found for $tool_name (index $i), skipping wait.\n";
    $parallel_status[$i] = "[ERROR]";
    next;
  }

  waitpid($pid, 0);
  my $exit_code = $? >> 8;
  $tool_exit_codes[$i] = $exit_code;

  if ($exit_code != 0) {
    print "$tool_name [NOTOK]\n";
    $parallel_status[$i] = "[NOTOK]";
  } else {
    print "$tool_name [OK]\n";
    $parallel_status[$i] = "[OK]";
  }
}

# --- Print results from log files ---
my $any_logs_printed = 0;
for my $i (0 .. $num_tools - 1) {
  my $tool_name = $parallel_tools[$i];
  my $log_file  = $tool_log_files[$i];
  my $exit_code = $tool_exit_codes[$i];
  my $pid       = $pids[$i];

  if (defined $pid && $pid != 0 && defined $exit_code && $exit_code != 0) {
    if (-f $log_file) {
      print "\n--- Log for $tool_name --- (Exit Code: $exit_code)\n";
      open my $log_fh, '<', $log_file or do {
        warn "Could not open log file $log_file: $!";
        next;
      };
      print <$log_fh>;
      close $log_fh;
      $any_logs_printed = 1;
    } else {
      print "\n!!! ERROR: Log File Not Found for $tool_name ($log_file) !!!\n";
      $any_logs_printed = 1;
    }
  }
}

print "\n" if $any_logs_printed;

# Determine exit code based on failures
my $exit_code = 0;
$exit_code = 1 if grep { $_ eq '[NOTOK]' } @sequential_status, @parallel_status;
exit $exit_code;