#!/usr/bin/env perl
use strict;
use warnings;
use FindBin;
use File::Glob 'bsd_glob';
use Term::ANSIColor;  # For colored output
require "$FindBin::Bin/../tui/twemoji.pm";  # Loads the exact file
Twemoji->import(qw(twemoji));  # Manually import the function
use utf8;  # Enable UTF-8 for Unicode
binmode STDOUT, ':encoding(UTF-8)';  # Set output encoding to UTF-8

system("echo \"ensuring TR...\" && source /opt/homebrew/opt/chruby/share/chruby/chruby.sh && source /opt/homebrew/opt/chruby/share/chruby/auto.sh && chruby truffleruby-24.2.1 && chruby truffleruby-24.2.1");

# Get terminal width
my $width = `tput cols` || 80;  # Default to 80 if tput fails
chomp $width;
my $box_width = 78;  # Fixed box width for better fit
my $line = "â•" x ($box_width);  # Unicode double line for polished look

# Overmind color palette (256-color indices)
my @overmind_colors = qw(224 111 150 182 186 147 216 110 174 115 175 116 218 217);
my $color_index = 0;  # To cycle through colors

# ANSI helpers for 256-color foreground and reset
my $RESET = "\e[0m";
sub _ansi_fg { my ($n) = @_; return sprintf("\e[38;5;%dm", $n); }

# Define fixed colors for different message types
my $header_color = _ansi_fg(182);
my $message_color = _ansi_fg(147);

# Function to get next color escape sequence
sub get_next_color {
    my $code = $overmind_colors[$color_index % @overmind_colors];
    $color_index++;
    return _ansi_fg($code);
}

# Clear screen for a fresh start
system('clear');

# Define banner lines
my @banner = (
    "  / /(_) |__  _ __ _____   _____ _ __ ___  ___ ",
    " / / | | '_ \\| '__/ _ \\ \\ / / _ \\ '__/ __|/ _ \\",
    "/ /__| | |_) | | |  __/\\ V /  __/ |  \\__ \\  __/",
    "\\____/_|_.__/|_|  \\___| \\_/ \\___|_|  |___/\\___|"
);

# Print header with banner
print $header_color;
print "â•”$lineâ•—\n";
foreach my $banner_line (@banner) {
    my $len = length($banner_line);
    my $side_spaces = int(($box_width - ($len + 1)) / 2);
    print "â•‘", " " x $side_spaces, $banner_line, " " x $side_spaces, " â•‘\n";
}
print "â•š$lineâ•\n";
print $RESET;

# Render a Twemoji brain emoji after the banner for flair
# print twemoji('ðŸ§ ');

# Function to display a task with status
sub run_task {
    my ($message, $command) = @_;
    print $message_color, twemoji('â–¶'), " $message", $RESET, "\n";
    system($command) == 0 or warn "Command failed: $command\n";
    print $message_color, "  ", twemoji('âœ…'), " Done", $RESET, "\n\n";
}

# Function to display a spinner during tasks
sub show_spinner {
    my ($message) = @_;
    print $message_color, "  ", twemoji('â³'), " $message", $RESET;
    my @spinner = ('|', '/', '-', '\\');
    for (1..10) {
        print "\r", $message_color, "  ", twemoji('â³'), " $message ", $spinner[$_ % 4], $RESET;
        select(undef, undef, undef, 0.1);  # Brief delay
    }
    print "\r", " " x ($width - 2), "\r";  # Clear line
}

#!/usr/bin/env perl
use strict;
use warnings;

# Define colors from the provided palette
my %COLORS = (
  reset  => "\033[0m",
  red    => "\033[38;5;174m",
  yellow => "\033[38;5;150m",
  cyan   => "\033[38;5;115m",
);

# Print messages as regular text (left-aligned)
print "\n";
print $COLORS{red}
  . $COLORS{cyan}
  . "Libreverse development startup in progress..."
  . $COLORS{reset} . "\n";
print $COLORS{yellow}
  . "This process may take a few minutes."
  . $COLORS{reset} . "\n";
print $COLORS{yellow}
  . "Please do not interrupt or close the terminal unless the time has gotten "
  . "\033[3mreally\033[23m"
  . " long."
  . $COLORS{reset} . "\n";
print "\n";

# Run tasks with visual feedback
show_spinner("Killing other overmind instances...");
run_task("Killing other overmind instances...", "pkill overmind > /dev/null 2>&1");

show_spinner("Unlinking the overmind socket...");
unlink '/tmp/.overmind.sock';
print $message_color, "  ", twemoji('âœ…'), " Done", $RESET, "\n\n";

show_spinner("Killing anything using the development SQLite database...");
run_task("Killing anything using the development SQLite database...", "cd .. && perl script/unlock_sqlite.pl > /dev/null 2>&1");;

show_spinner("Killing anything on port 3000...");
run_task("Killing anything on port 3000...", "fuser -k -TERM 3000/tcp > /dev/null 2>&1");

# Ensure mkcert root CA is installed and trusted (sudo once)
show_spinner("Configuring certificates for local http/3...");
run_task(
    "Ensuring mkcert root CA is trusted",
    q{mkcert -install >/dev/null 2>&1 || (command -v mkcert >/dev/null && mkcert -install)}
);

# ----------------------------------------------------------------------
# 1. Clean up any stale containers first (excluding persistent databases)
# ----------------------------------------------------------------------
print $message_color, twemoji('Broom'), " Cleaning up any stale containers...", $RESET, "\n";
system('podman rm -f libreverse-dev-detached-dragonflydb >/dev/null 2>&1');
print $message_color, "  ", twemoji('âœ…'), " Done", $RESET, "\n\n";

# ----------------------------------------------------------------------
# 2. Test podman with the hello container
# ----------------------------------------------------------------------
print $message_color, "Testing podman...", $RESET, "\n";

# First check if podman machine is running at all
my $machine_running = system('podman machine info >/dev/null 2>&1') == 0;
my $podman_ok = 0;

if ($machine_running) {
    # Machine is running, now test if containers work
    $podman_ok = system('podman run --rm quay.io/podman/hello >/dev/null 2>&1') == 0;
}

if ($podman_ok) {
    print $message_color, twemoji('Check Mark'), " podman works â€“ skipping recreation steps.", $RESET, "\n\n";
}
else {
    # ------------------------------------------------------------------
    # 2. podman broken â†’ ONE spinner for the whole recreation block
    # ------------------------------------------------------------------
    print $message_color, twemoji('Hourglass'), " podman failed. Recreating VM...", $RESET, "\n";

    # Start the spinner (it will animate for ~30 s â€“ enough for the whole block)
    show_spinner("Making sure podman behaves...");

    # ---- recreation steps (no individual spinners) -----------------
    run_task("Stopping podman machine",    "podman machine stop 2>/dev/null || true");
    run_task("Removing podman machine",    "podman machine rm -f 2>/dev/null || true");
    run_task("Clearing out podman data",   "rm -rf ~/.local/share/containers ~/.config/containers 2>/dev/null || true");
    run_task("Recreating podman VM",       "podman machine init --memory 2048 --cpus 1");
    run_task("Starting podman VM",         "podman machine start");

    # ------------------------------------------------------------------
    # 3. Final verification (still under the same spinner)
    # ------------------------------------------------------------------
    print $message_color, twemoji('Magnifying Glass'), " Verifying podman after recreation...", $RESET, "\n";
    if (system('podman run --rm quay.io/podman/hello >/dev/null 2>&1') == 0) {
        print $message_color, twemoji('Check Mark'), " podman is now working!", $RESET, "\n\n";
    }
    else {
        print $message_color, twemoji('Cross Mark'), " Still broken â€“ check logs / permissions.", $RESET, "\n\n";
    }

    # Overwrite the spinner line with a final status
    print "\r", " " x ($width - 2), "\r";               # clear spinner line
    print $message_color, twemoji('Check Mark'), " Making sure podman behaves... Done", $RESET, "\n\n";
}

# Set environment variables for Overmind and all child processes
$ENV{OBJC_DISABLE_INITIALIZE_FORK_SAFETY} = 'YES';
$ENV{OVERMIND_SOCKET}        = '/tmp/.overmind.sock';
$ENV{OVERMIND_TMUX_CONFIG}   = '/config/overmind-tmux.conf';
$ENV{OVERMIND_RESTART}       = 'all';
$ENV{OVERMIND_COLORS}        = '224,111,150,182,186,147,216,110,174,115,175,116,218,217';
$ENV{OVERMIND_CAN_DIE}       = 'startup-message';

# Check if databases are running before starting
print $message_color, twemoji('Database'), " Checking database status...\n", $RESET;
my $tidb_running = system("podman ps --format '{{.Names}}' | grep -q libreverse-dev-tidb") == 0;
my $postgres_running = system("podman ps --format '{{.Names}}' | grep -q libreverse-dev-postgres") == 0;
my $dragonfly_running = system("podman ps --format '{{.Names}}' | grep -q libreverse-dev-dragonflydb") == 0;

my $missing_databases = 0;

if (!$tidb_running) {
    print $message_color, twemoji('Cross Mark'), " TiDB database not running!\n", $RESET;
    print $message_color, "  Run: bin/db-start\n", $RESET;
    $missing_databases = 1;
}
if (!$postgres_running) {
    print $message_color, twemoji('Cross Mark'), " PostgreSQL database not running!\n", $RESET;
    print $message_color, "  Run: bin/db-start\n", $RESET;
    $missing_databases = 1;
}
if (!$dragonfly_running) {
    print $message_color, twemoji('Cross Mark'), " DragonflyDB database not running!\n", $RESET;
    print $message_color, "  Run: bin/db-start\n", $RESET;
    $missing_databases = 1;
}

if ($missing_databases) {
    print $message_color, "\n", twemoji('Warning Sign'), " Required databases are not running. Please start them first.\n", $RESET;
    print $message_color, "  Run: bin/db-start\n", $RESET;
    exit 1;
}

print $message_color, twemoji('Check Mark'), " All databases are running!\n\n", $RESET;
run_task("Preloading bootsnap cache...", "bundle exec bootsnap precompile .");
exec 'overmind', 'start', '-f', 'config/dev-processes.yml', @ARGV;