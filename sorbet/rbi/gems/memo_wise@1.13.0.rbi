# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `memo_wise` gem.
# Please instead update this file by running `bin/tapioca gem memo_wise`.


# MemoWise is the wise choice for memoization in Ruby.
#
# - **Q:** What is *memoization*?
# - **A:** [via Wikipedia](https://en.wikipedia.org/wiki/Memoization):
#
#          [Memoization is] an optimization technique used primarily to speed up
#          computer programs by storing the results of expensive function
#          calls and returning the cached result when the same inputs occur
#          again.
#
# To start using MemoWise in a class or module:
#
#   1. Add `prepend MemoWise` to the top of the class or module
#   2. Call {.memo_wise} to implement memoization for a given method
#
# **See Also:**
#
#   - {.memo_wise} for API and usage examples.
#   - {file:README.md} for general project information.
#
# source://memo_wise//lib/memo_wise/internal_api.rb#3
module MemoWise
  # source://memo_wise//lib/memo_wise.rb#44
  def initialize(*_arg0, **_arg1, &_arg2); end

  # Presets the memoized result for the given method to the result of the given
  # block.
  #
  # This method is for situations where the caller *already* has the result of
  # an expensive method call, and wants to preset that result as memoized for
  # future calls. In other words, the memoized method will be called *zero*
  # times rather than once.
  #
  # NOTE: Currently, no attempt is made to validate that the given arguments are
  # valid for the given method.
  #
  # @example
  #   class Example
  #   prepend MemoWise
  #   attr_reader :method_called_times
  #
  #   def method_to_preset
  #   @method_called_times = (@method_called_times || 0) + 1
  #   "A"
  #   end
  #   memo_wise :method_to_preset
  #   end
  #
  #   ex = Example.new
  #
  #   ex.preset_memo_wise(:method_to_preset) { "B" }
  #
  #   ex.method_to_preset #=> "B"
  #
  #   ex.method_called_times #=> nil
  # @param args [Array] (Optional) If the method takes positional args, these are the values of
  #   position args for which the given block's result will be preset as the
  #   memoized result.
  # @param kwargs [Hash] (Optional) If the method takes keyword args, these are the keys and values
  #   of keyword args for which the given block's result will be preset as the
  #   memoized result.
  # @param method_name [Symbol] Name of a method previously set up with `#memo_wise`.
  # @raise [ArgumentError]
  # @return [void]
  # @yieldreturn [Object] The result of the given block will be preset as memoized for future calls
  #   to the given method.
  #
  # source://memo_wise//lib/memo_wise.rb#433
  def preset_memo_wise(method_name, *args, **kwargs); end

  # Resets memoized results of a given method, or all methods.
  #
  # There are three _reset modes_ depending on how this method is called:
  #
  # **method + args** mode (most specific)
  #
  # - If given `method_name` and *either* `args` *or* `kwargs` *or* both:
  # - Resets *only* the memoized result of calling `method_name` with those
  #   particular arguments.
  #
  # **method** (any args) mode
  #
  # - If given `method_name` and *neither* `args` *nor* `kwargs`:
  # - Resets *all* memoized results of calling `method_name` with any arguments.
  #
  # **all methods** mode (most general)
  #
  # - If *not* given `method_name`:
  # - Resets all memoized results of calling *all methods*.
  #
  # @example
  #   class Example
  #   prepend MemoWise
  #
  #   def method_to_reset(x)
  #   @method_called_times = (@method_called_times || 0) + 1
  #   end
  #   memo_wise :method_to_reset
  #   end
  #
  #   ex = Example.new
  #
  #   ex.method_to_reset("a") #=> 1
  #   ex.method_to_reset("a") #=> 1
  #   ex.method_to_reset("b") #=> 2
  #   ex.method_to_reset("b") #=> 2
  #
  #   ex.reset_memo_wise(:method_to_reset, "a") # reset "method + args" mode
  #
  #   ex.method_to_reset("a") #=> 3
  #   ex.method_to_reset("a") #=> 3
  #   ex.method_to_reset("b") #=> 2
  #   ex.method_to_reset("b") #=> 2
  #
  #   ex.reset_memo_wise(:method_to_reset) # reset "method" (any args) mode
  #
  #   ex.method_to_reset("a") #=> 4
  #   ex.method_to_reset("b") #=> 5
  #
  #   ex.reset_memo_wise # reset "all methods" mode
  # @param args [Array] (Optional) If the method takes positional args, these are the values of
  #   position args for which the memoized result will be reset.
  # @param kwargs [Hash] (Optional) If the method takes keyword args, these are the keys and values
  #   of keyword args for which the memoized result will be reset.
  # @param method_name [Symbol, nil] (Optional) Name of a method previously set up with `#memo_wise`. If not
  #   given, will reset *all* memoized results for *all* methods.
  # @raise [ArgumentError]
  # @return [void]
  #
  # source://memo_wise//lib/memo_wise.rb#540
  def reset_memo_wise(method_name = T.unsafe(nil), *args, **kwargs); end

  class << self
    # Private setup method, called automatically by `prepend MemoWise` in a class.
    #
    # @example
    #   class Example
    #   prepend MemoWise
    #   end
    # @param target [Class] The `Class` into to prepend the MemoWise methods e.g. `memo_wise`
    # @private
    # @see https://ruby-doc.org/3.3.1/Module.html#method-i-prepend
    #
    # source://memo_wise//lib/memo_wise.rb#89
    def prepended(target); end
  end
end

# source://memo_wise//lib/memo_wise.rb#51
module MemoWise::CreateMemoWiseStateOnExtended
  # source://memo_wise//lib/memo_wise.rb#52
  def extended(base); end
end

# source://memo_wise//lib/memo_wise.rb#67
module MemoWise::CreateMemoWiseStateOnIncluded
  # source://memo_wise//lib/memo_wise.rb#68
  def included(base); end
end

# source://memo_wise//lib/memo_wise.rb#59
module MemoWise::CreateMemoWiseStateOnInherited
  # source://memo_wise//lib/memo_wise.rb#60
  def inherited(subclass); end
end

# source://memo_wise//lib/memo_wise/internal_api.rb#4
class MemoWise::InternalAPI
  class << self
    # @param method [UnboundMethod] a method being memoized
    # @return [String] the arguments string to use when defining our new
    #   memoized version of the method
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#69
    def args_str(method); end

    # @param method [UnboundMethod] a method being memoized
    # @return [String] the arguments string to use when calling the original
    #   method in our new memoized version of the method, i.e. when setting a
    #   memoized value
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#86
    def call_str(method); end

    # Create initial mutable state to store memoized values if it doesn't
    # already exist
    #
    # @param obj [Object] Object in which to create mutable state to store future memoized values
    # @return [Object] the passed-in obj
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#12
    def create_memo_wise_state!(obj); end

    # @param method [UnboundMethod] a method being memoized
    # @return [String] the string to use as a hash key when looking up a
    #   memoized value, based on the method's arguments
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#103
    def key_str(method); end

    # @param method [UnboundMethod] a method to categorize based on the types of
    #   arguments it has
    # @return [Symbol] one of:
    #   - :none (example: `def foo`)
    #   - :one_required_positional (example: `def foo(a)`)
    #   - :one_required_keyword (example: `def foo(a:)`)
    #   - :multiple_required (examples: `def foo(a, b)`, `def foo(a:, b:)`, `def foo(a, b:)`)
    #   - :splat (examples: `def foo(a=1)`, `def foo(a, *b)`)
    #   - :double_splat (examples: `def foo(a: 1)`, `def foo(a:, **b)`)
    #   - :splat_and_double_splat (examples: `def foo(a=1, b: 2)`, `def foo(a=1, **b)`, `def foo(*a, **b)`)
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#46
    def method_arguments(method); end

    # Returns visibility of an instance method defined on class `target`.
    #
    # @param method_name [Symbol] Name of existing *instance* method find the visibility of.
    # @param target [Class, Module] The class to which we are prepending MemoWise to provide memoization.
    # @raise ArgumentError
    #   Raises `ArgumentError` unless `method_name` is a `Symbol` corresponding
    #   to an existing **instance** method defined on `klass`.
    # @return [:private, :protected, :public] Visibility of existing instance method of the class.
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#160
    def method_visibility(target, method_name); end

    # Find the original class for which the given class is the corresponding
    # "singleton class".
    #
    # See https://stackoverflow.com/questions/54531270/retrieve-a-ruby-object-from-its-singleton-class
    #
    # @param klass [Class] Singleton class to find the original class of
    # @raise ArgumentError
    #   Raises if `klass` is not a singleton class.
    # @return Class
    #   Original class for which `klass` is the singleton class.
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#126
    def original_class_from_singleton(klass); end

    # Convention we use for renaming the original method when we replace with
    # the memoized version in {MemoWise.memo_wise}.
    #
    # @param method_name [Symbol] Name for which to return the renaming for the original method
    # @return [Symbol] Renamed method to use for the original method with name `method_name`
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#141
    def original_memo_wised_name(method_name); end

    # Validates that {.memo_wise} has already been called on `method_name`.
    #
    # @param method_name [Symbol] Name of method to validate has already been setup with {.memo_wise}
    # @param target [Class, Module] The class to which we are prepending MemoWise to provide memoization.
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#179
    def validate_memo_wised!(target, method_name); end

    private

    # :nocov:
    #
    # @param klass [Class] Singleton class to find the original class of
    # @return Class
    #   Original class for which `klass` is the singleton class.
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#210
    def find_attached_object(klass); end

    # @param target [Class, Module] The class to which we are prepending MemoWise to provide memoization.
    # @return [Class] where we look for method definitions
    #
    # source://memo_wise//lib/memo_wise/internal_api.rb#190
    def target_class(target); end
  end
end

# source://memo_wise//lib/memo_wise/internal_api.rb#33
MemoWise::InternalAPI::DOUBLE_SPLAT = T.let(T.unsafe(nil), Symbol)

# source://memo_wise//lib/memo_wise/internal_api.rb#31
MemoWise::InternalAPI::MULTIPLE_REQUIRED = T.let(T.unsafe(nil), Symbol)

# source://memo_wise//lib/memo_wise/internal_api.rb#28
MemoWise::InternalAPI::NONE = T.let(T.unsafe(nil), Symbol)

# source://memo_wise//lib/memo_wise/internal_api.rb#30
MemoWise::InternalAPI::ONE_REQUIRED_KEYWORD = T.let(T.unsafe(nil), Symbol)

# source://memo_wise//lib/memo_wise/internal_api.rb#29
MemoWise::InternalAPI::ONE_REQUIRED_POSITIONAL = T.let(T.unsafe(nil), Symbol)

# source://memo_wise//lib/memo_wise/internal_api.rb#32
MemoWise::InternalAPI::SPLAT = T.let(T.unsafe(nil), Symbol)

# source://memo_wise//lib/memo_wise/internal_api.rb#34
MemoWise::InternalAPI::SPLAT_AND_DOUBLE_SPLAT = T.let(T.unsafe(nil), Symbol)

# source://memo_wise//lib/memo_wise/version.rb#4
MemoWise::VERSION = T.let(T.unsafe(nil), String)
