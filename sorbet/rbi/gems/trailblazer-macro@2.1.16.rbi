# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `trailblazer-macro` gem.
# Please instead update this file by running `bin/tapioca gem trailblazer-macro`.


# source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#1
module Trailblazer; end

# source://trailblazer-macro//lib/trailblazer/macro.rb#81
module Trailblazer::Activity::DSL::Linear::Helper
  extend ::Forwardable

  # source://trailblazer-macro//lib/trailblazer/macro.rb#88
  def Each(*args, **_arg1, &block); end

  # source://trailblazer-macro//lib/trailblazer/macro.rb#88
  def Model(*args, **_arg1, &block); end

  # source://trailblazer-macro//lib/trailblazer/macro.rb#88
  def Nested(*args, **_arg1, &block); end

  # source://trailblazer-macro//lib/trailblazer/macro.rb#88
  def Rescue(*args, **_arg1, &block); end

  # source://trailblazer-macro//lib/trailblazer/macro.rb#88
  def Wrap(*args, **_arg1, &block); end
end

# source://trailblazer-macro//lib/trailblazer/macro.rb#83
Trailblazer::Activity::DSL::Linear::Helper::Constants::Model = Trailblazer::Macro::Model

# source://trailblazer-macro//lib/trailblazer/macro.rb#82
Trailblazer::Activity::DSL::Linear::Helper::Constants::Policy = Trailblazer::Macro::Policy

# source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#2
module Trailblazer::Macro
  class << self
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#85
    def Each(block_activity = T.unsafe(nil), dataset_from: T.unsafe(nil), item_key: T.unsafe(nil), id: T.unsafe(nil), collect: T.unsafe(nil), **dsl_options_for_iterated, &block); end

    # source://trailblazer-macro//lib/trailblazer/macro/model.rb#4
    def Model(model_class = T.unsafe(nil), action = T.unsafe(nil), find_by_key = T.unsafe(nil), id: T.unsafe(nil), not_found_terminus: T.unsafe(nil)); end

    # {Nested} macro.
    # DISCUSS: rename auto_wire => static
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#5
    def Nested(callable, id: T.unsafe(nil), auto_wire: T.unsafe(nil)); end

    # source://trailblazer-macro//lib/trailblazer/macro/rescue.rb#5
    def Rescue(*exceptions, handler: T.unsafe(nil), id: T.unsafe(nil), &block); end

    # TODO: {user_wrap}: rename to {wrap_handler}.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/wrap.rb#4
    def Wrap(user_wrap, id: T.unsafe(nil), &block); end

    # source://trailblazer-macro//lib/trailblazer/macro.rb#46
    def block_activity_for(block_activity, &block); end

    # source://trailblazer-macro//lib/trailblazer/macro.rb#73
    def id_for(user_proc, **options); end

    # DSL options added to {block_activity} to implement {collect: true}.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#171
    def options_for_collect(collect:); end

    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#180
    def options_for_dataset_from(dataset_from:); end

    # source://trailblazer-macro//lib/trailblazer/macro.rb#38
    def task_adapter_for_decider(decider_with_step_interface, variable_name:); end

    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#161
    def task_wrap_for_iterated(dsl_options); end
  end
end

# Run {user_proc} with "step interface" and assign its return value to ctx[@variable_name].
# This is experimental.
#
# @private
#
# source://trailblazer-macro//lib/trailblazer/macro.rb#22
class Trailblazer::Macro::AssignVariable
  # name of the ctx variable we want to assign the return_value of {user_proc} to.
  #
  # @return [AssignVariable] a new instance of AssignVariable
  #
  # source://trailblazer-macro//lib/trailblazer/macro.rb#24
  def initialize(return_value_step, variable_name:); end

  # source://trailblazer-macro//lib/trailblazer/macro.rb#29
  def call(_arg0, **circuit_options); end
end

# source://trailblazer-macro//lib/trailblazer/macro/each.rb#3
class Trailblazer::Macro::Each < ::Trailblazer::Macro::Strategy
  class << self
    # DISCUSS: do we need {start_task}?
    #
    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#13
    def call(_arg0, runner:, **circuit_options); end

    # Gets included in Debugger's Normalizer. Results in IDs like {invoke_block_activity.1}.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#69
    def compute_runtime_id(ctx, trace_node:, activity:, compile_id:, **_arg4); end

    # call
    #
    # source://trailblazer-macro//lib/trailblazer/macro/each.rb#57
    def to_h; end
  end
end

# and this In() => {copy everything}
#
# source://trailblazer-macro//lib/trailblazer/macro/each.rb#66
Trailblazer::Macro::Each::ITERATION_INPUT_PIPE = T.let(T.unsafe(nil), Trailblazer::Activity::TaskWrap::Pipeline)

# This is basically Out() => {copy all mutable variables}
#
# source://trailblazer-macro//lib/trailblazer/macro/each.rb#64
Trailblazer::Macro::Each::ITERATION_OUTPUT_PIPE = T.let(T.unsafe(nil), Trailblazer::Activity::TaskWrap::Pipeline)

# FIXME: for Strategy that wants to pass-through the exec_context, so it
# looks "invisible" for steps.
#
# source://trailblazer-macro//lib/trailblazer/macro/each.rb#6
module Trailblazer::Macro::Each::Transitive
  # source://trailblazer-macro//lib/trailblazer/macro/each.rb#7
  def call(args, exec_context:, **circuit_options); end
end

# source://trailblazer-macro//lib/trailblazer/macro.rb#55
module Trailblazer::Macro::IdFor
  private

  # source://trailblazer-macro//lib/trailblazer/macro.rb#58
  def call(user_proc, macro:, hint: T.unsafe(nil), id: T.unsafe(nil)); end

  # source://trailblazer-macro//lib/trailblazer/macro.rb#62
  def from_callable(user_proc, hint: T.unsafe(nil)); end

  class << self
    # source://trailblazer-macro//lib/trailblazer/macro.rb#58
    def call(user_proc, macro:, hint: T.unsafe(nil), id: T.unsafe(nil)); end

    # source://trailblazer-macro//lib/trailblazer/macro.rb#62
    def from_callable(user_proc, hint: T.unsafe(nil)); end
  end
end

# source://trailblazer-macro//lib/trailblazer/macro/model.rb#25
class Trailblazer::Macro::Model
  # source://trailblazer-macro//lib/trailblazer/macro/model.rb#26
  def call(ctx, params: T.unsafe(nil), **_arg2); end

  class << self
    # Find
    #
    # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#166
    def Build(model_class, method = T.unsafe(nil), id: T.unsafe(nil)); end

    # New API for retrieving models by ID.
    # Only handles keyword argument style.
    #
    #
    # DESIGN NOTES
    #   * params[:id] extraction and the actual query are two separate components in the final finder activity.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#10
    def Find(model_class, positional_method = T.unsafe(nil), find_method: T.unsafe(nil), id: T.unsafe(nil), not_found_terminus: T.unsafe(nil), query: T.unsafe(nil), **keyword_options, &block); end

    # Finder activity consists of two steps:
    # {extract_id}, and the finder code.
    #
    #   |-- model.build
    #   |   |-- Start.default
    #   |   |-- extract_id
    #   |   |-- finder.Trailblazer::Macro::Model::Find::Positional
    #   |   `-- End.success
    #   |-- validate
    #
    # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#118
    def finder_activity_for(params_key:, finder:, **_arg2, &block); end

    # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#64
    def for_explicit_positional(model_class, positional_method, **options, &block); end

    # FIXME: defaulting is redundant with bla_explicit_positional.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#74
    def for_keywords(model_class, find_method:, **options, &block); end

    # FIXME: defaulting is redundant with bla_explicit_positional.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#82
    def for_query(model_class, query, column_key: T.unsafe(nil), params_key: T.unsafe(nil), **_arg4, &block); end

    # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#51
    def for_shorthand(model_class, **options, &block); end

    # Defaulting happening.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#47
    def normalize_keys(column_key: T.unsafe(nil), params_key: T.unsafe(nil), **_arg2); end

    # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#94
    def options_for(task, id:); end
  end
end

# source://trailblazer-macro//lib/trailblazer/macro/model.rb#33
class Trailblazer::Macro::Model::Builder
  # source://trailblazer-macro//lib/trailblazer/macro/model.rb#34
  def call(ctx, params); end

  # Doesn't throw an exception and will return false to divert to Left.
  #
  # source://trailblazer-macro//lib/trailblazer/macro/model.rb#48
  def find_by!(model_class, params, action, find_by_key, *_arg4); end

  # source://trailblazer-macro//lib/trailblazer/macro/model.rb#43
  def new!(model_class, params, *_arg2); end

  # Call any method on the model class and pass find_by_key, for example find(params[:id]).
  #
  # source://trailblazer-macro//lib/trailblazer/macro/model.rb#53
  def pass_through!(model_class, params, action, find_by_key, *_arg4); end
end

# Runtime code.
#
# source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#135
module Trailblazer::Macro::Model::Find; end

# source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#147
class Trailblazer::Macro::Model::Find::KeywordArguments
  # @return [KeywordArguments] a new instance of KeywordArguments
  #
  # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#148
  def initialize(model_class:, find_method:, column_key:); end

  # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#154
  def call(ctx, id:, **_arg2); end
end

# source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#159
class Trailblazer::Macro::Model::Find::NoArgument < ::Trailblazer::Macro::Model::Find::Positional
  # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#160
  def call(ctx, **_arg1); end
end

# source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#136
class Trailblazer::Macro::Model::Find::Positional
  # @return [Positional] a new instance of Positional
  #
  # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#137
  def initialize(model_class:, find_method:); end

  # source://trailblazer-macro//lib/trailblazer/macro/model/find.rb#142
  def call(ctx, id:, **_arg2); end
end

# We don't need to override {Strategy.call} here to prevent {:exec_context} from being changed.
# The decider is run in the taskWrap before the {Nested} subclass is actually called.
#
# @api private The internals here are considered private and might change in the near future.
# @private
#
# source://trailblazer-macro//lib/trailblazer/macro/nested.rb#45
class Trailblazer::Macro::Nested < ::Trailblazer::Activity::Railway
  class << self
    # Dynamic is without auto_wire where we don't even know what *could* be the actual
    # nested activity until it's runtime.
    #
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#76
    def Dynamic(decider, id:); end

    # Code to handle [:auto_wire]. This is called "static" as you configure the possible activities at
    # compile-time. This is the recommended way.
    #
    # TODO: allow configuring Output of Nested per internal nested activity, e.g.
    #         step Nested(.., Id3Tag => {Output(:invalid_metadata) => ...}
    #       this will help when semantics overlap.
    #
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#129
    def Static(decider, id:, auto_wire:); end

    # TODO: remove once we don't need the deprecation anymore.
    #
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#46
    def operation_class; end
  end
end

# TaskWrap step to run the decider.
# It's part of the API that the decider sees the original ctx.
# So this has to be placed in tW because we this step needs to be run *before* In() filters
# to resemble the behavior from pre 2.1.12.
#
# @api private The internals here are considered private and might change in the near future.
#
# source://trailblazer-macro//lib/trailblazer/macro/nested.rb#54
class Trailblazer::Macro::Nested::Decider
  # @api private The internals here are considered private and might change in the near future.
  # @return [Decider] a new instance of Decider
  #
  # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#55
  def initialize(nested_activity_decider); end

  # TaskWrap API.
  #
  # @api private The internals here are considered private and might change in the near future.
  #
  # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#60
  def call(wrap_ctx, original_args); end
end

# @api private The internals here are considered private and might change in the near future.
#
# source://trailblazer-macro//lib/trailblazer/macro/nested.rb#83
class Trailblazer::Macro::Nested::Dynamic
  class << self
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#86
    def call_dynamic_nested_activity(_arg0, runner:, **circuit_options); end

    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#105
    def compute_legacy_return_signal(return_signal); end

    # This is used in Nested and Each where some tasks don't have a corresponding, hard-wired
    # activity. This is needed for {TaskWrap.invoke} and the Debugging API in tracing.
    #
    # @api private The internals here are considered private and might change in the near future.
    # @private
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#113
    def host_activity_for(activity:); end
  end
end

# TODO: make this injectable/or get it from operation.
#
# @api private The internals here are considered private and might change in the near future.
#
# source://trailblazer-macro//lib/trailblazer/macro/nested.rb#84
Trailblazer::Macro::Nested::Dynamic::SUCCESS_SEMANTICS = T.let(T.unsafe(nil), Array)

# @api private The internals here are considered private and might change in the near future.
#
# source://trailblazer-macro//lib/trailblazer/macro/nested.rb#161
module Trailblazer::Macro::Nested::Static
  class << self
    # @api private The internals here are considered private and might change in the near future.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/nested.rb#162
    def return_route_signal(_arg0, **circuit_options); end
  end
end

# source://trailblazer-macro//lib/trailblazer/macro/rescue.rb#3
Trailblazer::Macro::NoopHandler = T.let(T.unsafe(nil), Proc)

# source://trailblazer-macro//lib/trailblazer/macro/policy.rb#2
module Trailblazer::Macro::Policy
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/guard.rb#3
    def Guard(proc, name: T.unsafe(nil), &block); end

    # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#3
    def Pundit(policy_class, action, name: T.unsafe(nil)); end

    # Adds the `yield` result to the Railway and treats it like a
    # policy-compatible  object at runtime.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/policy.rb#31
    def step(condition, name: T.unsafe(nil), &block); end
  end
end

# Step: This generically `call`s a policy and then pushes its result to `options`.
# You can use any callable object as a policy with this step.
#
# source://trailblazer-macro//lib/trailblazer/macro/policy.rb#5
class Trailblazer::Macro::Policy::Eval
  # @return [Eval] a new instance of Eval
  #
  # source://trailblazer-macro//lib/trailblazer/macro/policy.rb#6
  def initialize(name: T.unsafe(nil), path: T.unsafe(nil)); end

  # incoming low-level {circuit interface}.
  # outgoing Task::Binary API.
  #
  # Retrieve the injectable {condition}, execute it and interpret its {Result} object.
  #
  # source://trailblazer-macro//lib/trailblazer/macro/policy.rb#15
  def call(_arg0, **circuit_options); end
end

# source://trailblazer-macro//lib/trailblazer/macro/guard.rb#7
module Trailblazer::Macro::Policy::Guard
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/guard.rb#8
    def build(callable); end
  end
end

# source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#7
module Trailblazer::Macro::Policy::Pundit
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#8
    def build(*args, &block); end
  end
end

# Pundit::Condition is invoked at runtime when iterating the pipe.
#
# source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#13
class Trailblazer::Macro::Policy::Pundit::Condition
  # @return [Condition] a new instance of Condition
  #
  # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#14
  def initialize(policy_class, action); end

  # Instantiate the actual policy object, and call it.
  #
  # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#19
  def call(_arg0, *_arg1); end

  private

  # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#25
  def build_policy(options); end

  # source://trailblazer-macro//lib/trailblazer/macro/pundit.rb#29
  def result!(success, policy); end
end

# TODO: remove me in 2.2.
#
# source://trailblazer-macro//lib/trailblazer/macro/rescue.rb#27
module Trailblazer::Macro::Rescue
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/rescue.rb#28
    def deprecate_positional_handler_signature(handler); end

    # TODO: for legacy reasons, we pass `:id` to {#id_for}. In 2.2, remove the id hint and use
    # generic {Macro.id_for} behavior.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/rescue.rb#40
    def random_id; end
  end
end

# {Macro::Strategy} always keeps a {block_activity} and has to define a `#call` method per macro type.
#
# source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#4
class Trailblazer::Macro::Strategy
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#7
    def Subprocess(*args, **_arg1, &block); end

    # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#15
    def block_activity; end

    # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#7
    def fail(*args, **_arg1, &block); end

    # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#7
    def pass(*args, **_arg1, &block); end

    # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#7
    def step(*args, **_arg1, &block); end

    # This makes {Wrap} look like {block_activity}.
    #
    # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#11
    def to_h; end
  end
end

# DISCUSS: move this to Linear::Strategy.
#
# source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#20
module Trailblazer::Macro::Strategy::State
  # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#25
  def inherited(inheritor); end

  # source://trailblazer-macro//lib/trailblazer/macro/strategy.rb#21
  def initialize!(state); end
end

# Wrap exposes {#inherited} which will also copy the block activity.
# Currently, this is only used for patching (as it will try to subclass Wrap).
#
# source://trailblazer-macro//lib/trailblazer/macro/wrap.rb#48
class Trailblazer::Macro::Wrap < ::Trailblazer::Macro::Strategy
  class << self
    # source://trailblazer-macro//lib/trailblazer/macro/wrap.rb#60
    def call(_arg0, **circuit_options); end

    # behaves like an operation so it plays with Nested and simply calls the operation in the user-provided block.
    # class Wrapped
    #
    # @private
    #
    # source://trailblazer-macro//lib/trailblazer/macro/wrap.rb#49
    def deprecate_positional_wrap_signature(user_wrap); end
  end
end
