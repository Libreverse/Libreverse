# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hamster` gem.
# Please instead update this file by running `bin/tapioca gem hamster`.


# Monkey-patches to Ruby's built-in `Enumerable` module.
#
# @see http://www.ruby-doc.org/core/Enumerable.html
#
# source://hamster//lib/hamster/core_ext/enumerable.rb#5
module Enumerable
  extend ::ActiveSupport::EnumerableCoreExt::Constants

  # Return a new {Hamster::List} populated with the items in this `Enumerable` object.
  #
  # @return [List]
  #
  # source://hamster//lib/hamster/core_ext/enumerable.rb#8
  def to_list; end
end

# source://hamster//lib/hamster/undefined.rb#1
module Hamster
  class << self
    # Turn an `Enumerator` into a `Hamster::List`. The result is a lazy
    # collection where the values are memoized as they are generated.
    #
    # If your code uses multiple threads, you need to make sure that the returned
    # lazy collection is realized on a single thread only. Otherwise, a `FiberError`
    # will be raised. After the collection is realized, it can be used from other
    # threads as well.
    #
    # @example
    #   def rg; loop { yield rand(100) }; end
    #   Hamster.enumerate(to_enum(:rg)).take(10)
    # @param enum [Enumerator] The object to iterate over
    # @return [List]
    #
    # source://hamster//lib/hamster/list.rb#92
    def enumerate(enum); end

    # Create a Hamster immutable data structure with nested Hamster data
    # structure from a nested Ruby object `obj`.  This method recursively
    # "walks" the Ruby object, converting Ruby `Hash` to {Hamster::Hash}, Ruby
    # `Array` to {Hamster::Vector}, Ruby `Set` to {Hamster::Set}, and Ruby
    # `SortedSet` to {Hamster::SortedSet}.  Other objects are left as-is.
    #
    # @example
    #   h = Hamster.from({ "a" => [1, 2], "b" => "c" })
    #   # => Hamster::Hash["a" => Hamster::Vector[1, 2], "b" => "c"]
    # @return [Hash, Vector, Set, SortedSet, Object]
    #
    # source://hamster//lib/hamster/nested.rb#24
    def from(obj); end

    # Construct a list of consecutive integers.
    #
    # @example
    #   Hamster.interval(5,9)
    #   # => Hamster::List[5, 6, 7, 8, 9]
    # @param from [Integer] Start value, inclusive
    # @param to [Integer] End value, inclusive
    # @return [List]
    #
    # source://hamster//lib/hamster/list.rb#36
    def interval(from, to); end

    # Create an infinite list where each item is derived from the previous one,
    # using the provided block
    #
    # @example
    #   Hamster.iterate(0) { |i| i.next }.take(5)
    #   # => Hamster::List[0, 1, 2, 3, 4]
    # @param item [Object] Starting value
    # @return [List]
    # @yieldparam previous [Object] The previous value
    # @yieldreturn [Object] The next value
    #
    # source://hamster//lib/hamster/list.rb#74
    def iterate(item, &block); end

    # Create an infinite list repeating the same item indefinitely
    #
    # @example
    #   Hamster.repeat(:chunky).take(4)
    #   => Hamster::List[:chunky, :chunky, :chunky, :chunky]
    # @return [List]
    #
    # source://hamster//lib/hamster/list.rb#48
    def repeat(item); end

    # Create a list that contains a given item a fixed number of times
    #
    # @example
    #   Hamster.replicate(3, :hamster)
    #   #=> Hamster::List[:hamster, :hamster, :hamster]
    # @return [List]
    #
    # source://hamster//lib/hamster/list.rb#59
    def replicate(number, item); end

    # Create a lazy, infinite list.
    #
    # The given block is called as necessary to return successive elements of the list.
    #
    # @example
    #   Hamster.stream { :hello }.take(3)
    #   # => Hamster::List[:hello, :hello, :hello]
    # @return [List]
    #
    # source://hamster//lib/hamster/list.rb#22
    def stream(&block); end

    # Create a Ruby object from Hamster data. This method recursively "walks"
    # the Hamster object, converting {Hamster::Hash} to Ruby `Hash`,
    # {Hamster::Vector} and {Hamster::Deque} to Ruby `Array`, {Hamster::Set}
    # to Ruby `Set`, and {Hamster::SortedSet} to Ruby `SortedSet`.  Other
    # objects are left as-is.
    #
    # @example
    #   h = Hamster.to_ruby(Hamster.from({ "a" => [1, 2], "b" => "c" }))
    #   # => { "a" => [1, 2], "b" => "c" }
    # @return [::Hash, ::Array, ::Set, ::SortedSet, Object]
    #
    # source://hamster//lib/hamster/nested.rb#61
    def to_ruby(obj); end

    private

    # source://hamster//lib/hamster/list.rb#104
    def interval_exclusive(from, to); end
  end
end

# Including `Associable` in your container class gives it an `update_in`
# method.
#
# To mix in `Associable`, your class must implement two methods:
#
# * `fetch(index, default = (missing_default = true))`
# * `put(index, item = yield(get(index)))`
# * `get(key)`
#
# See {Vector#fetch}, {Vector#put}, {Hash#fetch}, and {Hash#put} for examples.
#
# source://hamster//lib/hamster/associable.rb#12
module Hamster::Associable
  # Return the value of successively indexing into a collection.
  # If any of the keys is not present in the collection, return `nil`.
  # keys that the Hamster type doesn't understand, raises an argument error
  #
  # @example
  #   h = Hamster::Hash[:a => 9, :b => Hamster::Vector['a', 'b'], :e => nil]
  #   h.dig(:b, 0)    # => "a"
  #   h.dig(:b, 5)    # => nil
  #   h.dig(:b, 0, 0) # => nil
  #   h.dig(:b, :a)   # ArgumentError
  # @return [Object]
  #
  # source://hamster//lib/hamster/associable.rb#62
  def dig(key, *rest); end

  # Return a new container with a deeply nested value modified to the result
  # of the given code block.  When traversing the nested containers
  # non-existing keys are created with empty `Hash` values.
  #
  # The code block receives the existing value of the deeply nested key/index
  # (or `nil` if it doesn't exist). This is useful for "transforming" the
  # value associated with a certain key/index.
  #
  # Naturally, the original container and sub-containers are left unmodified;
  # new data structure copies are created along the path as needed.
  #
  # @example
  #   v = Hamster::Vector[123, 456, 789, Hamster::Hash["a" => Hamster::Vector[5, 6, 7]]]
  #   v.update_in(3, "a", 1) { |value| value + 9 }
  #   # => Hamster::Vector[123, 456, 789, Hamster::Hash["a" => Hamster::Vector[5, 15, 7]]]
  #   hash = Hamster::Hash["a" => Hamster::Hash["b" => Hamster::Hash["c" => 42]]]
  #   hash.update_in("a", "b", "c") { |value| value + 5 }
  #   # => Hamster::Hash["a" => Hamster::Hash["b" => Hamster::Hash["c" => 47]]]
  # @param key_path [Object(s)] List of keys/indexes which form the path to the key to be modified
  # @return [Associable]
  # @yield [value] The previously stored value
  # @yieldreturn [Object] The new value to store
  #
  # source://hamster//lib/hamster/associable.rb#36
  def update_in(*key_path, &block); end
end

# The basic building block for constructing lists
#
# A Cons, also known as a "cons cell", has a "head" and a "tail", where
# the head is an element in the list, and the tail is a reference to the
# rest of the list. This way a singly linked list can be constructed, with
# each `Cons` holding a single element and a pointer to the next
# `Cons`.
#
# The last `Cons` instance in the chain has the {EmptyList} as its tail.
#
# @private
#
# source://hamster//lib/hamster/list.rb#1275
class Hamster::Cons
  include ::Enumerable
  include ::Hamster::Enumerable
  include ::Hamster::List

  # @return [Cons] a new instance of Cons
  #
  # source://hamster//lib/hamster/list.rb#1280
  def initialize(head, tail = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1295
  def cached_size?; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1286
  def empty?; end

  # Returns the value of attribute head.
  #
  # source://hamster//lib/hamster/list.rb#1278
  def head; end

  # source://hamster//lib/hamster/list.rb#1293
  def length; end

  # source://hamster//lib/hamster/list.rb#1290
  def size; end

  # Returns the value of attribute tail.
  #
  # source://hamster//lib/hamster/list.rb#1278
  def tail; end
end

# A `Deque` (or double-ended queue) is an ordered, sequential collection of
# objects, which allows elements to be retrieved, added and removed at the
# front and end of the sequence in constant time. This makes `Deque` perfect
# for use as an immutable queue or stack.
#
# A `Deque` differs from a {Vector} in that vectors allow indexed access to
# any element in the collection. `Deque`s only allow access to the first and
# last element. But adding and removing from the ends of a `Deque` is faster
# than adding and removing from the ends of a {Vector}.
#
# To create a new `Deque`:
#
#     Hamster::Deque.new([:first, :second, :third])
#     Hamster::Deque[1, 2, 3, 4, 5]
#
# Or you can start with an empty deque and build it up:
#
#     Hamster::Deque.empty.push('b').push('c').unshift('a')
#
# Like all Hamster collections, `Deque` is immutable. The four basic
# operations that "modify" deques ({#push}, {#pop}, {#shift}, and
# {#unshift}) all return a new collection and leave the existing one
# unchanged.
#
# @example
#   deque = Hamster::Deque.empty                 # => Hamster::Deque[]
#   deque = deque.push('a').push('b').push('c')  # => Hamster::Deque['a', 'b', 'c']
#   deque.first                                  # => 'a'
#   deque.last                                   # => 'c'
#   deque = deque.shift                          # => Hamster::Deque['b', 'c']
# @see http://en.wikipedia.org/wiki/Deque "Deque" on Wikipedia
#
# source://hamster//lib/hamster/deque.rb#39
class Hamster::Deque
  include ::Hamster::Immutable
  include ::Hamster::Immutable::InstanceMethods
  extend ::Hamster::Immutable::ClassMethods

  # @return [Deque] a new instance of Deque
  #
  # source://hamster//lib/hamster/deque.rb#71
  def initialize(items = T.unsafe(nil)); end

  # Return true if `other` has the same type and contents as this `Deque`.
  #
  # @param other [Object] The collection to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/deque.rb#193
  def ==(other); end

  # Return an empty `Deque` instance, of the same class as this one. Useful if you
  # have multiple subclasses of `Deque` and want to treat them polymorphically.
  #
  # @return [Deque]
  #
  # source://hamster//lib/hamster/deque.rb#181
  def clear; end

  # Return a new `Deque` with the first item removed.
  #
  # @example
  #   Hamster::Deque["A", "B", "C"].shift
  #   # => Hamster::Deque["B", "C"]
  # @return [Deque]
  #
  # source://hamster//lib/hamster/deque.rb#175
  def dequeue; end

  # Return `true` if this `Deque` contains no items.
  #
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/deque.rb#78
  def empty?; end

  # Return a new `Deque` with `item` added at the end.
  #
  # @example
  #   Hamster::Deque["A", "B", "C"].add("Z")
  #   # => Hamster::Deque["A", "B", "C", "Z"]
  # @param item [Object] The item to add
  # @return [Deque]
  #
  # source://hamster//lib/hamster/deque.rb#126
  def enqueue(item); end

  # Return an `Array` with the same elements, in the same order.
  #
  # @return [Array]
  #
  # source://hamster//lib/hamster/deque.rb#200
  def entries; end

  # Return true if `other` has the same type and contents as this `Deque`.
  #
  # @param other [Object] The collection to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/deque.rb#189
  def eql?(other); end

  # Return the first item in the `Deque`. If the deque is empty, return `nil`.
  #
  # @example
  #   Hamster::Deque["A", "B", "C"].first  #=> "A"
  # @return [Object]
  #
  # source://hamster//lib/hamster/deque.rb#99
  def first; end

  # Return the contents of this `Deque` as a programmer-readable `String`. If all the
  # items in the deque are serializable as Ruby literal strings, the returned string can
  # be passed to `eval` to reconstitute an equivalent `Deque`.
  #
  # @return [String]
  #
  # source://hamster//lib/hamster/deque.rb#214
  def inspect; end

  # Return the last item in the `Deque`. If the deque is empty, return `nil`.
  #
  # @example
  #   Hamster::Deque["A", "B", "C"].last  #=> "C"
  # @return [Object]
  #
  # source://hamster//lib/hamster/deque.rb#110
  def last; end

  # Return the number of items in this `Deque`.
  #
  # @example
  #   Hamster::Deque["A", "B", "C"].size  #=> 3
  # @return [Integer]
  #
  # source://hamster//lib/hamster/deque.rb#91
  def length; end

  # @private
  # @return [::Array]
  #
  # source://hamster//lib/hamster/deque.rb#232
  def marshal_dump; end

  # @private
  #
  # source://hamster//lib/hamster/deque.rb#237
  def marshal_load(array); end

  # Return a new `Deque` with the last item removed.
  #
  # @example
  #   Hamster::Deque["A", "B", "C"].pop
  #   # => Hamster::Deque["A", "B"]
  # @return [Deque]
  #
  # source://hamster//lib/hamster/deque.rb#135
  def pop; end

  # @private
  #
  # source://hamster//lib/hamster/deque.rb#223
  def pretty_print(pp); end

  # Return a new `Deque` with `item` added at the end.
  #
  # @example
  #   Hamster::Deque["A", "B", "C"].add("Z")
  #   # => Hamster::Deque["A", "B", "C", "Z"]
  # @param item [Object] The item to add
  # @return [Deque]
  #
  # source://hamster//lib/hamster/deque.rb#123
  def push(item); end

  # Return a new `Deque` with the first item removed.
  #
  # @example
  #   Hamster::Deque["A", "B", "C"].shift
  #   # => Hamster::Deque["B", "C"]
  # @return [Deque]
  #
  # source://hamster//lib/hamster/deque.rb#165
  def shift; end

  # Return the number of items in this `Deque`.
  #
  # @example
  #   Hamster::Deque["A", "B", "C"].size  #=> 3
  # @return [Integer]
  #
  # source://hamster//lib/hamster/deque.rb#88
  def size; end

  # Return an `Array` with the same elements, in the same order.
  #
  # @return [Array]
  #
  # source://hamster//lib/hamster/deque.rb#197
  def to_a; end

  # Return an `Array` with the same elements, in the same order.
  #
  # @return [Array]
  #
  # source://hamster//lib/hamster/deque.rb#201
  def to_ary; end

  # Return a {List} with the same elements, in the same order.
  #
  # @return [Hamster::List]
  #
  # source://hamster//lib/hamster/deque.rb#205
  def to_list; end

  # Return a new `Deque` with `item` added at the front.
  #
  # @example
  #   Hamster::Deque["A", "B", "C"].unshift("Z")
  #   # => Hamster::Deque["Z", "A", "B", "C"]
  # @param item [Object] The item to add
  # @return [Deque]
  #
  # source://hamster//lib/hamster/deque.rb#154
  def unshift(item); end

  class << self
    # Create a new `Deque` populated with the given items.
    #
    # @return [Deque]
    #
    # source://hamster//lib/hamster/deque.rb#45
    def [](*items); end

    # "Raw" allocation of a new `Deque`. Used internally to create a new
    # instance quickly after consing onto the front/rear lists or taking their
    # tails.
    #
    # @private
    # @return [Deque]
    #
    # source://hamster//lib/hamster/deque.rb#63
    def alloc(front, rear); end

    # Return an empty `Deque`. If used on a subclass, returns an empty instance
    # of that class.
    #
    # @return [Deque]
    #
    # source://hamster//lib/hamster/deque.rb#53
    def empty; end
  end
end

# The canonical empty `Deque`. Returned by `Deque[]` when
# invoked with no arguments; also returned by `Deque.empty`. Prefer using this
# one rather than creating many empty deques using `Deque.new`.
#
# @private
#
# source://hamster//lib/hamster/deque.rb#247
Hamster::EmptyDeque = T.let(T.unsafe(nil), Hamster::Deque)

# The canonical empty `Hash`. Returned by `Hash[]` when
# invoked with no arguments; also returned by `Hash.empty`. Prefer using this
# one rather than creating many empty hashes using `Hash.new`.
#
# @private
#
# source://hamster//lib/hamster/hash.rb#898
Hamster::EmptyHash = T.let(T.unsafe(nil), Hamster::Hash)

# source://hamster//lib/hamster/list.rb#1562
module Hamster::EmptyList
  extend ::Enumerable
  extend ::Hamster::Enumerable
  extend ::Hamster::List

  class << self
    # source://hamster//lib/hamster/list.rb#1590
    def cached_size?; end

    # source://hamster//lib/hamster/list.rb#1579
    def empty?; end

    # source://hamster//lib/hamster/list.rb#1571
    def first; end

    # source://hamster//lib/hamster/list.rb#1568
    def head; end

    # source://hamster//lib/hamster/list.rb#1588
    def length; end

    # source://hamster//lib/hamster/list.rb#1585
    def size; end

    # source://hamster//lib/hamster/list.rb#1575
    def tail; end
  end
end

# The canonical empty `Set`. Returned by `Set[]` when
# invoked with no arguments; also returned by `Set.empty`. Prefer using this
# one rather than creating many empty sets using `Set.new`.
#
# @private
#
# source://hamster//lib/hamster/set.rb#575
Hamster::EmptySet = T.let(T.unsafe(nil), Hamster::Set)

# The canonical empty `SortedSet`. Returned by `SortedSet[]`
# when invoked with no arguments; also returned by `SortedSet.empty`. Prefer using
# this one rather than creating many empty sorted sets using `SortedSet.new`.
#
# @private
#
# source://hamster//lib/hamster/sorted_set.rb#1458
Hamster::EmptySortedSet = T.let(T.unsafe(nil), Hamster::SortedSet)

# @private
#
# source://hamster//lib/hamster/trie.rb#337
Hamster::EmptyTrie = T.let(T.unsafe(nil), Hamster::Trie)

# The canonical empty `Vector`. Returned by `Vector[]` when
# invoked with no arguments; also returned by `Vector.empty`. Prefer using this
# one rather than creating many empty vectors using `Vector.new`.
#
# @private
#
# source://hamster//lib/hamster/vector.rb#1520
Hamster::EmptyVector = T.let(T.unsafe(nil), Hamster::Vector)

# Helper module for Hamster's sequential collections
#
# Classes including `Hamster::Enumerable` must implement:
#
# - `#each` (just like `::Enumerable`).
# - `#select`, which takes a block, and returns an instance of the same class
#     with only the items for which the block returns a true value
#
# source://hamster//lib/hamster/enumerable.rb#9
module Hamster::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Enumerable

  # Compare with `other`, and return 0, 1, or -1 if it is (respectively) equal to,
  # greater than, or less than this collection.
  #
  # source://hamster//lib/hamster/enumerable.rb#92
  def <=>(other); end

  # Return true if `other` contains the same elements, in the same order.
  #
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/enumerable.rb#108
  def ==(other); end

  # Return a new collection with all `nil` elements removed.
  #
  # source://hamster//lib/hamster/enumerable.rb#20
  def compact; end

  # Return a new collection with all the elements for which the block returns false.
  #
  # source://hamster//lib/hamster/enumerable.rb#17
  def delete_if; end

  # Yield all integers from 0 up to, but not including, the number of items in
  # this collection. For collections which provide indexed access, these are all
  # the valid, non-negative indices into the collection.
  #
  # source://hamster//lib/hamster/enumerable.rb#44
  def each_index(&block); end

  # Search the collection for elements which are `#===` to `item`. Yield them to
  # the optional code block if provided, and return them as a new collection.
  #
  # source://hamster//lib/hamster/enumerable.rb#26
  def grep(pattern, &block); end

  # Search the collection for elements which are not `#===` to `item`. Yield
  # them to the optional code block if provided, and return them as a new
  # collection.
  #
  # source://hamster//lib/hamster/enumerable.rb#35
  def grep_v(pattern, &block); end

  # Groups the collection into sub-collections by the result of yielding them to
  # the block. Returns a {Hash} where the keys are return values from the block,
  # and the values are sub-collections (of the same type as this one).
  #
  # source://hamster//lib/hamster/enumerable.rb#86
  def group_by(&block); end

  # source://hamster//lib/hamster/enumerable.rb#146
  def index(*_arg0); end

  # Convert this collection to a programmer-readable `String` representation.
  #
  # source://hamster//lib/hamster/enumerable.rb#131
  def inspect; end

  # Convert all the elements into strings and join them together, separated by
  # `separator`. By default, the `separator` is `$,`, the global default string
  # separator, which is normally `nil`.
  #
  # source://hamster//lib/hamster/enumerable.rb#115
  def join(separator = T.unsafe(nil)); end

  # Return 2 collections, the first containing all the elements for which the block
  # evaluates to true, the second containing the rest.
  #
  # source://hamster//lib/hamster/enumerable.rb#62
  def partition; end

  # @private
  #
  # source://hamster//lib/hamster/enumerable.rb#138
  def pretty_print(pp); end

  # Multiply all the items (presumably numeric) in this collection together.
  #
  # source://hamster//lib/hamster/enumerable.rb#51
  def product; end

  # Return a new collection with all the elements for which the block returns false.
  #
  # source://hamster//lib/hamster/enumerable.rb#13
  def reject; end

  # Add up all the items (presumably numeric) in this collection.
  #
  # source://hamster//lib/hamster/enumerable.rb#56
  def sum; end

  # source://hamster//lib/hamster/enumerable.rb#145
  def to_ary(*_arg0); end

  # Convert this collection to a {Set}.
  #
  # source://hamster//lib/hamster/enumerable.rb#126
  def to_set; end

  protected

  # Groups the collection into sub-collections by the result of yielding them to
  # the block. Returns a {Hash} where the keys are return values from the block,
  # and the values are sub-collections. All the sub-collections are built up from
  # `empty_group`, which should respond to `#add` by returning a new collection
  # with an added element.
  #
  # source://hamster//lib/hamster/enumerable.rb#73
  def group_by_with(empty_group, &block); end
end

# A `Hamster::Hash` maps a set of unique keys to corresponding values, much
# like a dictionary maps from words to definitions. Given a key, it can store
# and retrieve an associated value in constant time. If an existing key is
# stored again, the new value will replace the old. It behaves much like
# Ruby's built-in Hash, which we will call RubyHash for clarity. Like
# RubyHash, two keys that are `#eql?` to each other and have the same
# `#hash` are considered identical in a `Hamster::Hash`.
#
# A `Hamster::Hash` can be created in a couple of ways:
#
#     Hamster::Hash.new(font_size: 10, font_family: 'Arial')
#     Hamster::Hash[first_name: 'John', last_name: 'Smith']
#
# Any `Enumerable` object which yields two-element `[key, value]` arrays
# can be used to initialize a `Hamster::Hash`:
#
#     Hamster::Hash.new([[:first_name, 'John'], [:last_name, 'Smith']])
#
# Key/value pairs can be added using {#put}. A new hash is returned and the
# existing one is left unchanged:
#
#     hash = Hamster::Hash[a: 100, b: 200]
#     hash.put(:c, 500) # => Hamster::Hash[:a => 100, :b => 200, :c => 500]
#     hash              # => Hamster::Hash[:a => 100, :b => 200]
#
# {#put} can also take a block, which is used to calculate the value to be
# stored.
#
#     hash.put(:a) { |current| current + 200 } # => Hamster::Hash[:a => 300, :b => 200]
#
# Since it is immutable, all methods which you might expect to "modify" a
# `Hamster::Hash` actually return a new hash and leave the existing one
# unchanged. This means that the `hash[key] = value` syntax from RubyHash
# *cannot* be used with `Hamster::Hash`.
#
# Nested data structures can easily be updated using {#update_in}:
#
#     hash = Hamster::Hash["a" => Hamster::Vector[Hamster::Hash["c" => 42]]]
#     hash.update_in("a", 0, "c") { |value| value + 5 }
#     # => Hamster::Hash["a" => Hamster::Hash["b" => Hamster::Hash["c" => 47]]]
#
# While a `Hamster::Hash` can iterate over its keys or values, it does not
# guarantee any specific iteration order (unlike RubyHash). Methods like
# {#flatten} do not guarantee the order of returned key/value pairs.
#
# Like RubyHash, a `Hamster::Hash` can have a default block which is used
# when looking up a key that does not exist. Unlike RubyHash, the default
# block will only be passed the missing key, without the hash itself:
#
#     hash = Hamster::Hash.new { |missing_key| missing_key * 10 }
#     hash[5] # => 50
#
# source://hamster//lib/hamster/hash.rb#61
class Hamster::Hash
  include ::Hamster::Immutable
  include ::Hamster::Immutable::InstanceMethods
  include ::Enumerable
  include ::Hamster::Enumerable
  include ::Hamster::Associable
  extend ::Hamster::Immutable::ClassMethods

  # @param pairs [::Enumerable] initial content of hash. An empty hash is returned if not provided.
  # @return [Hash] a new instance of Hash
  # @yield [key] Optional _default block_ to be stored and used to calculate the default value of a missing key. It will not be yielded during this method. It will not be preserved when marshalling.
  # @yieldparam key Key that was not present in the hash.
  #
  # source://hamster//lib/hamster/hash.rb#103
  def initialize(pairs = T.unsafe(nil), &block); end

  # Return true if this `Hash` is a proper subset of `other`, which means all
  # its keys are contained in `other` with the identical values, and the two
  # hashes are not identical.
  #
  # @param other [Hamster::Hash] The object to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#773
  def <(other); end

  # Return true if this `Hash` is a subset of `other`, which means all its
  # keys are contained in `other` with the identical values, and the two
  # hashes are not identical.
  #
  # @param other [Hamster::Hash] The object to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#783
  def <=(other); end

  # Return true if `other` has the same contents as this `Hash`. Will convert
  # `other` to a Ruby `Hash` using `#to_hash` if necessary.
  #
  # @param other [Object] The object to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#739
  def ==(other); end

  # Return true if this `Hash` is a proper superset of `other`, which means
  # all `other`'s keys are contained in this `Hash` with the identical
  # values, and the two hashes are not identical.
  #
  # @param other [Hamster::Hash] The object to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#749
  def >(other); end

  # Return true if this `Hash` is a superset of `other`, which means all
  # `other`'s keys are contained in this `Hash` with the identical values.
  #
  # @param other [Hamster::Hash] The object to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#758
  def >=(other); end

  # Retrieve the value corresponding to the provided key object. If not found, and
  # this `Hash` has a default block, the default block is called to provide the
  # value. Otherwise, return `nil`.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h["B"]             # => 2
  #   h.get("B")         # => 2
  #   h.get("Elephant")  # => nil
  #
  #   # Hamster Hash with a default proc:
  #   h = Hamster::Hash.new("A" => 1, "B" => 2, "C" => 3) { |key| key.size }
  #   h.get("B")         # => 2
  #   h.get("Elephant")  # => 8
  # @param key [Object] The key to look up
  # @return [Object]
  #
  # source://hamster//lib/hamster/hash.rb#187
  def [](key); end

  # Searches through the `Hash`, comparing `obj` with each key (using `#==`).
  # When a matching key is found, return the `[key, value]` pair as an array.
  # Return `nil` if no match is found.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].assoc("B")  # => ["B", 2]
  # @param obj [Object] The key to search for (using #==)
  # @return [Array]
  #
  # source://hamster//lib/hamster/hash.rb#667
  def assoc(obj); end

  # Return an empty `Hash` instance, of the same class as this one. Useful if you
  # have multiple subclasses of `Hash` and want to treat them polymorphically.
  # Maintains the default block, if there is one.
  #
  # @return [Hash]
  #
  # source://hamster//lib/hamster/hash.rb#717
  def clear; end

  # Call the block once for each key/value pair in this `Hash`, passing the key/value
  # pair as parameters. The block should return a `[key, value]` array each time.
  # All the returned `[key, value]` arrays will be gathered into a new `Hash`.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.map { |k, v| ["new-#{k}", v * v] }
  #   # => Hash["new-C" => 9, "new-B" => 4, "new-A" => 1]
  # @return [Hash]
  # @yield [key, value] Once for each key/value pair.
  #
  # source://hamster//lib/hamster/hash.rb#409
  def collect; end

  # Return the default block if there is one. Otherwise, return `nil`.
  #
  # @return [Proc]
  #
  # source://hamster//lib/hamster/hash.rb#111
  def default_proc; end

  # Return a new `Hash` with `key` removed. If `key` is not present, return
  # `self`.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].delete("B")
  #   # => Hamster::Hash["A" => 1, "C" => 3]
  # @param key [Object] The key to remove
  # @return [Hash]
  #
  # source://hamster//lib/hamster/hash.rb#311
  def delete(key); end

  # Yield `[key, value]` pairs until one is found for which the block returns true.
  # Return that `[key, value]` pair. If the block never returns true, return `nil`.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.find { |k, v| v.even? }
  #   # => ["B", 2]
  # @return [Array]
  # @yield [key, value] At most once for each key/value pair, until the block returns `true`.
  # @yieldreturn Truthy to halt iteration and return the yielded key/value pair.
  #
  # source://hamster//lib/hamster/hash.rb#444
  def detect; end

  # Call the block once for each key/value pair in this `Hash`, passing the key/value
  # pair as parameters. No specific iteration order is guaranteed, though the order will
  # be stable for any particular `Hash`.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].each { |k, v| puts "k=#{k} v=#{v}" }
  #
  #   k=A v=1
  #   k=C v=3
  #   k=B v=2
  #   # => Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  # @return [self]
  # @yield [key, value] Once for each key/value pair.
  #
  # source://hamster//lib/hamster/hash.rb#329
  def each(&block); end

  # Call the block once for each key/value pair in this `Hash`, passing the key as a
  # parameter. Ordering guarantees are the same as {#each}.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].each_key { |k| puts "k=#{k}" }
  #
  #   k=A
  #   k=C
  #   k=B
  #   # => Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  # @return [self]
  # @yield [key] Once for each key/value pair.
  #
  # source://hamster//lib/hamster/hash.rb#368
  def each_key; end

  # Call the block once for each key/value pair in this `Hash`, passing the key/value
  # pair as parameters. No specific iteration order is guaranteed, though the order will
  # be stable for any particular `Hash`.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].each { |k, v| puts "k=#{k} v=#{v}" }
  #
  #   k=A v=1
  #   k=C v=3
  #   k=B v=2
  #   # => Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  # @return [self]
  # @yield [key, value] Once for each key/value pair.
  #
  # source://hamster//lib/hamster/hash.rb#334
  def each_pair(&block); end

  # Call the block once for each key/value pair in this `Hash`, passing the value as a
  # parameter. Ordering guarantees are the same as {#each}.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].each_value { |v| puts "v=#{v}" }
  #
  #   v=1
  #   v=3
  #   v=2
  #   # => Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  # @return [self]
  # @yield [value] Once for each key/value pair.
  #
  # source://hamster//lib/hamster/hash.rb#387
  def each_value; end

  # Return `true` if this `Hash` contains no key/value pairs.
  #
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#129
  def empty?; end

  # Return true if `other` has the same type and contents as this `Hash`.
  #
  # @param other [Object] The collection to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#729
  def eql?(other); end

  # Return a new `Hash` with the associations for all of the given `keys` removed.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.except("A", "C")  # => Hamster::Hash["B" => 2]
  # @param keys [Array] The keys to remove
  # @return [Hash]
  #
  # source://hamster//lib/hamster/hash.rb#543
  def except(*keys); end

  # Retrieve the value corresponding to the given key object, or use the provided
  # default value or block, or otherwise raise a `KeyError`.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.fetch("B")         # => 2
  #   h.fetch("Elephant")  # => KeyError: key not found: "Elephant"
  #
  #   # with a default value:
  #   h.fetch("B", 99)         # => 2
  #   h.fetch("Elephant", 99)  # => 99
  #
  #   # with a block:
  #   h.fetch("B") { |key| key.size }         # => 2
  #   h.fetch("Elephant") { |key| key.size }  # => 8
  # @overload fetch
  # @overload fetch
  # @overload fetch
  # @return [Object]
  #
  # source://hamster//lib/hamster/hash.rb#222
  def fetch(key, default = T.unsafe(nil)); end

  # Return a {Vector} of the values which correspond to the `wanted` keys.
  # If any of the `wanted` keys are not present in this `Hash`, raise `KeyError`
  # exception.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.fetch_values("C", "A")  # => Hamster::Vector[3, 1]
  #   h.fetch_values("C", "Z")  # => KeyError: key not found: "Z"
  # @param wanted [Array] The keys to retrieve
  # @return [Vector]
  #
  # source://hamster//lib/hamster/hash.rb#588
  def fetch_values(*wanted); end

  # Yield `[key, value]` pairs until one is found for which the block returns true.
  # Return that `[key, value]` pair. If the block never returns true, return `nil`.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.find { |k, v| v.even? }
  #   # => ["B", 2]
  # @return [Array]
  # @yield [key, value] At most once for each key/value pair, until the block returns `true`.
  # @yieldreturn Truthy to halt iteration and return the yielded key/value pair.
  #
  # source://hamster//lib/hamster/hash.rb#439
  def find; end

  # Return a new `Hash` with all the key/value pairs for which the block returns true.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.select { |k, v| v >= 2 }
  #   # => Hamster::Hash["B" => 2, "C" => 3]
  # @return [Hash]
  # @yield [key, value] Once for each key/value pair.
  # @yieldreturn Truthy if this pair should be present in the new `Hash`.
  #
  # source://hamster//lib/hamster/hash.rb#425
  def find_all(&block); end

  # Return a new {Vector} which is a one-dimensional flattening of this `Hash`.
  # If `level` is 1, all the `[key, value]` pairs in the hash will be concatenated
  # into one {Vector}. If `level` is greater than 1, keys or values which are
  # themselves `Array`s or {Vector}s will be recursively flattened into the output
  # {Vector}. The depth to which that flattening will be recursively applied is
  # determined by `level`.
  #
  # As a special case, if `level` is 0, each `[key, value]` pair will be a
  # separate element in the returned {Vector}.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => [2, 3, 4]]
  #   h.flatten
  #   # => Hamster::Vector["A", 1, "B", [2, 3, 4]]
  #   h.flatten(2)
  #   # => Hamster::Vector["A", 1, "B", 2, 3, 4]
  # @param level [Integer] The number of times to recursively flatten the `[key, value]` pairs in this `Hash`.
  # @return [Vector]
  #
  # source://hamster//lib/hamster/hash.rb#650
  def flatten(level = T.unsafe(nil)); end

  # Retrieve the value corresponding to the provided key object. If not found, and
  # this `Hash` has a default block, the default block is called to provide the
  # value. Otherwise, return `nil`.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h["B"]             # => 2
  #   h.get("B")         # => 2
  #   h.get("Elephant")  # => nil
  #
  #   # Hamster Hash with a default proc:
  #   h = Hamster::Hash.new("A" => 1, "B" => 2, "C" => 3) { |key| key.size }
  #   h.get("B")         # => 2
  #   h.get("Elephant")  # => 8
  # @param key [Object] The key to look up
  # @return [Object]
  #
  # source://hamster//lib/hamster/hash.rb#179
  def get(key); end

  # Return `true` if the given key object is present in this `Hash`. More precisely,
  # return `true` if a key with the same `#hash` code, and which is also `#eql?`
  # to the given key object is present.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].key?("B")  # => true
  # @param key [Object] The key to check for
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#145
  def has_key?(key); end

  # Return `true` if this `Hash` has one or more keys which map to the provided value.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].value?(2)  # => true
  # @param value [Object] The value to check for
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#160
  def has_value?(value); end

  # See `Object#hash`.
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/hash.rb#789
  def hash; end

  # Return `true` if the given key object is present in this `Hash`. More precisely,
  # return `true` if a key with the same `#hash` code, and which is also `#eql?`
  # to the given key object is present.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].key?("B")  # => true
  # @param key [Object] The key to check for
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#146
  def include?(key); end

  # Return the contents of this `Hash` as a programmer-readable `String`. If all the
  # keys and values are serializable as Ruby literal strings, the returned string can
  # be passed to `eval` to reconstitute an equivalent `Hash`. The default
  # block (if there is one) will be lost when doing this, however.
  #
  # @return [String]
  #
  # source://hamster//lib/hamster/hash.rb#801
  def inspect; end

  # Return a new `Hash` created by using keys as values and values as keys.
  # If there are multiple values which are equivalent (as determined by `#hash` and
  # `#eql?`), only one out of each group of equivalent values will be
  # retained. Which one specifically is undefined.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3, "D" => 2].invert
  #   # => Hamster::Hash[1 => "A", 3 => "C", 2 => "B"]
  # @return [Hash]
  #
  # source://hamster//lib/hamster/hash.rb#625
  def invert; end

  # Return a new `Hash` with all the key/value pairs for which the block returns true.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.select { |k, v| v >= 2 }
  #   # => Hamster::Hash["B" => 2, "C" => 3]
  # @return [Hash]
  # @yield [key, value] Once for each key/value pair.
  # @yieldreturn Truthy if this pair should be present in the new `Hash`.
  #
  # source://hamster//lib/hamster/hash.rb#426
  def keep_if(&block); end

  # Searches through the `Hash`, comparing `value` with each value (using `#==`).
  # When a matching value is found, return its associated key object.
  # Return `nil` if no match is found.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].key(2)  # => "B"
  # @param value [Object] The value to search for (using #==)
  # @return [Object]
  #
  # source://hamster//lib/hamster/hash.rb#695
  def key(value); end

  # Return `true` if the given key object is present in this `Hash`. More precisely,
  # return `true` if a key with the same `#hash` code, and which is also `#eql?`
  # to the given key object is present.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].key?("B")  # => true
  # @param key [Object] The key to check for
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#142
  def key?(key); end

  # Return a new {Set} containing the keys from this `Hash`.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3, "D" => 2].keys
  #   # => Hamster::Set["D", "C", "B", "A"]
  # @return [Set]
  #
  # source://hamster//lib/hamster/hash.rb#600
  def keys; end

  # Return the number of key/value pairs in this `Hash`.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].size  # => 3
  # @return [Integer]
  #
  # source://hamster//lib/hamster/hash.rb#124
  def length; end

  # Call the block once for each key/value pair in this `Hash`, passing the key/value
  # pair as parameters. The block should return a `[key, value]` array each time.
  # All the returned `[key, value]` arrays will be gathered into a new `Hash`.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.map { |k, v| ["new-#{k}", v * v] }
  #   # => Hash["new-C" => 9, "new-B" => 4, "new-A" => 1]
  # @return [Hash]
  # @yield [key, value] Once for each key/value pair.
  #
  # source://hamster//lib/hamster/hash.rb#404
  def map; end

  # @private
  # @return [::Hash]
  #
  # source://hamster//lib/hamster/hash.rb#864
  def marshal_dump; end

  # @private
  #
  # source://hamster//lib/hamster/hash.rb#869
  def marshal_load(dictionary); end

  # Return `true` if the given key object is present in this `Hash`. More precisely,
  # return `true` if a key with the same `#hash` code, and which is also `#eql?`
  # to the given key object is present.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].key?("B")  # => true
  # @param key [Object] The key to check for
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#147
  def member?(key); end

  # Return a new `Hash` containing all the key/value pairs from this `Hash` and
  # `other`. If no block is provided, the value for entries with colliding keys
  # will be that from `other`. Otherwise, the value for each duplicate key is
  # determined by calling the block.
  #
  # `other` can be a `Hamster::Hash`, a built-in Ruby `Hash`, or any `Enumerable`
  # object which yields `[key, value]` pairs.
  #
  # @example
  #   h1 = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h2 = Hamster::Hash["C" => 70, "D" => 80]
  #   h1.merge(h2)
  #   # => Hamster::Hash["C" => 70, "A" => 1, "D" => 80, "B" => 2]
  #   h1.merge(h2) { |key, v1, v2| v1 + v2 }
  #   # => Hamster::Hash["C" => 73, "A" => 1, "D" => 80, "B" => 2]
  # @param other [::Enumerable] The collection to merge with
  # @return [Hash]
  # @yieldparam key [Object] The key which was present in both collections
  # @yieldparam my_value [Object] The associated value from this `Hash`
  # @yieldparam other_value [Object] The associated value from the other collection
  # @yieldreturn [Object] The value to associate this key with in the new `Hash`
  #
  # source://hamster//lib/hamster/hash.rb#468
  def merge(other); end

  # Allows this `Hash` to be printed at the `pry` console, or using `pp` (from the
  # Ruby standard library), in a way which takes the amount of horizontal space on
  # the screen into account, and which indents nested structures to make them easier
  # to read.
  #
  # @private
  #
  # source://hamster//lib/hamster/hash.rb#818
  def pretty_print(pp); end

  # Return a new `Hash` with the existing key/value associations, plus an association
  # between the provided key and value. If an equivalent key is already present, its
  # associated value will be replaced with the provided one.
  #
  # If the `value` argument is missing, but an optional code block is provided,
  # it will be passed the existing value (or `nil` if there is none) and what it
  # returns will replace the existing value. This is useful for "transforming"
  # the value associated with a certain key.
  #
  # Avoid mutating objects which are used as keys. `String`s are an exception:
  # unfrozen `String`s which are used as keys are internally duplicated and
  # frozen. This matches RubyHash's behaviour.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2]
  #   h.put("C", 3)
  #   # => Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.put("B") { |value| value * 10 }
  #   # => Hamster::Hash["A" => 1, "B" => 20]
  # @param key [Object] The key to store
  # @param value [Object] The value to associate it with
  # @return [Hash]
  # @yield [value] The previously stored value, or `nil` if none.
  # @yieldreturn [Object] The new value to store
  #
  # source://hamster//lib/hamster/hash.rb#260
  def put(key, value = T.unsafe(nil)); end

  # Searches through the `Hash`, comparing `obj` with each value (using `#==`).
  # When a matching value is found, return the `[key, value]` pair as an array.
  # Return `nil` if no match is found.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].rassoc(2)  # => ["B", 2]
  # @param obj [Object] The value to search for (using #==)
  # @return [Array]
  #
  # source://hamster//lib/hamster/hash.rb#681
  def rassoc(obj); end

  # Call the block once for each key/value pair in this `Hash`, passing the key/value
  # pair as parameters. Iteration order will be the opposite of {#each}.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].reverse_each { |k, v| puts "k=#{k} v=#{v}" }
  #
  #   k=B v=2
  #   k=C v=3
  #   k=A v=1
  #   # => Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  # @return [self]
  # @yield [key, value] Once for each key/value pair.
  #
  # source://hamster//lib/hamster/hash.rb#349
  def reverse_each(&block); end

  # Return a randomly chosen `[key, value]` pair from this `Hash`. If the hash is empty,
  # return `nil`.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].sample
  #   # => ["C", 3]
  # @return [Array]
  #
  # source://hamster//lib/hamster/hash.rb#708
  def sample; end

  # Return a new `Hash` with all the key/value pairs for which the block returns true.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.select { |k, v| v >= 2 }
  #   # => Hamster::Hash["B" => 2, "C" => 3]
  # @return [Hash]
  # @yield [key, value] Once for each key/value pair.
  # @yieldreturn Truthy if this pair should be present in the new `Hash`.
  #
  # source://hamster//lib/hamster/hash.rb#421
  def select(&block); end

  # Return the number of key/value pairs in this `Hash`.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].size  # => 3
  # @return [Integer]
  #
  # source://hamster//lib/hamster/hash.rb#121
  def size; end

  # Return a new `Hash` with only the associations for the `wanted` keys retained.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.slice("B", "C")  # => Hamster::Hash["B" => 2, "C" => 3]
  # @param wanted [::Enumerable] The keys to retain
  # @return [Hash]
  #
  # source://hamster//lib/hamster/hash.rb#555
  def slice(*wanted); end

  # Return a sorted {Vector} which contains all the `[key, value]` pairs in
  # this `Hash` as two-element `Array`s.
  #
  # @overload sort
  # @overload sort
  # @return [Vector]
  # @see ::Enumerable#sort
  #
  # source://hamster//lib/hamster/hash.rb#512
  def sort; end

  # Return a {Vector} which contains all the `[key, value]` pairs in this `Hash`
  # as two-element Arrays. The order which the pairs will appear in is determined by
  # passing each pair to the code block to obtain a sort key object, and comparing
  # the sort keys using `#<=>`.
  #
  # @example
  #   h = Hamster::Hash["Dog" => 1, "Elephant" => 2, "Lion" => 3]
  #   h.sort_by { |key, value| key.size }
  #   # => Hamster::Vector[["Dog", 1], ["Lion", 3], ["Elephant", 2]]
  # @return [Vector]
  # @see ::Enumerable#sort_by
  # @yield [key, value] Once for each key/value pair.
  # @yieldreturn a sort key object for the yielded pair.
  #
  # source://hamster//lib/hamster/hash.rb#531
  def sort_by; end

  # An alias for {#put} to match RubyHash's API. Does not support {#put}'s
  # block form.
  #
  # @param key [Object] The key to store
  # @param value [Object] The value to associate it with
  # @return [Hash]
  # @see #put
  #
  # source://hamster//lib/hamster/hash.rb#298
  def store(key, value); end

  # Convert this `Hamster::Hash` to an instance of Ruby's built-in `Hash`.
  #
  # @return [::Hash]
  #
  # source://hamster//lib/hamster/hash.rb#844
  def to_h; end

  # Convert this `Hamster::Hash` to an instance of Ruby's built-in `Hash`.
  #
  # @return [::Hash]
  #
  # source://hamster//lib/hamster/hash.rb#837
  def to_hash; end

  # Return a Proc which accepts a key as an argument and returns the value.
  # The Proc behaves like {#get} (when the key is missing, it returns nil or
  # result of the default proc).
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.to_proc.call("B")
  #   # => 2
  #   ["A", "C", "X"].map(&h)   # The & is short for .to_proc in Ruby
  #   # => [1, 3, nil]
  # @return [Proc]
  #
  # source://hamster//lib/hamster/hash.rb#858
  def to_proc; end

  # Return `true` if this `Hash` has one or more keys which map to the provided value.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3].value?(2)  # => true
  # @param value [Object] The value to check for
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/hash.rb#156
  def value?(value); end

  # Return a new {Vector} populated with the values from this `Hash`.
  #
  # @example
  #   Hamster::Hash["A" => 1, "B" => 2, "C" => 3, "D" => 2].values
  #   # => Hamster::Vector[2, 3, 2, 1]
  # @return [Vector]
  #
  # source://hamster//lib/hamster/hash.rb#611
  def values; end

  # Return a {Vector} of the values which correspond to the `wanted` keys.
  # If any of the `wanted` keys are not present in this `Hash`, `nil` will be
  # placed instead, or the result of the default proc (if one is defined),
  # similar to the behavior of {#get}.
  #
  # @example
  #   h = Hamster::Hash["A" => 1, "B" => 2, "C" => 3]
  #   h.values_at("B", "A", "D")  # => Hamster::Vector[2, 1, nil]
  # @param wanted [Array] The keys to retrieve
  # @return [Vector]
  #
  # source://hamster//lib/hamster/hash.rb#572
  def values_at(*wanted); end

  private

  # Return a new `Hash` which is derived from this one, using a modified {Trie}.
  # The new `Hash` will retain the existing default block, if there is one.
  #
  # source://hamster//lib/hamster/hash.rb#878
  def derive_new_hash(trie); end

  class << self
    # Create a new `Hash` populated with the given key/value pairs.
    #
    # @example
    #   Hamster::Hash["A" => 1, "B" => 2] # => Hamster::Hash["A" => 1, "B" => 2]
    #   Hamster::Hash[["A", 1], ["B", 2]] # => Hamster::Hash["A" => 1, "B" => 2]
    # @param pairs [::Enumerable] initial content of hash. An empty hash is returned if not provided.
    # @return [Hash]
    #
    # source://hamster//lib/hamster/hash.rb#75
    def [](pairs = T.unsafe(nil)); end

    # "Raw" allocation of a new `Hash`. Used internally to create a new
    # instance quickly after obtaining a modified {Trie}.
    #
    # @private
    # @return [Hash]
    #
    # source://hamster//lib/hamster/hash.rb#92
    def alloc(trie = T.unsafe(nil), block = T.unsafe(nil)); end

    # Return an empty `Hash`. If used on a subclass, returns an empty instance
    # of that class.
    #
    # @return [Hash]
    #
    # source://hamster//lib/hamster/hash.rb#83
    def empty; end
  end
end

# @private
#
# source://hamster//lib/hamster/immutable.rb#3
module Hamster::Immutable
  include ::Hamster::Immutable::InstanceMethods

  mixes_in_class_methods ::Hamster::Immutable::ClassMethods

  class << self
    # @private
    #
    # source://hamster//lib/hamster/immutable.rb#4
    def included(klass); end
  end
end

# @private
#
# source://hamster//lib/hamster/immutable.rb#12
module Hamster::Immutable::ClassMethods
  # source://hamster//lib/hamster/immutable.rb#17
  def memoize(*names); end

  # source://hamster//lib/hamster/immutable.rb#13
  def new(*args); end
end

# @private
#
# source://hamster//lib/hamster/immutable.rb#44
module Hamster::Immutable::InstanceMethods
  # source://hamster//lib/hamster/immutable.rb#60
  def clone; end

  # source://hamster//lib/hamster/immutable.rb#56
  def dup; end

  # source://hamster//lib/hamster/immutable.rb#45
  def immutable!; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/immutable.rb#49
  def immutable?; end

  protected

  # source://hamster//lib/hamster/immutable.rb#70
  def transform(&block); end

  # source://hamster//lib/hamster/immutable.rb#66
  def transform_unless(condition, &block); end

  private

  # source://hamster//lib/hamster/immutable.rb#53
  def __hamster_immutable_dup__; end
end

# @private
#
# source://hamster//lib/hamster/immutable.rb#36
module Hamster::Immutable::MemoizeMethods
  # source://hamster//lib/hamster/immutable.rb#37
  def immutable!; end
end

# A `LazyList` takes a block that returns a `List`, i.e. an object that responds
# to `#head`, `#tail` and `#empty?`. The list is only realized (i.e. the block is
# only called) when one of these operations is performed.
#
# By returning a `Cons` that in turn has a {LazyList} as its tail, one can
# construct infinite `List`s.
#
# @private
#
# source://hamster//lib/hamster/list.rb#1308
class Hamster::LazyList
  include ::Enumerable
  include ::Hamster::Enumerable
  include ::Hamster::List

  # @return [LazyList] a new instance of LazyList
  #
  # source://hamster//lib/hamster/list.rb#1311
  def initialize(&block); end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1339
  def cached_size?; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1329
  def empty?; end

  # source://hamster//lib/hamster/list.rb#1322
  def first; end

  # source://hamster//lib/hamster/list.rb#1318
  def head; end

  # source://hamster//lib/hamster/list.rb#1337
  def length; end

  # source://hamster//lib/hamster/list.rb#1334
  def size; end

  # source://hamster//lib/hamster/list.rb#1324
  def tail; end

  private

  # source://hamster//lib/hamster/list.rb#1348
  def realize; end
end

# source://hamster//lib/hamster/list.rb#1346
Hamster::LazyList::MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# source://hamster//lib/hamster/list.rb#1345
Hamster::LazyList::QUEUE = T.let(T.unsafe(nil), Thread::ConditionVariable)

# A `List` can be constructed with {List.[] List[]}, or {Enumerable#to_list}.
# It consists of a *head* (the first element) and a *tail* (which itself is also
# a `List`, containing all the remaining elements).
#
# This is a singly linked list. Prepending to the list with {List#add} runs
# in constant time. Traversing the list from front to back is efficient,
# however, indexed access runs in linear time because the list needs to be
# traversed to find the element.
#
# source://hamster//lib/hamster/list.rb#119
module Hamster::List
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Enumerable
  include ::Hamster::Enumerable

  # Return a `List` with all items from this `List`, followed by all items from
  # `other`.
  #
  # @example
  #   Hamster::List[1, 2, 3].append(Hamster::List[4, 5])
  #   # => Hamster::List[1, 2, 3, 4, 5]
  # @param other [List] The list to add onto the end of this one
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#384
  def +(other); end

  # Create a new `List` with `item` added at the end. This is much less efficient
  # than adding items at the front.
  #
  # @example
  #   Hamster::List[:a, :b] << :c
  #   # => Hamster::List[:a, :b, :c]
  # @param item [Object] The item to add
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#203
  def <<(item); end

  # Return specific objects from the `List`. All overloads return `nil` if
  # the starting index is out of range.
  #
  # @overload list.slice
  # @overload list.slice
  # @overload list.slice
  #
  # source://hamster//lib/hamster/list.rb#871
  def [](arg, length = T.unsafe(nil)); end

  # Create a new `List` with `item` added at the front. This is a constant
  # time operation.
  #
  # @example
  #   Hamster::List[:b, :c].add(:a)
  #   # => Hamster::List[:a, :b, :c]
  # @param item [Object] The item to add
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#189
  def add(item); end

  # Return a `List` with all items from this `List`, followed by all items from
  # `other`.
  #
  # @example
  #   Hamster::List[1, 2, 3].append(Hamster::List[4, 5])
  #   # => Hamster::List[1, 2, 3, 4, 5]
  # @param other [List] The list to add onto the end of this one
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#377
  def append(other); end

  # Retrieve the item at `index`. Negative indices count back from the end of
  # the list (-1 is the last item). If `index` is invalid (either too high or
  # too low), return `nil`.
  #
  # @param index [Integer] The index to retrieve
  # @return [Object]
  #
  # source://hamster//lib/hamster/list.rb#787
  def at(index); end

  # Return two `List`s, one up to (but not including) the first item for which the
  # block returns true, and another of all the remaining items.
  #
  # @example
  #   Hamster::List[1, 3, 4, 2, 5].break { |x| x > 3 }
  #   # => [Hamster::List[1, 3], Hamster::List[4, 2, 5]]
  # @return [Array]
  # @yield [item]
  #
  # source://hamster//lib/hamster/list.rb#525
  def break(&block); end

  # Return `true` if the size of this list can be obtained in constant time (without
  # traversing the list).
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/list.rb#1230
  def cached_size?; end

  # Split the items in this list in groups of `number`. Return a list of lists.
  #
  # @example
  #   ("a".."o").to_list.chunk(5)
  #   # => Hamster::List[
  #   #      Hamster::List["a", "b", "c", "d", "e"],
  #   #      Hamster::List["f", "g", "h", "i", "j"],
  #   #      Hamster::List["k", "l", "m", "n", "o"]]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#726
  def chunk(number); end

  # Return an empty `List`. If used on a subclass, returns an empty instance
  # of that class.
  #
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#534
  def clear; end

  # Return `self`. Since this is an immutable object duplicates are
  # equivalent.
  #
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#1190
  def clone; end

  # Return a `List` in which each element is derived from the corresponding
  # element in this `List`, transformed through the given block. If no block
  # is given, returns an `Enumerator`.
  #
  # @example
  #   Hamster::List[3, 2, 1].map { |e| e * e } # => Hamster::List[9, 4, 1]
  # @return [List, Enumerator]
  # @yield [item]
  #
  # source://hamster//lib/hamster/list.rb#238
  def collect(&block); end

  # Return a `List` of all combinations of length `n` of items from this `List`.
  #
  # @example
  #   Hamster::List[1,2,3].combination(2)
  #   # => Hamster::List[
  #   #      Hamster::List[1, 2],
  #   #      Hamster::List[1, 3],
  #   #      Hamster::List[2, 3]]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#708
  def combination(n); end

  # Return a `List` with all items from this `List`, followed by all items from
  # `other`.
  #
  # @example
  #   Hamster::List[1, 2, 3].append(Hamster::List[4, 5])
  #   # => Hamster::List[1, 2, 3, 4, 5]
  # @param other [List] The list to add onto the end of this one
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#383
  def concat(other); end

  # Create a new `List` with `item` added at the front. This is a constant
  # time operation.
  #
  # @example
  #   Hamster::List[:b, :c].add(:a)
  #   # => Hamster::List[:a, :b, :c]
  # @param item [Object] The item to add
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#192
  def cons(item); end

  # Concatenate an infinite series of copies of this `List` together into a
  # new `List`. Or, if empty, just return an empty list.
  #
  # @example
  #   Hamster::List[1, 2, 3].cycle.take(10)
  #   # => Hamster::List[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#458
  def cycle; end

  # Return a `List` with all elements equal to `obj` removed. `#==` is used
  # for testing equality.
  #
  # @example
  #   Hamster::List[:a, :b, :a, :a, :c].delete(:a) # => Hamster::List[:b, :c]
  # @param obj [Object] The object to remove.
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#994
  def delete(obj); end

  # Return a `List` containing the same items, minus the one at `index`.
  # If `index` is negative, it counts back from the end of the list.
  #
  # @example
  #   Hamster::List[1, 2, 3].delete_at(1)  # => Hamster::List[1, 3]
  #   Hamster::List[1, 2, 3].delete_at(-1) # => Hamster::List[1, 2]
  # @param index [Integer] The index of the item to remove
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#1010
  def delete_at(index); end

  # Return a `List` containing all items after the first `number` items from
  # this `List`.
  #
  # @example
  #   Hamster::List[1, 3, 5, 7, 6, 4, 2].drop(3)
  #   # => Hamster::List[7, 6, 4, 2]
  # @param number [Integer] The number of items to skip over
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#357
  def drop(number); end

  # Return a `List` which contains all elements starting from the
  # first element for which the block returns `nil` or `false`.
  #
  # @example
  #   Hamster::List[1, 3, 5, 7, 6, 4, 2].drop_while { |e| e < 5 }
  #   # => Hamster::List[5, 7, 6, 4, 2]
  # @return [List, Enumerator]
  # @yield [item]
  #
  # source://hamster//lib/hamster/list.rb#308
  def drop_while(&block); end

  # Return `self`. Since this is an immutable object duplicates are
  # equivalent.
  #
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#1187
  def dup; end

  # Call the given block once for each item in the list, passing each
  # item from first to last successively to the block. If no block is given,
  # returns an `Enumerator`.
  #
  # @return [self]
  # @yield [item]
  #
  # source://hamster//lib/hamster/list.rb#213
  def each; end

  # Split the items in this list in groups of `number`, and yield each group
  # to the block (as a `List`). If no block is given, returns an
  # `Enumerator`.
  #
  # @return [self, Enumerator]
  # @yield [list] Once for each chunk.
  #
  # source://hamster//lib/hamster/list.rb#740
  def each_chunk(number, &block); end

  # Split the items in this list in groups of `number`, and yield each group
  # to the block (as a `List`). If no block is given, returns an
  # `Enumerator`.
  #
  # @return [self, Enumerator]
  # @yield [list] Once for each chunk.
  #
  # source://hamster//lib/hamster/list.rb#745
  def each_slice(number, &block); end

  # Return true if `other` has the same type and contents as this `Hash`.
  #
  # @param other [Object] The collection to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1165
  def eql?(other); end

  # Replace a range of indexes with the given object.
  #
  # @overload fill
  # @overload fill
  # @overload fill
  # @raise [IndexError] if index is out of negative range.
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#1058
  def fill(obj, index = T.unsafe(nil), length = T.unsafe(nil)); end

  # Return a `List` which contains all the items for which the given block
  # returns true.
  #
  # @example
  #   Hamster::List["Bird", "Cow", "Elephant"].select { |e| e.size >= 4 }
  #   # => Hamster::List["Bird", "Elephant"]
  # @return [List]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/list.rb#278
  def find_all(&block); end

  # Return a `List` which is realized by transforming each item into a `List`,
  # and flattening the resulting lists.
  #
  # @example
  #   Hamster::List[1, 2, 3].flat_map { |x| Hamster::List[x, 100] }
  #   # => Hamster::List[1, 100, 2, 100, 3, 100]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#248
  def flat_map(&block); end

  # Return a new `List` with all nested lists recursively "flattened out",
  # that is, their elements inserted into the new `List` in the place where
  # the nested list originally was.
  #
  # @example
  #   Hamster::List[Hamster::List[1, 2], Hamster::List[3, 4]].flatten
  #   # => Hamster::List[1, 2, 3, 4]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#756
  def flatten; end

  # Passes each item to the block, and gathers them into a {Hash} where the
  # keys are return values from the block, and the values are `List`s of items
  # for which the block returned that value.
  #
  # @example
  #   Hamster::List["a", "b", "ab"].group_by { |e| e.size }
  #   # Hamster::Hash[
  #   #   1 => Hamster::List["b", "a"],
  #   #   2 => Hamster::List["ab"]
  #   # ]
  # @return [Hash]
  # @yield [item]
  #
  # source://hamster//lib/hamster/list.rb#779
  def group(&block); end

  # Passes each item to the block, and gathers them into a {Hash} where the
  # keys are return values from the block, and the values are `List`s of items
  # for which the block returned that value.
  #
  # @example
  #   Hamster::List["a", "b", "ab"].group_by { |e| e.size }
  #   # Hamster::Hash[
  #   #   1 => Hamster::List["b", "a"],
  #   #   2 => Hamster::List["ab"]
  #   # ]
  # @return [Hash]
  # @yield [item]
  #
  # source://hamster//lib/hamster/list.rb#776
  def group_by(&block); end

  # See `Object#hash`
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/list.rb#1180
  def hash; end

  # Return a `List` of indices of matching objects.
  #
  # @overload indices
  # @overload indices
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#893
  def indices(object = T.unsafe(nil), i = T.unsafe(nil), &block); end

  # Return a `List` with all elements except the last one.
  #
  # @example
  #   Hamster::List["a", "b", "c"].init # => Hamster::List["a", "b"]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#651
  def init; end

  # Return a `List` of all prefixes of this list.
  #
  # @example
  #   Hamster::List[1,2,3].inits
  #   # => Hamster::List[
  #   #      Hamster::List[1],
  #   #      Hamster::List[1, 2],
  #   #      Hamster::List[1, 2, 3]]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#691
  def inits; end

  # Return a new `List` with the given items inserted before the item at `index`.
  #
  # @example
  #   Hamster::List["A", "D", "E"].insert(1, "B", "C") # => Hamster::List["A", "B", "C", "D", "E"]
  # @param index [Integer] The index where the new items should go
  # @param items [Array] The items to add
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#973
  def insert(index, *items); end

  # Return the contents of this `List` as a programmer-readable `String`. If all the
  # items in the list are serializable as Ruby literal strings, the returned string can
  # be passed to `eval` to reconstitute an equivalent `List`.
  #
  # @return [String]
  #
  # source://hamster//lib/hamster/list.rb#1203
  def inspect; end

  # Return a new `List` with `sep` inserted between each of the existing elements.
  #
  # @example
  #   Hamster::List["one", "two", "three"].intersperse(" ")
  #   # => Hamster::List["one", " ", "two", " ", "three"]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#587
  def intersperse(sep); end

  # Return a `List` which contains all the items for which the given block
  # returns true.
  #
  # @example
  #   Hamster::List["Bird", "Cow", "Elephant"].select { |e| e.size >= 4 }
  #   # => Hamster::List["Bird", "Elephant"]
  # @return [List]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/list.rb#279
  def keep_if(&block); end

  # Return the last item in this list.
  #
  # @return [Object]
  #
  # source://hamster//lib/hamster/list.rb#658
  def last; end

  # Return the number of items in this `List`.
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/list.rb#178
  def length; end

  # Return a `List` in which each element is derived from the corresponding
  # element in this `List`, transformed through the given block. If no block
  # is given, returns an `Enumerator`.
  #
  # @example
  #   Hamster::List[3, 2, 1].map { |e| e * e } # => Hamster::List[9, 4, 1]
  # @return [List, Enumerator]
  # @yield [item]
  #
  # source://hamster//lib/hamster/list.rb#231
  def map(&block); end

  # Merge all the nested lists into a single list, using the given comparator
  # block to determine the order which items should be shifted out of the nested
  # lists and into the output list.
  #
  # @example
  #   list_1 = Hamster::List[1, -3, -5]
  #   list_2 = Hamster::List[-2, 4, 6]
  #   Hamster::List[list_1, list_2].merge { |a,b| a.abs <=> b.abs }
  #   # => Hamster::List[1, -2, -3, 4, -5, 6]
  # @return [List]
  # @yield [a, b] Pairs of items from matching indices in each list.
  # @yieldreturn [Integer] Negative if the first element should be selected
  #   first, positive if the latter element, or zero if
  #   either.
  #
  # source://hamster//lib/hamster/list.rb#922
  def merge(&comparator); end

  # Merge all the nested lists into a single list, using sort keys generated
  # by mapping the items in the nested lists through the given block to determine the
  # order which items should be shifted out of the nested lists and into the output
  # list. Whichever nested list's `#head` has the "lowest" sort key (according to
  # their natural order) will be the first in the merged `List`.
  #
  # @example
  #   list_1 = Hamster::List[1, -3, -5]
  #   list_2 = Hamster::List[-2, 4, 6]
  #   Hamster::List[list_1, list_2].merge_by { |x| x.abs }
  #   # => Hamster::List[1, -2, -3, 4, -5, 6]
  # @return [List]
  # @yield [item] Once for each item in either list.
  # @yieldreturn [Object] A sort key for the element.
  #
  # source://hamster//lib/hamster/list.rb#948
  def merge_by(&transformer); end

  # Return two `List`s, the first containing all the elements for which the
  # block evaluates to true, the second containing the rest.
  #
  # @example
  #   Hamster::List[1, 2, 3, 4, 5, 6].partition { |x| x.even? }
  #   # => [Hamster::List[2, 4, 6], Hamster::List[1, 3, 5]]
  # @return [List]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/list.rb#1153
  def partition(&block); end

  # Yields all permutations of length `n` of the items in the list, and then
  # returns `self`. If no length `n` is specified, permutations of the entire
  # list will be yielded.
  #
  # There is no guarantee about which order the permutations will be yielded in.
  #
  # If no block is given, an `Enumerator` is returned instead.
  #
  # @example
  #   Hamster::List[1, 2, 3].permutation.to_a
  #   # => [Hamster::List[1, 2, 3],
  #   #     Hamster::List[2, 1, 3],
  #   #     Hamster::List[2, 3, 1],
  #   #     Hamster::List[1, 3, 2],
  #   #     Hamster::List[3, 1, 2],
  #   #     Hamster::List[3, 2, 1]]
  # @return [self, Enumerator]
  # @yield [list] Once for each permutation.
  #
  # source://hamster//lib/hamster/list.rb#1097
  def permutation(length = T.unsafe(nil), &block); end

  # Return a `List` containing all but the last item from this `List`.
  #
  # @example
  #   Hamster::List["A", "B", "C"].pop  # => Hamster::List["A", "B"]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#339
  def pop; end

  # Allows this `List` to be printed at the `pry` console, or using `pp` (from the
  # Ruby standard library), in a way which takes the amount of horizontal space on
  # the screen into account, and which indents nested structures to make them easier
  # to read.
  #
  # @private
  #
  # source://hamster//lib/hamster/list.rb#1215
  def pretty_print(pp); end

  # @private
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1223
  def respond_to?(name, include_private = T.unsafe(nil)); end

  # Return a `List` with the same items, but in reverse order.
  #
  # @example
  #   Hamster::List["A", "B", "C"].reverse # => Hamster::List["C", "B", "A"]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#392
  def reverse; end

  # Return a new `List` with the same elements, but rotated so that the one at
  # index `count` is the first element of the new list. If `count` is positive,
  # the elements will be shifted left, and those shifted past the lowest position
  # will be moved to the end. If `count` is negative, the elements will be shifted
  # right, and those shifted past the last position will be moved to the beginning.
  #
  # @example
  #   l = Hamster::List["A", "B", "C", "D", "E", "F"]
  #   l.rotate(2)   # => Hamster::List["C", "D", "E", "F", "A", "B"]
  #   l.rotate(-1)  # => Hamster::List["F", "A", "B", "C", "D", "E"]
  # @param count [Integer] The number of positions to shift items by
  # @raise [TypeError] if count is not an integer.
  # @return [Vector]
  #
  # source://hamster//lib/hamster/list.rb#479
  def rotate(count = T.unsafe(nil)); end

  # Return a randomly chosen element from this list.
  #
  # @return [Object]
  #
  # source://hamster//lib/hamster/list.rb#961
  def sample; end

  # Return a `List` which contains all the items for which the given block
  # returns true.
  #
  # @example
  #   Hamster::List["Bird", "Cow", "Elephant"].select { |e| e.size >= 4 }
  #   # => Hamster::List["Bird", "Elephant"]
  # @return [List]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/list.rb#267
  def select(&block); end

  # Return the number of items in this `List`.
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/list.rb#166
  def size; end

  # Return specific objects from the `List`. All overloads return `nil` if
  # the starting index is out of range.
  #
  # @overload list.slice
  # @overload list.slice
  # @overload list.slice
  #
  # source://hamster//lib/hamster/list.rb#838
  def slice(arg, length = T.unsafe(nil)); end

  # Return a new `List` with the same items, but sorted.
  #
  # @overload sort
  # @overload sort
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#559
  def sort(&comparator); end

  # Return a new `List` with the same items, but sorted. The sort order is
  # determined by mapping the items through the given block to obtain sort
  # keys, and then sorting the keys according to their natural sort order
  # (`#<=>`).
  #
  # @example
  #   Hamster::List["Elephant", "Dog", "Lion"].sort_by { |e| e.size }
  #   # => Hamster::List["Dog", "Lion", "Elephant"]
  # @return [List]
  # @yield [element] Once for each element.
  # @yieldreturn a sort key object for the yielded element.
  #
  # source://hamster//lib/hamster/list.rb#575
  def sort_by(&transformer); end

  # Return two `List`s, one up to (but not including) the first item for which the
  # block returns `nil` or `false`, and another of all the remaining items.
  #
  # @example
  #   Hamster::List[4, 3, 5, 2, 1].span { |x| x > 2 }
  #   # => [Hamster::List[4, 3, 5], Hamster::List[2, 1]]
  # @return [Array]
  # @yield [item]
  #
  # source://hamster//lib/hamster/list.rb#508
  def span(&block); end

  # Return two `List`s, one of the first `number` items, and another with the
  # remaining.
  #
  # @example
  #   Hamster::List["a", "b", "c", "d"].split_at(2)
  #   # => [Hamster::List["a", "b"], Hamster::List["c", "d"]]
  # @param number [Integer] The index at which to split this list
  # @return [Array]
  #
  # source://hamster//lib/hamster/list.rb#495
  def split_at(number); end

  # Yield every non-empty sublist to the given block. (The entire `List` also
  # counts as one sublist.)
  #
  # @example
  #   Hamster::List[1, 2, 3].subsequences { |list| p list }
  #   # prints:
  #   # Hamster::List[1]
  #   # Hamster::List[1, 2]
  #   # Hamster::List[1, 2, 3]
  #   # Hamster::List[2]
  #   # Hamster::List[2, 3]
  #   # Hamster::List[3]
  # @return [self]
  # @yield [sublist] One or more contiguous elements from this list
  #
  # source://hamster//lib/hamster/list.rb#1133
  def subsequences(&block); end

  # Return a `List` of all suffixes of this list.
  #
  # @example
  #   Hamster::List[1,2,3].tails
  #   # => Hamster::List[
  #   #      Hamster::List[1, 2, 3],
  #   #      Hamster::List[2, 3],
  #   #      Hamster::List[3]]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#674
  def tails; end

  # Return a `List` containing the first `number` items from this `List`.
  #
  # @example
  #   Hamster::List[1, 3, 5, 7, 6, 4, 2].take(3)
  #   # => Hamster::List[1, 3, 5]
  # @param number [Integer] The number of items to retain
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#325
  def take(number); end

  # Return a `List` which contains all elements up to, but not including, the
  # first element for which the block returns `nil` or `false`.
  #
  # @example
  #   Hamster::List[1, 3, 5, 7, 6, 4, 2].take_while { |e| e < 5 }
  #   # => Hamster::List[1, 3]
  # @return [List, Enumerator]
  # @yield [item]
  #
  # source://hamster//lib/hamster/list.rb#290
  def take_while(&block); end

  # Return `self`.
  #
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#1194
  def to_list; end

  # Gather the first element of each nested list into a new `List`, then the second
  # element of each nested list, then the third, and so on. In other words, if each
  # nested list is a "row", return a `List` of "columns" instead.
  #
  # Although the returned list is lazy, each returned nested list (each "column")
  # is strict. So while each nested list in the input can be infinite, the parent
  # `List` must not be, or trying to realize the first element in the output will
  # cause an infinite loop.
  #
  # @example
  #   # First let's create some infinite lists
  #   list1 = Hamster.iterate(1, &:next)
  #   list2 = Hamster.iterate(2) { |n| n * 2 }
  #   list3 = Hamster.iterate(3) { |n| n * 3 }
  #
  #   # Now we transpose our 3 infinite "rows" into an infinite series of 3-element "columns"
  #   Hamster::List[list1, list2, list3].transpose.take(4)
  #   # => Hamster::List[
  #   #      Hamster::List[1, 2, 3],
  #   #      Hamster::List[2, 4, 9],
  #   #      Hamster::List[3, 8, 27],
  #   #      Hamster::List[4, 16, 81]]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#440
  def transpose; end

  # Return a `List` with all the elements from both this list and `other`,
  # with all duplicates removed.
  #
  # @example
  #   Hamster::List[1, 2].union(Hamster::List[2, 3]) # => Hamster::List[1, 2, 3]
  # @param other [List] The list to merge with
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#636
  def union(other, items = T.unsafe(nil)); end

  # Return a `List` with the same items, but all duplicates removed.
  # Use `#hash` and `#eql?` to determine which items are duplicates.
  #
  # @example
  #   Hamster::List[:a, :b, :a, :c, :b].uniq      # => Hamster::List[:a, :b, :c]
  #   Hamster::List["a", "A", "b"].uniq(&:upcase) # => Hamster::List["a", "b"]
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#602
  def uniq(&block); end

  # Combine two lists by "zipping" them together.  The corresponding elements
  # from this `List` and each of `others` (that is, the elements with the
  # same indices) will be gathered into lists.
  #
  # If `others` contains fewer elements than this list, `nil` will be used
  # for padding.
  #
  # @example
  #   Hamster::List["A", "B", "C"].zip(Hamster::List[1, 2, 3])
  #   # => Hamster::List[Hamster::List["A", 1], Hamster::List["B", 2], Hamster::List["C", 3]]
  # @param others [List] The list to zip together with this one
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#409
  def zip(others); end

  # Return a `List` with all the elements from both this list and `other`,
  # with all duplicates removed.
  #
  # @example
  #   Hamster::List[1, 2].union(Hamster::List[2, 3]) # => Hamster::List[1, 2, 3]
  # @param other [List] The list to merge with
  # @return [List]
  #
  # source://hamster//lib/hamster/list.rb#643
  def |(other, items = T.unsafe(nil)); end

  protected

  # Separate from `uniq` so as not to expose `items` in the public API.
  #
  # @private
  #
  # source://hamster//lib/hamster/list.rb#608
  def _uniq(items, &block); end

  private

  # Perform compositions of `car` and `cdr` operations (traditional shorthand
  # for `head` and `tail` respectively). Their names consist of a `c`,
  # followed by at least one `a` or `d`, and finally an `r`. The series of
  # `a`s and `d`s in the method name identify the series of `car` and `cdr`
  # operations performed, in inverse order.
  #
  # @example
  #   l = Hamster::List[nil, Hamster::List[1]]
  #   l.car   # => nil
  #   l.cdr   # => Hamster::List[Hamster::List[1]]
  #   l.cadr  # => Hamster::List[1]
  #   l.caadr # => 1
  # @return [Object, List]
  #
  # source://hamster//lib/hamster/list.rb#1249
  def method_missing(name, *args, &block); end

  class << self
    # Create a new `List` populated with the given items.
    #
    # @example
    #   list = Hamster::List[:a, :b, :c]
    #   # => Hamster::List[:a, :b, :c]
    # @return [List]
    #
    # source://hamster//lib/hamster/list.rb#132
    def [](*items); end

    # Return an empty `List`.
    #
    # @return [List]
    #
    # source://hamster//lib/hamster/list.rb#139
    def empty; end

    # This method exists distinct from `.[]` since it is ~30% faster
    # than splatting the argument.
    #
    # Marking as private only because it was introduced for an internal
    # refactoring. It could potentially be made public with a good name.
    #
    # @private
    #
    # source://hamster//lib/hamster/list.rb#150
    def from_enum(items); end
  end
end

# @private
#
# source://hamster//lib/hamster/list.rb#123
Hamster::List::CADR = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://hamster//lib/hamster/mutable_hash.rb#6
class Hamster::MutableHash
  include ::Hamster::ReadCopyUpdate

  # @api private
  #
  # source://hamster//lib/hamster/mutable_hash.rb#21
  def []=(key, value); end

  # @api private
  #
  # source://hamster//lib/hamster/mutable_hash.rb#23
  def delete(key); end

  # @api private
  #
  # source://hamster//lib/hamster/mutable_hash.rb#13
  def put(key, value = T.unsafe(nil), &block); end

  # @api private
  #
  # source://hamster//lib/hamster/mutable_hash.rb#17
  def store(key, value); end

  class << self
    # @api private
    #
    # source://hamster//lib/hamster/mutable_hash.rb#9
    def [](pairs = T.unsafe(nil)); end
  end
end

# One of the `List`s which gets its items from a Partitioner
#
# @private
#
# source://hamster//lib/hamster/list.rb#1447
class Hamster::Partitioned < ::Hamster::Realizable
  # @return [Partitioned] a new instance of Partitioned
  #
  # source://hamster//lib/hamster/list.rb#1448
  def initialize(partitioner, buffer, mutex); end

  # source://hamster//lib/hamster/list.rb#1453
  def realize; end
end

# This class can divide a collection into 2 `List`s, one of items
#   for which the block returns true, and another for false
# At the same time, it guarantees the block will only be called ONCE for each item
#
# @private
#
# source://hamster//lib/hamster/list.rb#1426
class Hamster::Partitioner
  # @return [Partitioner] a new instance of Partitioner
  #
  # source://hamster//lib/hamster/list.rb#1428
  def initialize(list, block); end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1440
  def done?; end

  # Returns the value of attribute left.
  #
  # source://hamster//lib/hamster/list.rb#1427
  def left; end

  # source://hamster//lib/hamster/list.rb#1432
  def next_item; end

  # Returns the value of attribute right.
  #
  # source://hamster//lib/hamster/list.rb#1427
  def right; end
end

# @private
#
# source://hamster//lib/hamster/read_copy_update.rb#6
module Hamster::ReadCopyUpdate
  extend ::Forwardable

  # source://hamster//lib/hamster/read_copy_update.rb#9
  def initialize(content); end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/read_copy_update.rb#17
  def ==(other); end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/read_copy_update.rb#14
  def eql?(other); end

  # source://hamster//lib/hamster/read_copy_update.rb#19
  def inspect(*args, **_arg1, &block); end

  # source://hamster//lib/hamster/read_copy_update.rb#20
  def to_s(*args, **_arg1, &block); end

  protected

  # source://hamster//lib/hamster/read_copy_update.rb#24
  def transform; end

  private

  # source://hamster//lib/hamster/read_copy_update.rb#33
  def method_missing(name, *args, &block); end
end

# Common behavior for other classes which implement various kinds of `List`s
#
# @private
#
# source://hamster//lib/hamster/list.rb#1384
class Hamster::Realizable
  include ::Enumerable
  include ::Hamster::Enumerable
  include ::Hamster::List

  # @return [Realizable] a new instance of Realizable
  #
  # source://hamster//lib/hamster/list.rb#1387
  def initialize; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1412
  def cached_size?; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1402
  def empty?; end

  # source://hamster//lib/hamster/list.rb#1395
  def first; end

  # source://hamster//lib/hamster/list.rb#1391
  def head; end

  # source://hamster//lib/hamster/list.rb#1410
  def length; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1416
  def realized?; end

  # source://hamster//lib/hamster/list.rb#1407
  def size; end

  # source://hamster//lib/hamster/list.rb#1397
  def tail; end
end

# `Hamster::Set` is a collection of unordered values with no duplicates. Testing whether
# an object is present in the `Set` can be done in constant time. `Set` is also `Enumerable`, so you can
# iterate over the members of the set with {#each}, transform them with {#map}, filter
# them with {#select}, and so on. Some of the `Enumerable` methods are overridden to
# return Hamster collections.
#
# Like the `Set` class in Ruby's standard library, which we will call RubySet,
# `Hamster::Set` defines equivalency of objects using `#hash` and `#eql?`. No two
# objects with the same `#hash` code, and which are also `#eql?`, can coexist in the
# same `Set`. If one is already in the `Set`, attempts to add another one will have
# no effect.
#
# `Set`s have no natural ordering and cannot be compared using `#<=>`. However, they
# define {#<}, {#>}, {#<=}, and {#>=} as shorthand for {#proper_subset?},
# {#proper_superset?}, {#subset?}, and {#superset?} respectively.
#
# The basic set-theoretic operations {#union}, {#intersection}, {#difference}, and
# {#exclusion} work with any `Enumerable` object.
#
# A `Set` can be created in either of the following ways:
#
#     Hamster::Set.new([1, 2, 3]) # any Enumerable can be used to initialize
#     Hamster::Set['A', 'B', 'C', 'D']
#
# The latter 2 forms of initialization can be used with your own, custom subclasses
# of `Hamster::Set`.
#
# Unlike RubySet, all methods which you might expect to "modify" a `Hamster::Set`
# actually return a new set and leave the existing one unchanged.
#
# @example
#   set1 = Hamster::Set[1, 2] # => Hamster::Set[1, 2]
#   set2 = Hamster::Set[1, 2] # => Hamster::Set[1, 2]
#   set1 == set2              # => true
#   set3 = set1.add("foo")    # => Hamster::Set[1, 2, "foo"]
#   set3 - set2               # => Hamster::Set["foo"]
#   set3.subset?(set1)        # => false
#   set1.subset?(set3)        # => true
#
# source://hamster//lib/hamster/set.rb#50
class Hamster::Set
  include ::Hamster::Immutable
  include ::Hamster::Immutable::InstanceMethods
  include ::Enumerable
  include ::Hamster::Enumerable
  extend ::Hamster::Immutable::ClassMethods

  # @return [Set] a new instance of Set
  #
  # source://hamster//lib/hamster/set.rb#79
  def initialize(items = T.unsafe(nil)); end

  # Return a new `Set` which contains all the items which are members of both
  # this `Set` and `other`. `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] & Hamster::Set[2, 3] # => Hamster::Set[2]
  # @param other [Enumerable] The collection to intersect with
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#337
  def &(other); end

  # Return a new `Set` which contains all the members of both this `Set` and `other`.
  # `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] | Hamster::Set[2, 3] # => Hamster::Set[1, 2, 3]
  # @param other [Enumerable] The collection to merge with
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#313
  def +(other); end

  # Return a new `Set` with all the items in `other` removed. `other` can be
  # any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] - Hamster::Set[2, 3] # => Hamster::Set[1]
  # @param other [Enumerable] The collection to subtract from this set
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#356
  def -(other); end

  # Returns `true` if `other` contains all the items in this `Set`, plus at least
  # one item which is not in this set.
  #
  # @example
  #   Hamster::Set[2, 3].proper_subset?(Hamster::Set[1, 2, 3])    # => true
  #   Hamster::Set[1, 2, 3].proper_subset?(Hamster::Set[1, 2, 3]) # => false
  # @param other [Set]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#426
  def <(other); end

  # Return a new `Set` with `item` added. If `item` is already in the set,
  # return `self`.
  #
  # @example
  #   Hamster::Set[1, 2, 3].add(4) # => Hamster::Set[1, 2, 4, 3]
  #   Hamster::Set[1, 2, 3].add(2) # => Hamster::Set[1, 2, 3]
  # @param item [Object] The object to add
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#109
  def <<(item); end

  # Return `true` if all items in this `Set` are also in `other`.
  #
  # @example
  #   Hamster::Set[2, 3].subset?(Hamster::Set[1, 2, 3]) # => true
  # @param other [Set]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#395
  def <=(other); end

  # Return true if `other` has the same type and contents as this `Set`.
  #
  # @param other [Object] The object to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#523
  def ==(other); end

  # Returns `true` if this `Set` contains all the items in `other`, plus at least
  # one item which is not in `other`.
  #
  # @example
  #   Hamster::Set[1, 2, 3].proper_superset?(Hamster::Set[2, 3])    # => true
  #   Hamster::Set[1, 2, 3].proper_superset?(Hamster::Set[1, 2, 3]) # => false
  # @param other [Set]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#440
  def >(other); end

  # Return `true` if all items in `other` are also in this `Set`.
  #
  # @example
  #   Hamster::Set[1, 2, 3].superset?(Hamster::Set[2, 3]) # => true
  # @param other [Set]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#407
  def >=(other); end

  # Return a new `Set` which contains all the items which are members of this
  # `Set` or of `other`, but not both. `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] ^ Hamster::Set[2, 3] # => Hamster::Set[1, 3]
  # @param other [Enumerable] The collection to take the exclusive disjunction of
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#369
  def ^(other); end

  # Return a new `Set` with `item` added. If `item` is already in the set,
  # return `self`.
  #
  # @example
  #   Hamster::Set[1, 2, 3].add(4) # => Hamster::Set[1, 2, 4, 3]
  #   Hamster::Set[1, 2, 3].add(2) # => Hamster::Set[1, 2, 3]
  # @param item [Object] The object to add
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#106
  def add(item); end

  # If `item` is not a member of this `Set`, return a new `Set` with `item` added.
  # Otherwise, return `false`.
  #
  # @example
  #   Hamster::Set[1, 2, 3].add?(4) # => Hamster::Set[1, 2, 4, 3]
  #   Hamster::Set[1, 2, 3].add?(2) # => false
  # @param item [Object] The object to add
  # @return [Set, false]
  #
  # source://hamster//lib/hamster/set.rb#120
  def add?(item); end

  # source://hamster//lib/hamster/set.rb#489
  def classify(&block); end

  # Return an empty `Set` instance, of the same class as this one. Useful if you
  # have multiple subclasses of `Set` and want to treat them polymorphically.
  #
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#505
  def clear; end

  # Call the block once for each item in this `Set`. All the values returned
  # from the block will be gathered into a new `Set`. If no block is given,
  # an `Enumerator` is returned instead.
  #
  # @example
  #   Hamster::Set["Cat", "Elephant", "Dog", "Lion"].map { |e| e.size }
  #   # => Hamster::Set[8, 4, 3]
  # @return [Set]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/set.rb#219
  def collect; end

  # Return a new `Set` with `item` removed. If `item` is not a member of the set,
  # return `self`.
  #
  # @example
  #   Hamster::Set[1, 2, 3].delete(1)  # => Hamster::Set[2, 3]
  #   Hamster::Set[1, 2, 3].delete(99) # => Hamster::Set[1, 2, 3]
  # @param item [Object] The object to remove
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#133
  def delete(item); end

  # If `item` is a member of this `Set`, return a new `Set` with `item` removed.
  # Otherwise, return `false`.
  #
  # @example
  #   Hamster::Set[1, 2, 3].delete?(1)  # => Hamster::Set[2, 3]
  #   Hamster::Set[1, 2, 3].delete?(99) # => false
  # @param item [Object] The object to remove
  # @return [Set, false]
  #
  # source://hamster//lib/hamster/set.rb#147
  def delete?(item); end

  # Return a new `Set` with all the items in `other` removed. `other` can be
  # any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] - Hamster::Set[2, 3] # => Hamster::Set[1]
  # @param other [Enumerable] The collection to subtract from this set
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#347
  def difference(other); end

  # Return `true` if this `Set` and `other` do not share any items.
  #
  # @example
  #   Hamster::Set[1, 2].disjoint?(Hamster::Set[8, 9]) # => true
  # @param other [Set]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#449
  def disjoint?(other); end

  # Call the block once for each item in this `Set`. No specific iteration order
  # is guaranteed, but the order will be stable for any particular `Set`. If
  # no block is given, an `Enumerator` is returned instead.
  #
  # @example
  #   Hamster::Set["Dog", "Elephant", "Lion"].each { |e| puts e }
  #   Elephant
  #   Dog
  #   Lion
  #   # => Hamster::Set["Dog", "Elephant", "Lion"]
  # @return [self, Enumerator]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/set.rb#164
  def each; end

  # Return `true` if this `Set` contains no items.
  #
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#86
  def empty?; end

  # Return true if `other` has the same type and contents as this `Set`.
  #
  # @param other [Object] The object to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#513
  def eql?(other); end

  # Return a new `Set` which contains all the items which are members of this
  # `Set` or of `other`, but not both. `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] ^ Hamster::Set[2, 3] # => Hamster::Set[1, 3]
  # @param other [Enumerable] The collection to take the exclusive disjunction of
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#366
  def exclusion(other); end

  # Return a new `Set` with all the items for which the block returns true.
  #
  # @example
  #   Hamster::Set["Elephant", "Dog", "Lion"].select { |e| e.size >= 4 }
  #   # => Hamster::Set["Elephant", "Lion"]
  # @return [Set]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/set.rb#201
  def find_all; end

  # Return a member of this `Set`. The member chosen will be the first one which
  # would be yielded by {#each}. If the set is empty, return `nil`.
  #
  # @example
  #   Hamster::Set["A", "B", "C"].first # => "C"
  # @return [Object]
  #
  # source://hamster//lib/hamster/set.rb#243
  def first; end

  # Recursively insert the contents of any nested `Set`s into this `Set`, and
  # remove them.
  #
  # @example
  #   Hamster::Set[Hamster::Set[1, 2], Hamster::Set[3, 4]].flatten
  #   # => Hamster::Set[1, 2, 3, 4]
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#481
  def flatten; end

  # source://hamster//lib/hamster/set.rb#488
  def group(&block); end

  # See `Object#hash`.
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/set.rb#527
  def hash; end

  # Return `true` if the given item is present in this `Set`. More precisely,
  # return `true` if an object with the same `#hash` code, and which is also `#eql?`
  # to the given object is present.
  #
  # @example
  #   Hamster::Set["A", "B", "C"].include?("B") # => true
  #   Hamster::Set["A", "B", "C"].include?("Z") # => false
  # @param object [Object] The object to check for
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#231
  def include?(object); end

  # Return `true` if this `Set` and `other` have at least one item in common.
  #
  # @example
  #   Hamster::Set[1, 2].intersect?(Hamster::Set[2, 3]) # => true
  # @param other [Set]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#469
  def intersect?(other); end

  # Return a new `Set` which contains all the items which are members of both
  # this `Set` and `other`. `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] & Hamster::Set[2, 3] # => Hamster::Set[2]
  # @param other [Enumerable] The collection to intersect with
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#324
  def intersection(other); end

  # Return a new `Set` with all the items for which the block returns true.
  #
  # @example
  #   Hamster::Set["Elephant", "Dog", "Lion"].select { |e| e.size >= 4 }
  #   # => Hamster::Set["Elephant", "Lion"]
  # @return [Set]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/set.rb#202
  def keep_if; end

  # Return the number of items in this `Set`.
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/set.rb#95
  def length; end

  # Call the block once for each item in this `Set`. All the values returned
  # from the block will be gathered into a new `Set`. If no block is given,
  # an `Enumerator` is returned instead.
  #
  # @example
  #   Hamster::Set["Cat", "Elephant", "Dog", "Lion"].map { |e| e.size }
  #   # => Hamster::Set[8, 4, 3]
  # @return [Set]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/set.rb#214
  def map; end

  # @private
  #
  # source://hamster//lib/hamster/set.rb#542
  def marshal_dump; end

  # @private
  #
  # source://hamster//lib/hamster/set.rb#551
  def marshal_load(dictionary); end

  # Return `true` if the given item is present in this `Set`. More precisely,
  # return `true` if an object with the same `#hash` code, and which is also `#eql?`
  # to the given object is present.
  #
  # @example
  #   Hamster::Set["A", "B", "C"].include?("B") # => true
  #   Hamster::Set["A", "B", "C"].include?("Z") # => false
  # @param object [Object] The object to check for
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#234
  def member?(object); end

  # Return a new `Set` which contains all the members of both this `Set` and `other`.
  # `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] | Hamster::Set[2, 3] # => Hamster::Set[1, 2, 3]
  # @param other [Enumerable] The collection to merge with
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#314
  def merge(other); end

  # Returns `true` if `other` contains all the items in this `Set`, plus at least
  # one item which is not in this set.
  #
  # @example
  #   Hamster::Set[2, 3].proper_subset?(Hamster::Set[1, 2, 3])    # => true
  #   Hamster::Set[1, 2, 3].proper_subset?(Hamster::Set[1, 2, 3]) # => false
  # @param other [Set]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#418
  def proper_subset?(other); end

  # Returns `true` if this `Set` contains all the items in `other`, plus at least
  # one item which is not in `other`.
  #
  # @example
  #   Hamster::Set[1, 2, 3].proper_superset?(Hamster::Set[2, 3])    # => true
  #   Hamster::Set[1, 2, 3].proper_superset?(Hamster::Set[1, 2, 3]) # => false
  # @param other [Set]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#437
  def proper_superset?(other); end

  # Call the block once for each item in this `Set`. Iteration order will be
  # the opposite of {#each}. If no block is given, an `Enumerator` is
  # returned instead.
  #
  # @example
  #   Hamster::Set["Dog", "Elephant", "Lion"].reverse_each { |e| puts e }
  #   Lion
  #   Dog
  #   Elephant
  #   # => Hamster::Set["Dog", "Elephant", "Lion"]
  # @return [self]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/set.rb#183
  def reverse_each; end

  # Return a randomly chosen item from this `Set`. If the set is empty, return `nil`.
  #
  # @example
  #   Hamster::Set[1, 2, 3, 4, 5].sample # => 3
  # @return [Object]
  #
  # source://hamster//lib/hamster/set.rb#497
  def sample; end

  # Return a new `Set` with all the items for which the block returns true.
  #
  # @example
  #   Hamster::Set["Elephant", "Dog", "Lion"].select { |e| e.size >= 4 }
  #   # => Hamster::Set["Elephant", "Lion"]
  # @return [Set]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/set.rb#196
  def select; end

  # Return the number of items in this `Set`.
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/set.rb#92
  def size; end

  # Return a {SortedSet} which contains the same items as this `Set`, ordered by
  # the given comparator block.
  #
  # @example
  #   Hamster::Set["Elephant", "Dog", "Lion"].sort
  #   # => Hamster::SortedSet["Dog", "Elephant", "Lion"]
  #   Hamster::Set["Elephant", "Dog", "Lion"].sort { |a,b| a.size <=> b.size }
  #   # => Hamster::SortedSet["Dog", "Lion", "Elephant"]
  # @return [SortedSet]
  # @yield [a, b] Any number of times with different pairs of elements.
  # @yieldreturn [Integer] Negative if the first element should be sorted
  #   lower, positive if the latter element, or 0 if
  #   equal.
  #
  # source://hamster//lib/hamster/set.rb#261
  def sort(&comparator); end

  # Return a {SortedSet} which contains the same items as this `Set`, ordered
  # by mapping each item through the provided block to obtain sort keys, and
  # then sorting the keys.
  #
  # @example
  #   Hamster::Set["Elephant", "Dog", "Lion"].sort_by { |e| e.size }
  #   # => Hamster::SortedSet["Dog", "Lion", "Elephant"]
  # @return [SortedSet]
  # @yield [item] Once for each item to create the set, and then potentially
  #   again depending on what operations are performed on the
  #   returned {SortedSet}. As such, it is recommended that the
  #   block be a pure function.
  # @yieldreturn [Object] sort key for the item
  #
  # source://hamster//lib/hamster/set.rb#279
  def sort_by(&mapper); end

  # Return `true` if all items in this `Set` are also in `other`.
  #
  # @example
  #   Hamster::Set[2, 3].subset?(Hamster::Set[1, 2, 3]) # => true
  # @param other [Set]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#378
  def subset?(other); end

  # Return a new `Set` with all the items in `other` removed. `other` can be
  # any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] - Hamster::Set[2, 3] # => Hamster::Set[1]
  # @param other [Enumerable] The collection to subtract from this set
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#355
  def subtract(other); end

  # Return `true` if all items in `other` are also in this `Set`.
  #
  # @example
  #   Hamster::Set[1, 2, 3].superset?(Hamster::Set[2, 3]) # => true
  # @param other [Set]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/set.rb#404
  def superset?(other); end

  # Return `self`.
  #
  # @return [self]
  #
  # source://hamster//lib/hamster/set.rb#537
  def to_set; end

  # Return a new `Set` which contains all the members of both this `Set` and `other`.
  # `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] | Hamster::Set[2, 3] # => Hamster::Set[1, 2, 3]
  # @param other [Enumerable] The collection to merge with
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#291
  def union(other); end

  # Return a new `Set` which contains all the members of both this `Set` and `other`.
  # `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::Set[1, 2] | Hamster::Set[2, 3] # => Hamster::Set[1, 2, 3]
  # @param other [Enumerable] The collection to merge with
  # @return [Set]
  #
  # source://hamster//lib/hamster/set.rb#312
  def |(other); end

  private

  # source://hamster//lib/hamster/set.rb#559
  def new_trie(trie); end

  class << self
    # Create a new `Set` populated with the given items.
    #
    # @return [Set]
    #
    # source://hamster//lib/hamster/set.rb#57
    def [](*items); end

    # "Raw" allocation of a new `Set`. Used internally to create a new
    # instance quickly after obtaining a modified {Trie}.
    #
    # @private
    # @return [Set]
    #
    # source://hamster//lib/hamster/set.rb#74
    def alloc(trie = T.unsafe(nil)); end

    # Return an empty `Set`. If used on a subclass, returns an empty instance
    # of that class.
    #
    # @return [Set]
    #
    # source://hamster//lib/hamster/set.rb#65
    def empty; end
  end
end

# A `SortedSet` is a collection of ordered values with no duplicates. Unlike a
# {Vector}, in which items can appear in any arbitrary order, a `SortedSet` always
# keeps items either in their natural order, or in an order defined by a comparator
# block which is provided at initialization time.
#
# `SortedSet` uses `#<=>` (or its comparator block) to determine which items are
# equivalent. If the comparator indicates that an existing item and a new item are
# equal, any attempt to insert the new item will have no effect.
#
# This means that *all* the items inserted into any one `SortedSet` must all be
# comparable. For example, you cannot put `String`s and `Integer`s in the same
# `SortedSet`. This is unlike {Set}, which can store items of any type, as long
# as they all support `#hash` and `#eql?`.
#
# A `SortedSet` can be created in either of the following ways:
#
#     Hamster::SortedSet.new([1, 2, 3]) # any Enumerable can be used to initialize
#     Hamster::SortedSet['A', 'B', 'C', 'D']
#
# Or if you want to use a custom ordering:
#
#     Hamster::SortedSet.new([1,2,3]) { |a, b| -a <=> -b }
#     Hamster::SortedSet.new([1, 2, 3]) { |num| -num }
#
# `SortedSet` can use a 2-parameter block which returns 0, 1, or -1
# as a comparator (like `Array#sort`), *or* use a 1-parameter block to derive sort
# keys (like `Array#sort_by`) which will be compared using `#<=>`.
#
# Like all Hamster collections, `SortedSet`s are immutable. Any operation which you
# might expect to "modify" a `SortedSet` will actually return a new collection and
# leave the existing one unchanged.
#
# `SortedSet` supports the same basic set-theoretic operations as {Set}, including
# {#union}, {#intersection}, {#difference}, and {#exclusion}, as well as {#subset?},
# {#superset?}, and so on. Unlike {Set}, it does not define comparison operators like
# `#>` or `#<` as aliases for the superset/subset predicates. Instead, these comparison
# operators do a item-by-item comparison between the `SortedSet` and another sequential
# collection. (See `Array#<=>` for details.)
#
# Additionally, since `SortedSet`s are ordered, they also support indexed retrieval
# of items using {#at} or {#[]}. Like {Vector},
# negative indices count back from the end of the `SortedSet`.
#
# Getting the {#max} or {#min} item from a `SortedSet`, as defined by its comparator,
# is a constant time operation.
#
# source://hamster//lib/hamster/sorted_set.rb#52
class Hamster::SortedSet
  include ::Hamster::Immutable
  include ::Hamster::Immutable::InstanceMethods
  include ::Enumerable
  include ::Hamster::Enumerable
  extend ::Hamster::Immutable::ClassMethods

  # @return [SortedSet] a new instance of SortedSet
  #
  # source://hamster//lib/hamster/sorted_set.rb#85
  def initialize(items = T.unsafe(nil), &block); end

  # Return a new `SortedSet` which contains all the items which are members of both
  # this set and `other`. `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] & Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[2]
  # @param other [Enumerable] The collection to intersect with
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#626
  def &(other); end

  # Return a new `SortedSet` which contains all the members of both this set and `other`.
  # `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] | Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[1, 2, 3]
  # @param other [Enumerable] The collection to merge with
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#611
  def +(other); end

  # Return a new `SortedSet` with all the items in `other` removed. `other` can be
  # any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] - Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[1]
  # @param other [Enumerable] The collection to subtract from this set
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#641
  def -(other); end

  # Return a new `SortedSet` with `item` added. If `item` is already in the set,
  # return `self`.
  #
  # @example
  #   Hamster::SortedSet["Dog", "Lion"].add("Elephant")
  #   # => Hamster::SortedSet["Dog", "Elephant", "Lion"]
  # @param item [Object] The object to add
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#135
  def <<(item); end

  # Return specific objects from the `Vector`. All overloads return `nil` if
  # the starting index is out of range.
  #
  # @overload set.slice
  # @overload set.slice
  # @overload set.slice
  #
  # source://hamster//lib/hamster/sorted_set.rb#327
  def [](arg, length = T.unsafe(nil)); end

  # Return a new `SortedSet` with all the items which are members of this
  # set or of `other`, but not both. `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] ^ Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[1, 3]
  # @param other [Enumerable] The collection to take the exclusive disjunction of
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#655
  def ^(other); end

  # Select elements greater than a value.
  #
  # @overload above
  # @overload above
  # @param item [Object]
  #
  # source://hamster//lib/hamster/sorted_set.rb#760
  def above(item, &block); end

  # Return a new `SortedSet` with `item` added. If `item` is already in the set,
  # return `self`.
  #
  # @example
  #   Hamster::SortedSet["Dog", "Lion"].add("Elephant")
  #   # => Hamster::SortedSet["Dog", "Elephant", "Lion"]
  # @param item [Object] The object to add
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#128
  def add(item); end

  # If `item` is not a member of this `SortedSet`, return a new `SortedSet` with
  # `item` added. Otherwise, return `false`.
  #
  # @example
  #   Hamster::SortedSet["Dog", "Lion"].add?("Elephant")
  #   # => Hamster::SortedSet["Dog", "Elephant", "Lion"]
  #   Hamster::SortedSet["Dog", "Lion"].add?("Lion")
  #   # => false
  # @param item [Object] The object to add
  # @return [SortedSet, false]
  #
  # source://hamster//lib/hamster/sorted_set.rb#148
  def add?(item); end

  # Retrieve the item at `index`. If there is none (either the provided index
  # is too high or too low), return `nil`.
  #
  # @example
  #   s = Hamster::SortedSet["A", "B", "C", "D", "E", "F"]
  #   s.at(2)   # => "C"
  #   s.at(-2)  # => "E"
  #   s.at(6)   # => nil
  # @param index [Integer] The index to retrieve
  # @return [Object]
  #
  # source://hamster//lib/hamster/sorted_set.rb#212
  def at(index); end

  # Select elements less than a value.
  #
  # @overload below
  # @overload below
  # @param item [Object]
  #
  # source://hamster//lib/hamster/sorted_set.rb#791
  def below(item, &block); end

  # Select elements between two values.
  #
  # @overload between
  # @overload between
  # @param from [Object]
  # @param to [Object]
  #
  # source://hamster//lib/hamster/sorted_set.rb#891
  def between(from, to, &block); end

  # source://hamster//lib/hamster/sorted_set.rb#735
  def classify(&block); end

  # Return an empty `SortedSet` instance, of the same class as this one. Useful if you
  # have multiple subclasses of `SortedSet` and want to treat them polymorphically.
  #
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#913
  def clear; end

  # Invoke the given block once for each item in the set, and return a new
  # `SortedSet` containing the values returned by the block. If no block is
  # given, returns an `Enumerator`.
  #
  # @example
  #   Hamster::SortedSet[1, 2, 3].map { |e| -(e * e) }
  #   # => Hamster::SortedSet[-9, -4, -1]
  # @return [SortedSet, Enumerator]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/sorted_set.rb#453
  def collect; end

  # Return a new `SortedSet` with `item` removed. If `item` is not a member of the set,
  # return `self`.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C"].delete("B")
  #   # => Hamster::SortedSet["A", "C"]
  # @param item [Object] The object to remove
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#161
  def delete(item); end

  # If `item` is a member of this `SortedSet`, return a new `SortedSet` with
  # `item` removed. Otherwise, return `false`.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C"].delete?("B")
  #   # => Hamster::SortedSet["A", "C"]
  #   Hamster::SortedSet["A", "B", "C"].delete?("Z")
  #   # => false
  # @param item [Object] The object to remove
  # @return [SortedSet, false]
  #
  # source://hamster//lib/hamster/sorted_set.rb#184
  def delete?(item); end

  # Return a new `SortedSet` with the item at `index` removed. If the given `index`
  # does not exist (if it is too high or too low), return `self`.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C", "D"].delete_at(2)
  #   # => Hamster::SortedSet["A", "B", "D"]
  # @param index [Integer] The index to remove
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#197
  def delete_at(index); end

  # Return a new `SortedSet` with all the items in `other` removed. `other` can be
  # any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] - Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[1]
  # @param other [Enumerable] The collection to subtract from this set
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#637
  def difference(other); end

  # Return `true` if this set and `other` do not share any items.
  #
  # @example
  #   Hamster::SortedSet[1, 2].disjoint?(Hamster::SortedSet[3, 4])  # => true
  # @param other [Enumerable]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#714
  def disjoint?(other); end

  # Drop the first `n` elements and return the rest in a new `SortedSet`.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C", "D", "E", "F"].drop(2)
  #   # => Hamster::SortedSet["C", "D", "E", "F"]
  # @param n [Integer] The number of elements to remove
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#542
  def drop(n); end

  # Drop elements up to, but not including, the first element for which the
  # block returns `nil` or `false`. Gather the remaining elements into a new
  # `SortedSet`. If no block is given, an `Enumerator` is returned instead.
  #
  # @example
  #   Hamster::SortedSet[2, 4, 6, 7, 8, 9].drop_while { |e| e.even? }
  #   # => Hamster::SortedSet[7, 8, 9]
  # @return [SortedSet, Enumerator]
  # @yield [item]
  #
  # source://hamster//lib/hamster/sorted_set.rb#568
  def drop_while; end

  # Call the given block once for each item in the set, passing each
  # item from first to last successively to the block. If no block is
  # provided, returns an `Enumerator`.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C"].each { |e| puts "Element: #{e}" }
  #
  #   Element: A
  #   Element: B
  #   Element: C
  #   # => Hamster::SortedSet["A", "B", "C"]
  # @return [self, Enumerator]
  # @yield [item]
  #
  # source://hamster//lib/hamster/sorted_set.rb#357
  def each(&block); end

  # Return `true` if this `SortedSet` contains no items.
  #
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#104
  def empty?; end

  # Return true if `other` has the same type and contents as this `SortedSet`.
  #
  # @param other [Object] The object to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#925
  def eql?(other); end

  # Return a new `SortedSet` with all the items which are members of this
  # set or of `other`, but not both. `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] ^ Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[1, 3]
  # @param other [Enumerable] The collection to take the exclusive disjunction of
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#652
  def exclusion(other); end

  # Retrieve the value at `index` with optional default.
  #
  # @overload fetch
  # @overload fetch
  # @overload fetch
  # @return [Object]
  #
  # source://hamster//lib/hamster/sorted_set.rb#257
  def fetch(index, default = T.unsafe(nil)); end

  # Return a new `SortedSet` containing all elements for which the given block returns
  # true.
  #
  # @example
  #   Hamster::SortedSet["Bird", "Cow", "Elephant"].select { |e| e.size >= 4 }
  #   # => Hamster::SortedSet["Bird", "Elephant"]
  # @return [SortedSet]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/sorted_set.rb#435
  def find_all; end

  # Find the index of a given object or an element that satisfies the given
  # block.
  #
  # @overload find_index
  # @overload find_index
  # @return [Integer] The index of the object, or `nil` if not found.
  #
  # source://hamster//lib/hamster/sorted_set.rb#510
  def find_index(obj = T.unsafe(nil), &block); end

  # Return the "lowest" element in this set, as determined by its sort order.
  #
  # @return [Object]
  #
  # source://hamster//lib/hamster/sorted_set.rb#397
  def first; end

  # Select elements greater than or equal to a value.
  #
  # @overload from
  # @overload from
  # @param item [Object]
  #
  # source://hamster//lib/hamster/sorted_set.rb#823
  def from(item, &block); end

  # source://hamster//lib/hamster/sorted_set.rb#734
  def group(&block); end

  # See `Object#hash`.
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/sorted_set.rb#939
  def hash; end

  # Return `true` if the given item is present in this `SortedSet`. More precisely,
  # return `true` if an object which compares as "equal" using this set's
  # comparator is present.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C"].include?("B")  # => true
  # @param item [Object] The object to check for
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#464
  def include?(item); end

  # Find the index of a given object or an element that satisfies the given
  # block.
  #
  # @overload find_index
  # @overload find_index
  # @return [Integer] The index of the object, or `nil` if not found.
  #
  # source://hamster//lib/hamster/sorted_set.rb#532
  def index(obj = T.unsafe(nil), &block); end

  # Return `true` if this set and `other` have at least one item in common.
  #
  # @example
  #   Hamster::SortedSet[1, 2].intersect?(Hamster::SortedSet[2, 3])  # => true
  # @param other [Enumerable]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#730
  def intersect?(other); end

  # Return a new `SortedSet` which contains all the items which are members of both
  # this set and `other`. `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] & Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[2]
  # @param other [Enumerable] The collection to intersect with
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#623
  def intersection(other); end

  # Return a new `SortedSet` containing all elements for which the given block returns
  # true.
  #
  # @example
  #   Hamster::SortedSet["Bird", "Cow", "Elephant"].select { |e| e.size >= 4 }
  #   # => Hamster::SortedSet["Bird", "Elephant"]
  # @return [SortedSet]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/sorted_set.rb#436
  def keep_if; end

  # Return the "highest" element in this set, as determined by its sort order.
  #
  # @return [Object]
  #
  # source://hamster//lib/hamster/sorted_set.rb#416
  def last; end

  # Return the number of items in this `SortedSet`.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C"].size  # => 3
  # @return [Integer]
  #
  # source://hamster//lib/hamster/sorted_set.rb#117
  def length; end

  # Invoke the given block once for each item in the set, and return a new
  # `SortedSet` containing the values returned by the block. If no block is
  # given, returns an `Enumerator`.
  #
  # @example
  #   Hamster::SortedSet[1, 2, 3].map { |e| -(e * e) }
  #   # => Hamster::SortedSet[-9, -4, -1]
  # @return [SortedSet, Enumerator]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/sorted_set.rb#448
  def map; end

  # @private
  # @return [::Array]
  #
  # source://hamster//lib/hamster/sorted_set.rb#945
  def marshal_dump; end

  # @private
  #
  # source://hamster//lib/hamster/sorted_set.rb#954
  def marshal_load(array); end

  # Return the "highest" element in this set, as determined by its sort order.
  # Or, if a block is provided, use the block as a comparator to find the
  # "highest" element. (See `Enumerable#max`.)
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C"].max  # => "C"
  # @return [Object]
  # @yield [a, b] Any number of times with different pairs of elements.
  #
  # source://hamster//lib/hamster/sorted_set.rb#410
  def max; end

  # Return `true` if the given item is present in this `SortedSet`. More precisely,
  # return `true` if an object which compares as "equal" using this set's
  # comparator is present.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C"].include?("B")  # => true
  # @param item [Object] The object to check for
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#467
  def member?(item); end

  # Return a new `SortedSet` which contains all the members of both this set and `other`.
  # `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] | Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[1, 2, 3]
  # @param other [Enumerable] The collection to merge with
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#612
  def merge(other); end

  # Return the "lowest" element in this set, as determined by its sort order.
  # Or, if a block is provided, use the block as a comparator to find the
  # "lowest" element. (See `Enumerable#min`.)
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C"].min  # => "A"
  # @return [Object]
  # @yield [a, b] Any number of times with different pairs of elements.
  #
  # source://hamster//lib/hamster/sorted_set.rb#391
  def min; end

  # Returns `true` if `other` contains all the items in this set, plus at least
  # one item which is not in this set.
  #
  # @example
  #   Hamster::SortedSet[2, 3].proper_subset?(Hamster::SortedSet[1, 2, 3])     # => true
  #   Hamster::SortedSet[1, 2, 3].proper_subset?(Hamster::SortedSet[1, 2, 3])  # => false
  # @param other [Enumerable]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#689
  def proper_subset?(other); end

  # Returns `true` if this set contains all the items in `other`, plus at least
  # one item which is not in `other`.
  #
  # @example
  #   Hamster::SortedSet[1, 2, 3].proper_superset?(Hamster::SortedSet[2, 3])     # => true
  #   Hamster::SortedSet[1, 2, 3].proper_superset?(Hamster::SortedSet[1, 2, 3])  # => false
  # @param other [Enumerable]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#703
  def proper_superset?(other); end

  # Call the given block once for each item in the set, passing each
  # item starting from the last, and counting back to the first, successively to
  # the block.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C"].reverse_each { |e| puts "Element: #{e}" }
  #
  #   Element: C
  #   Element: B
  #   Element: A
  #   # => Hamster::SortedSet["A", "B", "C"]
  # @return [self]
  #
  # source://hamster//lib/hamster/sorted_set.rb#376
  def reverse_each(&block); end

  # Return a randomly chosen item from this set. If the set is empty, return `nil`.
  #
  # @example
  #   Hamster::SortedSet[1, 2, 3, 4, 5].sample  # => 2
  # @return [Object]
  #
  # source://hamster//lib/hamster/sorted_set.rb#905
  def sample; end

  # Return a new `SortedSet` containing all elements for which the given block returns
  # true.
  #
  # @example
  #   Hamster::SortedSet["Bird", "Cow", "Elephant"].select { |e| e.size >= 4 }
  #   # => Hamster::SortedSet["Bird", "Elephant"]
  # @return [SortedSet]
  # @yield [item] Once for each item.
  #
  # source://hamster//lib/hamster/sorted_set.rb#429
  def select; end

  # Return the number of items in this `SortedSet`.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C"].size  # => 3
  # @return [Integer]
  #
  # source://hamster//lib/hamster/sorted_set.rb#114
  def size; end

  # Return specific objects from the `Vector`. All overloads return `nil` if
  # the starting index is out of range.
  #
  # @overload set.slice
  # @overload set.slice
  # @overload set.slice
  #
  # source://hamster//lib/hamster/sorted_set.rb#309
  def slice(arg, length = T.unsafe(nil)); end

  # Return a new `SortedSet` with the same items, but a sort order determined
  # by the given block.
  #
  # @example
  #   Hamster::SortedSet["Bird", "Cow", "Elephant"].sort { |a, b| a.size <=> b.size }
  #   # => Hamster::SortedSet["Cow", "Bird", "Elephant"]
  #   Hamster::SortedSet["Bird", "Cow", "Elephant"].sort_by { |e| e.size }
  #   # => Hamster::SortedSet["Cow", "Bird", "Elephant"]
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#479
  def sort(&block); end

  # Return a new `SortedSet` with the same items, but a sort order determined
  # by the given block.
  #
  # @example
  #   Hamster::SortedSet["Bird", "Cow", "Elephant"].sort { |a, b| a.size <=> b.size }
  #   # => Hamster::SortedSet["Cow", "Bird", "Elephant"]
  #   Hamster::SortedSet["Bird", "Cow", "Elephant"].sort_by { |e| e.size }
  #   # => Hamster::SortedSet["Cow", "Bird", "Elephant"]
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#486
  def sort_by(&block); end

  # Return `true` if all items in this set are also in `other`.
  #
  # @example
  #   Hamster::SortedSet[2, 3].subset?(Hamster::SortedSet[1, 2, 3])  # => true
  # @param other [Enumerable]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#664
  def subset?(other); end

  # Return a new `SortedSet` with all the items in `other` removed. `other` can be
  # any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] - Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[1]
  # @param other [Enumerable] The collection to subtract from this set
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#640
  def subtract(other); end

  # Return `true` if all items in `other` are also in this set.
  #
  # @example
  #   Hamster::SortedSet[1, 2, 3].superset?(Hamster::SortedSet[2, 3])  # => true
  # @param other [Enumerable]
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#676
  def superset?(other); end

  # Return only the first `n` elements in a new `SortedSet`.
  #
  # @example
  #   Hamster::SortedSet["A", "B", "C", "D", "E", "F"].take(4)
  #   # => Hamster::SortedSet["A", "B", "C", "D"]
  # @param n [Integer] The number of elements to retain
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#554
  def take(n); end

  # Gather elements up to, but not including, the first element for which the
  # block returns `nil` or `false`, and return them in a new `SortedSet`. If no block
  # is given, an `Enumerator` is returned instead.
  #
  # @example
  #   Hamster::SortedSet[2, 4, 6, 7, 8, 9].take_while { |e| e.even? }
  #   # => Hamster::SortedSet[2, 4, 6]
  # @return [SortedSet, Enumerator]
  # @yield [item]
  #
  # source://hamster//lib/hamster/sorted_set.rb#588
  def take_while; end

  # Return a new `SortedSet` which contains all the members of both this set and `other`.
  # `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] | Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[1, 2, 3]
  # @param other [Enumerable] The collection to merge with
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#607
  def union(other); end

  # Select elements less than or equal to a value.
  #
  # @overload up_to
  # @overload up_to
  # @param item [Object]
  #
  # source://hamster//lib/hamster/sorted_set.rb#857
  def up_to(item, &block); end

  # Return a new `SortedSet` with only the elements at the given `indices`.
  # If any of the `indices` do not exist, they will be skipped.
  #
  # @example
  #   s = Hamster::SortedSet["A", "B", "C", "D", "E", "F"]
  #   s.values_at(2, 4, 5)   # => Hamster::SortedSet["C", "E", "F"]
  # @param indices [Array] The indices to retrieve and gather into a new `SortedSet`
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#338
  def values_at(*indices); end

  # Return a new `SortedSet` which contains all the members of both this set and `other`.
  # `other` can be any `Enumerable` object.
  #
  # @example
  #   Hamster::SortedSet[1, 2] | Hamster::SortedSet[2, 3]
  #   # => Hamster::SortedSet[1, 2, 3]
  # @param other [Enumerable] The collection to merge with
  # @return [SortedSet]
  #
  # source://hamster//lib/hamster/sorted_set.rb#610
  def |(other); end

  private

  # Return a new `SortedSet` which is derived from this one, using a modified
  # {AVLNode}.  The new `SortedSet` will retain the existing comparator, if
  # there is one.
  #
  # source://hamster//lib/hamster/sorted_set.rb#976
  def derive_new_sorted_set(node); end

  # source://hamster//lib/hamster/sorted_set.rb#960
  def subsequence(from, length); end

  class << self
    # Create a new `SortedSet` populated with the given items. This method does not
    # accept a comparator block.
    #
    # @return [SortedSet]
    #
    # source://hamster//lib/hamster/sorted_set.rb#61
    def [](*items); end

    # "Raw" allocation of a new `SortedSet`. Used internally to create a new
    # instance quickly after obtaining a modified binary tree.
    #
    # @private
    # @return [Set]
    #
    # source://hamster//lib/hamster/sorted_set.rb#78
    def alloc(node); end

    # Return an empty `SortedSet`. If used on a subclass, returns an empty instance
    # of that class.
    #
    # @return [SortedSet]
    #
    # source://hamster//lib/hamster/sorted_set.rb#69
    def empty; end
  end
end

# @private
#
# source://hamster//lib/hamster/sorted_set.rb#987
class Hamster::SortedSet::AVLNode
  # @return [AVLNode] a new instance of AVLNode
  #
  # source://hamster//lib/hamster/sorted_set.rb#1004
  def initialize(item, comparator, left, right); end

  # source://hamster//lib/hamster/sorted_set.rb#1261
  def at(index); end

  # source://hamster//lib/hamster/sorted_set.rb#1279
  def balance; end

  # source://hamster//lib/hamster/sorted_set.rb#1166
  def between(from, to); end

  # source://hamster//lib/hamster/sorted_set.rb#1084
  def bulk_delete(items); end

  # source://hamster//lib/hamster/sorted_set.rb#1042
  def bulk_insert(items); end

  # source://hamster//lib/hamster/sorted_set.rb#1023
  def clear; end

  # source://hamster//lib/hamster/sorted_set.rb#1059
  def delete(item); end

  # source://hamster//lib/hamster/sorted_set.rb#1027
  def derive(item, left, right); end

  # source://hamster//lib/hamster/sorted_set.rb#1350
  def direction(item); end

  # source://hamster//lib/hamster/sorted_set.rb#1224
  def drop(n); end

  # @yield [@item]
  #
  # source://hamster//lib/hamster/sorted_set.rb#1212
  def each(&block); end

  # source://hamster//lib/hamster/sorted_set.rb#1200
  def each_between(from, to, &block); end

  # source://hamster//lib/hamster/sorted_set.rb#1189
  def each_greater(item, inclusive, &block); end

  # source://hamster//lib/hamster/sorted_set.rb#1178
  def each_less(item, inclusive, &block); end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#1019
  def empty?; end

  # source://hamster//lib/hamster/sorted_set.rb#1130
  def finish_removal(keep_item, left, right); end

  # source://hamster//lib/hamster/sorted_set.rb#1011
  def from_items(items); end

  # Returns the value of attribute height.
  #
  # source://hamster//lib/hamster/sorted_set.rb#1009
  def height; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#1250
  def include?(item); end

  # source://hamster//lib/hamster/sorted_set.rb#1031
  def insert(item); end

  # Returns the value of attribute item.
  #
  # source://hamster//lib/hamster/sorted_set.rb#1009
  def item; end

  # source://hamster//lib/hamster/sorted_set.rb#1110
  def keep_only(items); end

  # Returns the value of attribute left.
  #
  # source://hamster//lib/hamster/sorted_set.rb#1009
  def left; end

  # source://hamster//lib/hamster/sorted_set.rb#1271
  def max; end

  # source://hamster//lib/hamster/sorted_set.rb#1275
  def min; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#1015
  def natural_order?; end

  # source://hamster//lib/hamster/sorted_set.rb#1297
  def partition(items); end

  # source://hamster//lib/hamster/sorted_set.rb#1148
  def prefix(item, inclusive); end

  # source://hamster//lib/hamster/sorted_set.rb#1310
  def rebalance(left, right); end

  # source://hamster//lib/hamster/sorted_set.rb#1318
  def rebalance_left(left, right); end

  # source://hamster//lib/hamster/sorted_set.rb#1334
  def rebalance_right(left, right); end

  # @yield [@item]
  #
  # source://hamster//lib/hamster/sorted_set.rb#1218
  def reverse_each(&block); end

  # Returns the value of attribute right.
  #
  # source://hamster//lib/hamster/sorted_set.rb#1009
  def right; end

  # Returns the value of attribute size.
  #
  # source://hamster//lib/hamster/sorted_set.rb#1009
  def size; end

  # source://hamster//lib/hamster/sorted_set.rb#1283
  def slice(from, length); end

  # source://hamster//lib/hamster/sorted_set.rb#1157
  def suffix(item, inclusive); end

  # source://hamster//lib/hamster/sorted_set.rb#1238
  def take(n); end

  class << self
    # items must be sorted
    #
    # source://hamster//lib/hamster/sorted_set.rb#988
    def from_items(items, comparator, from = T.unsafe(nil), to = T.unsafe(nil)); end
  end
end

# @private
#
# source://hamster//lib/hamster/sorted_set.rb#1355
class Hamster::SortedSet::AVLNode::Empty
  # @return [Empty] a new instance of Empty
  #
  # source://hamster//lib/hamster/sorted_set.rb#1356
  def initialize(comparator); end

  # source://hamster//lib/hamster/sorted_set.rb#1366
  def at(index); end

  # source://hamster//lib/hamster/sorted_set.rb#1380
  def between(from, to); end

  # source://hamster//lib/hamster/sorted_set.rb#1374
  def bulk_delete(items); end

  # source://hamster//lib/hamster/sorted_set.rb#1370
  def bulk_insert(items); end

  # source://hamster//lib/hamster/sorted_set.rb#1376
  def delete(item); end

  # source://hamster//lib/hamster/sorted_set.rb#1384
  def drop(n); end

  # source://hamster//lib/hamster/sorted_set.rb#1364
  def each; end

  # source://hamster//lib/hamster/sorted_set.rb#1383
  def each_between(item, inclusive); end

  # source://hamster//lib/hamster/sorted_set.rb#1381
  def each_greater(item, inclusive); end

  # source://hamster//lib/hamster/sorted_set.rb#1382
  def each_less(item, inclusive); end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#1386
  def empty?; end

  # source://hamster//lib/hamster/sorted_set.rb#1360
  def height; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#1377
  def include?(item); end

  # source://hamster//lib/hamster/sorted_set.rb#1367
  def insert(item); end

  # source://hamster//lib/hamster/sorted_set.rb#1375
  def keep_only(items); end

  # source://hamster//lib/hamster/sorted_set.rb#1358
  def left; end

  # source://hamster//lib/hamster/sorted_set.rb#1363
  def max; end

  # source://hamster//lib/hamster/sorted_set.rb#1362
  def min; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#1357
  def natural_order?; end

  # source://hamster//lib/hamster/sorted_set.rb#1378
  def prefix(item, inclusive); end

  # source://hamster//lib/hamster/sorted_set.rb#1365
  def reverse_each; end

  # source://hamster//lib/hamster/sorted_set.rb#1359
  def right; end

  # source://hamster//lib/hamster/sorted_set.rb#1361
  def size; end

  # source://hamster//lib/hamster/sorted_set.rb#1387
  def slice(from, length); end

  # source://hamster//lib/hamster/sorted_set.rb#1379
  def suffix(item, inclusive); end

  # source://hamster//lib/hamster/sorted_set.rb#1385
  def take(n); end
end

# AVL node which does not use a comparator function; it keeps items sorted
#   in their natural order
#
# @private
#
# source://hamster//lib/hamster/sorted_set.rb#1394
class Hamster::SortedSet::PlainAVLNode < ::Hamster::SortedSet::AVLNode
  # @return [PlainAVLNode] a new instance of PlainAVLNode
  #
  # source://hamster//lib/hamster/sorted_set.rb#1409
  def initialize(item, left, right); end

  # source://hamster//lib/hamster/sorted_set.rb#1424
  def clear; end

  # source://hamster//lib/hamster/sorted_set.rb#1428
  def derive(item, left, right); end

  # source://hamster//lib/hamster/sorted_set.rb#1432
  def direction(item); end

  # source://hamster//lib/hamster/sorted_set.rb#1416
  def from_items(items); end

  # Returns the value of attribute height.
  #
  # source://hamster//lib/hamster/sorted_set.rb#1414
  def height; end

  # Returns the value of attribute item.
  #
  # source://hamster//lib/hamster/sorted_set.rb#1414
  def item; end

  # Returns the value of attribute left.
  #
  # source://hamster//lib/hamster/sorted_set.rb#1414
  def left; end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#1420
  def natural_order?; end

  # Returns the value of attribute right.
  #
  # source://hamster//lib/hamster/sorted_set.rb#1414
  def right; end

  # Returns the value of attribute size.
  #
  # source://hamster//lib/hamster/sorted_set.rb#1414
  def size; end

  class << self
    # items must be sorted
    #
    # source://hamster//lib/hamster/sorted_set.rb#1395
    def from_items(items, from = T.unsafe(nil), to = T.unsafe(nil)); end
  end
end

# @private
#
# source://hamster//lib/hamster/sorted_set.rb#1437
class Hamster::SortedSet::PlainAVLNode::Empty < ::Hamster::SortedSet::AVLNode::Empty
  # @return [Empty] a new instance of Empty
  #
  # source://hamster//lib/hamster/sorted_set.rb#1438
  def initialize; end

  # source://hamster//lib/hamster/sorted_set.rb#1443
  def bulk_insert(items); end

  # source://hamster//lib/hamster/sorted_set.rb#1440
  def insert(item); end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/sorted_set.rb#1439
  def natural_order?; end
end

# source://hamster//lib/hamster/sorted_set.rb#1449
Hamster::SortedSet::PlainAVLNode::EmptyNode = T.let(T.unsafe(nil), Hamster::SortedSet::PlainAVLNode::Empty)

# This class can divide a list up into 2 `List`s, one for the prefix of
# elements for which the block returns true, and another for all the elements
# after that. It guarantees that the block will only be called ONCE for each
# item
#
# @private
#
# source://hamster//lib/hamster/list.rb#1484
class Hamster::Splitter
  # @return [Splitter] a new instance of Splitter
  #
  # source://hamster//lib/hamster/list.rb#1486
  def initialize(list, block); end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/list.rb#1503
  def done?; end

  # Returns the value of attribute left.
  #
  # source://hamster//lib/hamster/list.rb#1485
  def left; end

  # source://hamster//lib/hamster/list.rb#1490
  def next_item; end

  # Returns the value of attribute right.
  #
  # source://hamster//lib/hamster/list.rb#1485
  def right; end
end

# @private
#
# source://hamster//lib/hamster/list.rb#1508
class Hamster::Splitter::Left < ::Hamster::Realizable
  # @return [Left] a new instance of Left
  #
  # source://hamster//lib/hamster/list.rb#1509
  def initialize(splitter, buffer, mutex); end

  # source://hamster//lib/hamster/list.rb#1514
  def realize; end
end

# @private
#
# source://hamster//lib/hamster/list.rb#1538
class Hamster::Splitter::Right < ::Hamster::Realizable
  # @return [Right] a new instance of Right
  #
  # source://hamster//lib/hamster/list.rb#1539
  def initialize(splitter, mutex); end

  # source://hamster//lib/hamster/list.rb#1544
  def realize; end
end

# @private
#
# source://hamster//lib/hamster/trie.rb#3
class Hamster::Trie
  # @return [Trie] a new instance of Trie
  #
  # source://hamster//lib/hamster/trie.rb#13
  def initialize(significant_bits, size = T.unsafe(nil), entries = T.unsafe(nil), children = T.unsafe(nil)); end

  # Returns <tt>true</tt> if . <tt>eql?</tt> is synonymous with <tt>==</tt>
  #
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/trie.rb#280
  def ==(other); end

  # source://hamster//lib/hamster/trie.rb#252
  def at(index); end

  # Delete multiple elements from a Trie.  This is more efficient than
  # several calls to `#delete`.
  #
  # @param keys [Enumerable] The keys to delete
  # @return [Trie]
  #
  # source://hamster//lib/hamster/trie.rb#204
  def bulk_delete(keys); end

  # Put multiple elements into a Trie.  This is more efficient than several
  # calls to `#put`.
  #
  # @param key_value_pairs Enumerable of pairs (`[key, value]`)
  # @return [Trie] A copy of `self` after associated the given keys and
  #   values (or `self` if no modifications where needed).
  #
  # source://hamster//lib/hamster/trie.rb#113
  def bulk_put(key_value_pairs); end

  # Returns a copy of <tt>self</tt> with the given key (and associated value) deleted. If not found, returns <tt>self</tt>.
  #
  # source://hamster//lib/hamster/trie.rb#195
  def delete(key); end

  # Calls <tt>block</tt> once for each entry in the trie, passing the key-value pair as parameters.
  #
  # source://hamster//lib/hamster/trie.rb#31
  def each(&block); end

  # Returns <tt>true</tt> if the trie contains no key-value pairs.
  #
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/trie.rb#21
  def empty?; end

  # Returns <tt>true</tt> if . <tt>eql?</tt> is synonymous with <tt>==</tt>
  #
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/trie.rb#272
  def eql?(other); end

  # Retrieves the entry corresponding to the given key. If not found, returns <tt>nil</tt>.
  #
  # source://hamster//lib/hamster/trie.rb#183
  def get(key); end

  # @return [Boolean]
  #
  # source://hamster//lib/hamster/trie.rb#247
  def include?(key, value); end

  # Returns <tt>true</tt> if the given key is present in the trie.
  #
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/trie.rb#26
  def key?(key); end

  # @return [Trie] A copy of `self` with the given value associated with the
  #   key (or `self` if no modification was needed because an identical
  #   key-value pair wes already stored
  #
  # source://hamster//lib/hamster/trie.rb#69
  def put(key, value); end

  # Returns <tt>self</tt> after overwriting the element associated with the specified key.
  #
  # source://hamster//lib/hamster/trie.rb#158
  def put!(key, value); end

  # source://hamster//lib/hamster/trie.rb#55
  def reduce(memo); end

  # source://hamster//lib/hamster/trie.rb#47
  def reverse_each(&block); end

  # source://hamster//lib/hamster/trie.rb#60
  def select; end

  # Returns the number of key-value pairs in the trie.
  #
  # source://hamster//lib/hamster/trie.rb#11
  def size; end

  protected

  # Returns a replacement instance after removing the specified entry. If empty, returns <tt>nil</tt>
  #
  # @yield []
  #
  # source://hamster//lib/hamster/trie.rb#308
  def delete_at(index = T.unsafe(nil)); end

  # Returns a replacement instance after removing the specified key.
  # If not found, returns <tt>self</tt>.
  # If empty, returns <tt>nil</tt>.
  #
  # source://hamster//lib/hamster/trie.rb#287
  def find_and_delete(key); end

  private

  # source://hamster//lib/hamster/trie.rb#331
  def copy_size(copy); end

  # source://hamster//lib/hamster/trie.rb#327
  def index_for(key); end

  class << self
    # source://hamster//lib/hamster/trie.rb#4
    def [](pairs); end
  end
end

# @private
#
# source://hamster//lib/hamster/undefined.rb#3
module Hamster::Undefined; end

# Current released gem version. Note that master will often have the same
# value as a release gem but with different code.
#
# source://hamster//lib/hamster/version.rb#4
Hamster::VERSION = T.let(T.unsafe(nil), String)

# A `Vector` is an ordered, integer-indexed collection of objects. Like
# Ruby's `Array`, `Vector` indexing starts at zero and negative indexes count
# back from the end.
#
# `Vector` has a similar interface to `Array`. The main difference is methods
# that would destructively update an `Array` (such as {#insert} or
# {#delete_at}) instead return new `Vectors` and leave the existing one
# unchanged.
#
# ### Creating New Vectors
#
#     Hamster::Vector.new([:first, :second, :third])
#     Hamster::Vector[1, 2, 3, 4, 5]
#
# ### Retrieving Items from Vectors
#
#     vector = Hamster::Vector[1, 2, 3, 4, 5]
#
#     vector[0]      # => 1
#     vector[-1]     # => 5
#     vector[0,3]    # => Hamster::Vector[1, 2, 3]
#     vector[1..-1]  # => Hamster::Vector[2, 3, 4, 5]
#     vector.first   # => 1
#     vector.last    # => 5
#
# ### Creating Modified Vectors
#
#     vector.add(6)            # => Hamster::Vector[1, 2, 3, 4, 5, 6]
#     vector.insert(1, :a, :b) # => Hamster::Vector[1, :a, :b, 2, 3, 4, 5]
#     vector.delete_at(2)      # => Hamster::Vector[1, 2, 4, 5]
#     vector + [6, 7]          # => Hamster::Vector[1, 2, 3, 4, 5, 6, 7]
#
# source://hamster//lib/hamster/vector.rb#39
class Hamster::Vector
  include ::Hamster::Immutable
  include ::Hamster::Immutable::InstanceMethods
  include ::Enumerable
  include ::Hamster::Enumerable
  include ::Hamster::Associable
  extend ::Hamster::Immutable::ClassMethods

  # @return [Vector] a new instance of Vector
  #
  # source://hamster//lib/hamster/vector.rb#85
  def initialize(items = T.unsafe(nil)); end

  # Repetition. Return a new `Vector` built by concatenating `times` copies
  # of this one together.
  #
  # @example
  #   Hamster::Vector["A", "B"] * 3
  #   # => Hamster::Vector["A", "B", "A", "B", "A", "B"]
  # @param times [Integer] The number of times to repeat the elements in this vector
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#758
  def *(times); end

  # Return a new `Vector` built by concatenating this one with `other`. `other`
  # can be any object which is convertible to an `Array` using `#to_a`.
  #
  # @example
  #   Hamster::Vector["A", "B", "C"] + ["D", "E"]
  #   # => Hamster::Vector["A", "B", "C", "D", "E"]
  # @param other [Enumerable] The collection to concatenate onto this vector
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#611
  def +(other); end

  # Return a new `Vector` with `item` added after the last occupied position.
  #
  # @example
  #   Hamster::Vector[1, 2].add(99)  # => Hamster::Vector[1, 2, 99]
  # @param item [Object] The object to insert at the end of the vector
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#137
  def <<(item); end

  # Return specific objects from the `Vector`. All overloads return `nil` if
  # the starting index is out of range.
  #
  # @overload vector.slice
  # @overload vector.slice
  # @overload vector.slice
  #
  # source://hamster//lib/hamster/vector.rb#330
  def [](arg, length = T.unsafe(nil)); end

  # Return a new `Vector` with `item` added after the last occupied position.
  #
  # @example
  #   Hamster::Vector[1, 2].add(99)  # => Hamster::Vector[1, 2, 99]
  # @param item [Object] The object to insert at the end of the vector
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#134
  def add(item); end

  # Assumes all elements are nested, indexable collections, and searches through them,
  # comparing `obj` with the first element of each nested collection. Return the
  # first nested collection which matches, or `nil` if none is found.
  # Behaviour is undefined when elements do not meet assumptions (i.e. are
  # not indexable collections).
  #
  # @example
  #   v = Hamster::Vector[["A", 10], ["B", 20], ["C", 30]]
  #   v.assoc("B")  # => ["B", 20]
  # @param obj [Object] The object to search for
  # @return [Object]
  #
  # source://hamster//lib/hamster/vector.rb#1243
  def assoc(obj); end

  # Retrieve the item at `index`. If there is none (either the provided index
  # is too high or too low), return `nil`.
  #
  # @example
  #   v = Hamster::Vector["A", "B", "C", "D"]
  #   v.get(2)   # => "C"
  #   v.get(-1)  # => "D"
  #   v.get(4)   # => nil
  # @param index [Integer] The index to retrieve
  # @return [Object]
  #
  # source://hamster//lib/hamster/vector.rb#219
  def at(index); end

  # Finds a value from this `Vector` which meets the condition defined by the
  # provided block, using a binary search. The vector must already be sorted
  # with respect to the block.  See Ruby's `Array#bsearch` for details,
  # behaviour is equivalent.
  #
  # @example
  #   v = Hamster::Vector[1, 3, 5, 7, 9, 11, 13]
  #   # Block returns true/false for exact element match:
  #   v.bsearch { |e| e > 4 }      # => 5
  #   # Block returns number to match an element in 4 <= e <= 7:
  #   v.bsearch { |e| 1 - e / 4 }  # => 7
  # @raise TypeError if the block returns a non-numeric, non-boolean, non-nil
  #   value.
  # @return [Object] The matched element, or `nil` if none found.
  # @yield Once for at most `log n` elements, where `n` is the size of the
  #   vector. The exact elements and ordering are undefined.
  # @yieldparam element [Object] element to be evaluated
  # @yieldreturn [Boolean] `true` if this element matches the criteria, `false` otherwise.
  # @yieldreturn [Integer] See `Array#bsearch` for details.
  #
  # source://hamster//lib/hamster/vector.rb#1137
  def bsearch; end

  # Return an empty `Vector` instance, of the same class as this one. Useful if you
  # have multiple subclasses of `Vector` and want to treat them polymorphically.
  #
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#1168
  def clear; end

  # Invoke the given block once for each item in the vector, and return a new
  # `Vector` containing the values returned by the block. If no block is
  # provided, return an enumerator.
  #
  # @example
  #   Hamster::Vector[3, 2, 1].map { |e| e * e }  # => Hamster::Vector[9, 4, 1]
  # @return [Vector, Enumerator]
  #
  # source://hamster//lib/hamster/vector.rb#493
  def collect; end

  # When invoked with a block, yields all combinations of length `n` of items
  # from the `Vector`, and then returns `self`. There is no guarantee about
  # which order the combinations will be yielded.
  #
  # If no block is given, an `Enumerator` is returned instead.
  #
  # @example
  #   v = Hamster::Vector[5, 6, 7, 8]
  #   v.combination(3) { |c| puts "Combination: #{c}" }
  #
  #   Combination: [5, 6, 7]
  #   Combination: [5, 6, 8]
  #   Combination: [5, 7, 8]
  #   Combination: [6, 7, 8]
  #   #=> Hamster::Vector[5, 6, 7, 8]
  # @return [self, Enumerator]
  #
  # source://hamster//lib/hamster/vector.rb#837
  def combination(n); end

  # Return a new `Vector` built by concatenating this one with `other`. `other`
  # can be any object which is convertible to an `Array` using `#to_a`.
  #
  # @example
  #   Hamster::Vector["A", "B", "C"] + ["D", "E"]
  #   # => Hamster::Vector["A", "B", "C", "D", "E"]
  # @param other [Enumerable] The collection to concatenate onto this vector
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#616
  def concat(other); end

  # Return a new `Vector` with all items which are equal to `obj` removed.
  # `#==` is used for checking equality.
  #
  # @example
  #   Hamster::Vector["C", "B", "A", "B"].delete("B")  # => Hamster::Vector["C", "A"]
  # @param obj [Object] The object to remove (every occurrence)
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#476
  def delete(obj); end

  # Return a new `Vector` with the element at `index` removed. If the given `index`
  # does not exist, return `self`.
  #
  # @example
  #   Hamster::Vector["A", "B", "C", "D"].delete_at(2)
  #   # => Hamster::Vector["A", "B", "D"]
  # @param index [Integer] The index to remove
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#372
  def delete_at(index); end

  # Drop the first `n` elements and return the rest in a new `Vector`.
  #
  # @example
  #   Hamster::Vector["A", "B", "C", "D", "E", "F"].drop(2)
  #   # => Hamster::Vector["C", "D", "E", "F"]
  # @param n [Integer] The number of elements to remove
  # @raise ArgumentError if `n` is negative.
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#701
  def drop(n); end

  # Drop elements up to, but not including, the first element for which the
  # block returns `nil` or `false`. Gather the remaining elements into a new
  # `Vector`. If no block is given, an `Enumerator` is returned instead.
  #
  # @example
  #   Hamster::Vector[1, 3, 5, 7, 6, 4, 2].drop_while { |e| e < 5 }
  #   # => Hamster::Vector[5, 7, 6, 4, 2]
  # @return [Vector, Enumerator]
  #
  # source://hamster//lib/hamster/vector.rb#730
  def drop_while; end

  # Call the given block once for each item in the vector, passing each
  # item from first to last successively to the block. If no block is given,
  # an `Enumerator` is returned instead.
  #
  # @example
  #   Hamster::Vector["A", "B", "C"].each { |e| puts "Element: #{e}" }
  #
  #   Element: A
  #   Element: B
  #   Element: C
  #   # => Hamster::Vector["A", "B", "C"]
  # @return [self, Enumerator]
  #
  # source://hamster//lib/hamster/vector.rb#429
  def each(&block); end

  # Return `true` if this `Vector` contains no items.
  #
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/vector.rb#103
  def empty?; end

  # Return true if `other` has the same type and contents as this `Vector`.
  #
  # @param other [Object] The collection to compare with
  # @return [Boolean]
  #
  # source://hamster//lib/hamster/vector.rb#1290
  def eql?(other); end

  # Retrieve the value at `index` with optional default.
  #
  # @overload fetch
  # @overload fetch
  # @overload fetch
  # @return [Object]
  #
  # source://hamster//lib/hamster/vector.rb#260
  def fetch(index, default = T.unsafe(nil)); end

  # Replace a range of indexes with the given object.
  #
  # @overload fill
  # @overload fill
  # @overload fill
  # @raise [IndexError] if index is out of negative range.
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#802
  def fill(object, index = T.unsafe(nil), length = T.unsafe(nil)); end

  # Return a new `Vector` containing all elements for which the given block returns
  # true.
  #
  # @example
  #   Hamster::Vector["Bird", "Cow", "Elephant"].select { |e| e.size >= 4 }
  #   # => Hamster::Vector["Bird", "Elephant"]
  # @return [Vector]
  # @yield [element] Once for each element.
  #
  # source://hamster//lib/hamster/vector.rb#465
  def find_all; end

  # Return the first item in the `Vector`. If the vector is empty, return `nil`.
  #
  # @example
  #   Hamster::Vector["A", "B", "C"].first  # => "A"
  # @return [Object]
  #
  # source://hamster//lib/hamster/vector.rb#113
  def first; end

  # Return a new `Vector` with the concatenated results of running the block once
  # for every element in this `Vector`.
  #
  # @example
  #   Hamster::Vector[1, 2, 3].flat_map { |x| [x, -x] }
  #   # => Hamster::Vector[1, -1, 2, -2, 3, -3]
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#503
  def flat_map; end

  # Return a new `Vector` with all nested vectors and arrays recursively "flattened
  # out". That is, their elements inserted into the new `Vector` in the place where
  # the nested array/vector originally was. If an optional `level` argument is
  # provided, the flattening will only be done recursively that number of times.
  # A `level` of 0 means not to flatten at all, 1 means to only flatten nested
  # arrays/vectors which are directly contained within this `Vector`.
  #
  # @example
  #   v = Hamster::Vector["A", Hamster::Vector["B", "C", Hamster::Vector["D"]]]
  #   v.flatten(1)
  #   # => Hamster::Vector["A", "B", "C", Hamster::Vector["D"]]
  #   v.flatten
  #   # => Hamster::Vector["A", "B", "C", "D"]
  # @param level [Integer] The depth to which flattening should be applied
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#590
  def flatten(level = T.unsafe(nil)); end

  # Retrieve the item at `index`. If there is none (either the provided index
  # is too high or too low), return `nil`.
  #
  # @example
  #   v = Hamster::Vector["A", "B", "C", "D"]
  #   v.get(2)   # => "C"
  #   v.get(-1)  # => "D"
  #   v.get(4)   # => nil
  # @param index [Integer] The index to retrieve
  # @return [Object]
  #
  # source://hamster//lib/hamster/vector.rb#213
  def get(index); end

  # See `Object#hash`.
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/vector.rb#1298
  def hash; end

  # Return a new `Vector` with the given values inserted before the element
  # at `index`. If `index` is greater than the current length, `nil` values
  # are added to pad the `Vector` to the required size.
  #
  # @example
  #   Hamster::Vector["A", "B", "C", "D"].insert(2, "X", "Y", "Z")
  #   # => Hamster::Vector["A", "B", "X", "Y", "Z", "C", "D"]
  #   Hamster::Vector[].insert(2, "X", "Y", "Z")
  #   # => Hamster::Vector[nil, nil, "X", "Y", "Z"]
  # @param index [Integer] The index where the new items should go
  # @param items [Array] The items to add
  # @raise [IndexError] if index exceeds negative range.
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#346
  def insert(index, *items); end

  # Return a new `Vector` containing all elements for which the given block returns
  # true.
  #
  # @example
  #   Hamster::Vector["Bird", "Cow", "Elephant"].select { |e| e.size >= 4 }
  #   # => Hamster::Vector["Bird", "Elephant"]
  # @return [Vector]
  # @yield [element] Once for each element.
  #
  # source://hamster//lib/hamster/vector.rb#466
  def keep_if; end

  # Return the last item in the `Vector`. If the vector is empty, return `nil`.
  #
  # @example
  #   Hamster::Vector["A", "B", "C"].last  # => "C"
  # @return [Object]
  #
  # source://hamster//lib/hamster/vector.rb#123
  def last; end

  # Return the number of items in this `Vector`
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/vector.rb#54
  def length; end

  # Invoke the given block once for each item in the vector, and return a new
  # `Vector` containing the values returned by the block. If no block is
  # provided, return an enumerator.
  #
  # @example
  #   Hamster::Vector[3, 2, 1].map { |e| e * e }  # => Hamster::Vector[9, 4, 1]
  # @return [Vector, Enumerator]
  #
  # source://hamster//lib/hamster/vector.rb#488
  def map; end

  # @private
  # @return [::Array]
  #
  # source://hamster//lib/hamster/vector.rb#1304
  def marshal_dump; end

  # @private
  #
  # source://hamster//lib/hamster/vector.rb#1309
  def marshal_load(array); end

  # Yields all permutations of length `n` of items from the `Vector`, and then
  # returns `self`. If no length `n` is specified, permutations of all elements
  # will be yielded.
  #
  # There is no guarantee about which order the permutations will be yielded in.
  #
  # If no block is given, an `Enumerator` is returned instead.
  #
  # @example
  #   v = Hamster::Vector[5, 6, 7]
  #   v.permutation(2) { |p| puts "Permutation: #{p}" }
  #
  #   Permutation: [5, 6]
  #   Permutation: [5, 7]
  #   Permutation: [6, 5]
  #   Permutation: [6, 7]
  #   Permutation: [7, 5]
  #   Permutation: [7, 6]
  #   # => Hamster::Vector[5, 6, 7]
  # @return [self, Enumerator]
  #
  # source://hamster//lib/hamster/vector.rb#940
  def permutation(n = T.unsafe(nil)); end

  # Return a new `Vector` with the last element removed. Return `self` if
  # empty.
  #
  # @example
  #   Hamster::Vector["A", "B", "C"].pop  # => Hamster::Vector["A", "B"]
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#387
  def pop; end

  # Cartesian product or multiplication.
  #
  # @overload product
  # @overload product
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#1038
  def product(*vectors); end

  # Return a new `Vector` with `item` added after the last occupied position.
  #
  # @example
  #   Hamster::Vector[1, 2].add(99)  # => Hamster::Vector[1, 2, 99]
  # @param item [Object] The object to insert at the end of the vector
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#138
  def push(item); end

  # Return a new `Vector` with a new value at the given `index`. If `index`
  # is greater than the length of the vector, the returned vector will be
  # padded with `nil`s to the correct size.
  #
  # @overload put
  # @overload put
  # @param index [Integer] The index to update. May be negative.
  # @raise [IndexError]
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#167
  def put(index, item = T.unsafe(nil)); end

  # Assumes all elements are nested, indexable collections, and searches through them,
  # comparing `obj` with the second element of each nested collection. Return
  # the first nested collection which matches, or `nil` if none is found.
  # Behaviour is undefined when elements do not meet assumptions (i.e. are
  # not indexable collections).
  #
  # @example
  #   v = Hamster::Vector[["A", 10], ["B", 20], ["C", 30]]
  #   v.rassoc(20)  # => ["B", 20]
  # @param obj [Object] The object to search for
  # @return [Object]
  #
  # source://hamster//lib/hamster/vector.rb#1263
  def rassoc(obj); end

  # When invoked with a block, yields all repeated combinations of length `n` of
  # items from the `Vector`, and then returns `self`. A "repeated combination" is
  # one in which any item from the `Vector` can appear consecutively any number of
  # times.
  #
  # There is no guarantee about which order the combinations will be yielded in.
  #
  # If no block is given, an `Enumerator` is returned instead.
  #
  # @example
  #   v = Hamster::Vector[5, 6, 7, 8]
  #   v.repeated_combination(2) { |c| puts "Combination: #{c}" }
  #
  #   Combination: [5, 5]
  #   Combination: [5, 6]
  #   Combination: [5, 7]
  #   Combination: [5, 8]
  #   Combination: [6, 6]
  #   Combination: [6, 7]
  #   Combination: [6, 8]
  #   Combination: [7, 7]
  #   Combination: [7, 8]
  #   Combination: [8, 8]
  #   # => Hamster::Vector[5, 6, 7, 8]
  # @return [self, Enumerator]
  #
  # source://hamster//lib/hamster/vector.rb#890
  def repeated_combination(n); end

  # When invoked with a block, yields all repeated permutations of length `n` of
  # items from the `Vector`, and then returns `self`. A "repeated permutation" is
  # one where any item from the `Vector` can appear any number of times, and in
  # any position (not just consecutively)
  #
  # If no length `n` is specified, permutations of all elements will be yielded.
  # There is no guarantee about which order the permutations will be yielded in.
  #
  # If no block is given, an `Enumerator` is returned instead.
  #
  # @example
  #   v = Hamster::Vector[5, 6, 7]
  #   v.repeated_permutation(2) { |p| puts "Permutation: #{p}" }
  #
  #   Permutation: [5, 5]
  #   Permutation: [5, 6]
  #   Permutation: [5, 7]
  #   Permutation: [6, 5]
  #   Permutation: [6, 6]
  #   Permutation: [6, 7]
  #   Permutation: [7, 5]
  #   Permutation: [7, 6]
  #   Permutation: [7, 7]
  #   # => Hamster::Vector[5, 6, 7]
  # @return [self, Enumerator]
  #
  # source://hamster//lib/hamster/vector.rb#995
  def repeated_permutation(n = T.unsafe(nil)); end

  # Return a new `Vector` with the same elements as this one, but in reverse order.
  #
  # @example
  #   Hamster::Vector["A", "B", "C"].reverse  # => Hamster::Vector["C", "B", "A"]
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#552
  def reverse; end

  # Call the given block once for each item in the vector, from last to
  # first.
  #
  # @example
  #   Hamster::Vector["A", "B", "C"].reverse_each { |e| puts "Element: #{e}" }
  #
  #   Element: C
  #   Element: B
  #   Element: A
  # @return [self]
  #
  # source://hamster//lib/hamster/vector.rb#446
  def reverse_each(&block); end

  # Find the index of an element, starting from the end of the vector.
  # Returns `nil` if no element is found.
  #
  # @overload rindex
  # @overload rindex
  # @return [Integer]
  #
  # source://hamster//lib/hamster/vector.rb#1216
  def rindex(obj = T.unsafe(nil)); end

  # Return a new `Vector` with the same elements, but rotated so that the one at
  # index `count` is the first element of the new vector. If `count` is positive,
  # the elements will be shifted left, and those shifted past the lowest position
  # will be moved to the end. If `count` is negative, the elements will be shifted
  # right, and those shifted past the last position will be moved to the beginning.
  #
  # @example
  #   v = Hamster::Vector["A", "B", "C", "D", "E", "F"]
  #   v.rotate(2)   # => Hamster::Vector["C", "D", "E", "F", "A", "B"]
  #   v.rotate(-1)  # => Hamster::Vector["F", "A", "B", "C", "D", "E"]
  # @param count [Integer] The number of positions to shift items by
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#569
  def rotate(count = T.unsafe(nil)); end

  # Return a randomly chosen item from this `Vector`. If the vector is empty, return `nil`.
  #
  # @example
  #   Hamster::Vector[1, 2, 3, 4, 5].sample  # => 2
  # @return [Object]
  #
  # source://hamster//lib/hamster/vector.rb#1178
  def sample; end

  # Return a new `Vector` containing all elements for which the given block returns
  # true.
  #
  # @example
  #   Hamster::Vector["Bird", "Cow", "Elephant"].select { |e| e.size >= 4 }
  #   # => Hamster::Vector["Bird", "Elephant"]
  # @return [Vector]
  # @yield [element] Once for each element.
  #
  # source://hamster//lib/hamster/vector.rb#461
  def select; end

  # Return a new `Vector` with a new value at the given `index`. If `index`
  # is greater than the length of the vector, the returned vector will be
  # padded with `nil`s to the correct size.
  #
  # @overload put
  # @overload put
  # @param index [Integer] The index to update. May be negative.
  # @raise [IndexError]
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#178
  def set(index, item = T.unsafe(nil)); end

  # Return a new `Vector` with the first element removed. If empty, return
  # `self`.
  #
  # @example
  #   Hamster::Vector["A", "B", "C"].shift  # => Hamster::Vector["B", "C"]
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#412
  def shift; end

  # Return a new `Vector` with the same elements as this one, but randomly permuted.
  #
  # @example
  #   Hamster::Vector[1, 2, 3, 4].shuffle  # => Hamster::Vector[4, 1, 3, 2]
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#515
  def shuffle; end

  # Return the number of items in this `Vector`
  #
  # @return [Integer]
  #
  # source://hamster//lib/hamster/vector.rb#53
  def size; end

  # Return specific objects from the `Vector`. All overloads return `nil` if
  # the starting index is out of range.
  #
  # @overload vector.slice
  # @overload vector.slice
  # @overload vector.slice
  #
  # source://hamster//lib/hamster/vector.rb#312
  def slice(arg, length = T.unsafe(nil)); end

  # Return a new `Vector` with the same items, but sorted.
  #
  # @overload sort
  # @overload sort
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#672
  def sort; end

  # Return a new `Vector` with the same items, but sorted. The sort order is
  # determined by mapping the items through the given block to obtain sort
  # keys, and then sorting the keys according to their natural sort order
  # (`#<=>`).
  #
  # @example
  #   Hamster::Vector["Elephant", "Dog", "Lion"].sort_by { |e| e.size }
  #   # => Hamster::Vector["Dog", "Lion", "Elephant"]
  # @return [Vector]
  # @yield [element] Once for each element.
  # @yieldreturn a sort key object for the yielded element.
  #
  # source://hamster//lib/hamster/vector.rb#688
  def sort_by; end

  # Return only the first `n` elements in a new `Vector`.
  #
  # @example
  #   Hamster::Vector["A", "B", "C", "D", "E", "F"].take(4)
  #   # => Hamster::Vector["A", "B", "C", "D"]
  # @param n [Integer] The number of elements to retain
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#716
  def take(n); end

  # Gather elements up to, but not including, the first element for which the
  # block returns `nil` or `false`, and return them in a new `Vector`. If no block
  # is given, an `Enumerator` is returned instead.
  #
  # @example
  #   Hamster::Vector[1, 3, 5, 7, 6, 4, 2].take_while { |e| e < 5 }
  #   # => Hamster::Vector[1, 3]
  # @return [Vector, Enumerator]
  #
  # source://hamster//lib/hamster/vector.rb#744
  def take_while; end

  # Return an `Array` with the same elements, in the same order. The returned
  # `Array` may or may not be frozen.
  #
  # @return [Array]
  #
  # source://hamster//lib/hamster/vector.rb#1275
  def to_a; end

  # Return an `Array` with the same elements, in the same order. The returned
  # `Array` may or may not be frozen.
  #
  # @return [Array]
  #
  # source://hamster//lib/hamster/vector.rb#1284
  def to_ary; end

  # Assume all elements are vectors or arrays and transpose the rows and columns.
  # In other words, take the first element of each nested vector/array and gather
  # them together into a new `Vector`. Do likewise for the second, third, and so on
  # down to the end of each nested vector/array. Gather all the resulting `Vectors`
  # into a new `Vector` and return it.
  #
  # This operation is closely related to {#zip}. The result is almost the same as
  # calling {#zip} on the first nested vector/array with the others supplied as
  # arguments.
  #
  # @example
  #   Hamster::Vector[["A", 10], ["B", 20], ["C", 30]].transpose
  #   # => Hamster::Vector[Hamster::Vector["A", "B", "C"], Hamster::Vector[10, 20, 30]]
  # @raise [IndexError] if elements are not of the same size.
  # @raise [TypeError] if an element can not be implicitly converted to an array (using `#to_ary`)
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#1098
  def transpose; end

  # Return a new `Vector` with no duplicate elements, as determined by `#hash` and
  # `#eql?`. For each group of equivalent elements, only the first will be retained.
  #
  # @example
  #   Hamster::Vector["A", "B", "C", "B"].uniq      # => Hamster::Vector["A", "B", "C"]
  #   Hamster::Vector["a", "A", "b"].uniq(&:upcase) # => Hamster::Vector["a", "b"]
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#527
  def uniq(&block); end

  # Return a new `Vector` with `object` inserted before the first element,
  # moving the other elements upwards.
  #
  # @example
  #   Hamster::Vector["A", "B"].unshift("Z")
  #   # => Hamster::Vector["Z", "A", "B"]
  # @param object [Object] The value to prepend
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#401
  def unshift(object); end

  # Return a new `Vector` with only the elements at the given `indices`, in the
  # order specified by `indices`. If any of the `indices` do not exist, `nil`s will
  # appear in their places.
  #
  # @example
  #   v = Hamster::Vector["A", "B", "C", "D", "E", "F"]
  #   v.values_at(2, 4, 5)   # => Hamster::Vector["C", "E", "F"]
  # @param indices [Array] The indices to retrieve and gather into a new `Vector`
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#1192
  def values_at(*indices); end

  # Combine two vectors by "zipping" them together. `others` should be arrays
  # and/or vectors. The corresponding elements from this `Vector` and each of
  # `others` (that is, the elements with the same indices) will be gathered
  # into arrays.
  #
  # If `others` contains fewer elements than this vector, `nil` will be used
  # for padding.
  #
  # @example
  #   v1 = Hamster::Vector["A", "B", "C"]
  #   v2 = Hamster::Vector[1, 2]
  #   v1.zip(v2)
  #   # => Hamster::Vector[["A", 1], ["B", 2], ["C", nil]]
  # @overload zip
  # @overload zip
  # @param others [Array] The arrays/vectors to zip together with this one
  # @return [Vector]
  #
  # source://hamster//lib/hamster/vector.rb#643
  def zip(*others); end

  private

  # source://hamster//lib/hamster/vector.rb#1395
  def flatten_node(node, bitshift, result); end

  # source://hamster//lib/hamster/vector.rb#1361
  def flatten_range(node, bitshift, from, to); end

  # source://hamster//lib/hamster/vector.rb#1414
  def flatten_suffix(node, bitshift, from, result); end

  # source://hamster//lib/hamster/vector.rb#1325
  def leaf_node_for(node, bitshift, index); end

  # source://hamster//lib/hamster/vector.rb#1471
  def replace_node_suffix(node, bitshift, from, suffix); end

  # @raise [IndexError]
  #
  # source://hamster//lib/hamster/vector.rb#1439
  def replace_suffix(from, suffix); end

  # source://hamster//lib/hamster/vector.rb#1320
  def reverse_traverse_depth_first(node, level, &block); end

  # source://hamster//lib/hamster/vector.rb#1407
  def subsequence(from, length); end

  # source://hamster//lib/hamster/vector.rb#1315
  def traverse_depth_first(node, level, &block); end

  # source://hamster//lib/hamster/vector.rb#1347
  def update_leaf_node(node, bitshift, index, item); end

  # source://hamster//lib/hamster/vector.rb#1333
  def update_root(index, item); end

  class << self
    # Create a new `Vector` populated with the given items.
    #
    # @return [Vector]
    #
    # source://hamster//lib/hamster/vector.rb#59
    def [](*items); end

    # "Raw" allocation of a new `Vector`. Used internally to create a new
    # instance quickly after building a modified trie.
    #
    # @private
    # @return [Vector]
    #
    # source://hamster//lib/hamster/vector.rb#76
    def alloc(root, size, levels); end

    # Return an empty `Vector`. If used on a subclass, returns an empty instance
    # of that class.
    #
    # @return [Vector]
    #
    # source://hamster//lib/hamster/vector.rb#67
    def empty; end
  end
end

# @private
#
# source://hamster//lib/hamster/vector.rb#49
Hamster::Vector::BITS_PER_LEVEL = T.let(T.unsafe(nil), Integer)

# @private
#
# source://hamster//lib/hamster/vector.rb#45
Hamster::Vector::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# @private
#
# source://hamster//lib/hamster/vector.rb#47
Hamster::Vector::INDEX_MASK = T.let(T.unsafe(nil), Integer)

# Monkey-patches to Ruby's built-in `IO` class.
#
# @see http://www.ruby-doc.org/core/IO.html
#
# source://hamster//lib/hamster/core_ext/io.rb#5
class IO
  include ::Enumerable
  include ::File::Constants

  # Return a lazy list of "records" read from this IO stream.
  # "Records" are delimited by `$/`, the global input record separator string.
  # By default, it is `"\n"`, a newline.
  #
  # @return [List]
  #
  # source://hamster//lib/hamster/core_ext/io.rb#11
  def to_list(sep = T.unsafe(nil)); end
end

class IO::Buffer
  include ::Comparable

  def initialize(*_arg0); end

  def &(_arg0); end
  def <=>(_arg0); end
  def ^(_arg0); end
  def and!(_arg0); end
  def clear(*_arg0); end
  def copy(*_arg0); end
  def each(*_arg0); end
  def each_byte(*_arg0); end
  def empty?; end
  def external?; end
  def free; end
  def get_string(*_arg0); end
  def get_value(_arg0, _arg1); end
  def get_values(_arg0, _arg1); end
  def hexdump(*_arg0); end
  def inspect; end
  def internal?; end
  def locked; end
  def locked?; end
  def mapped?; end
  def not!; end
  def null?; end
  def or!(_arg0); end
  def pread(*_arg0); end
  def private?; end
  def pwrite(*_arg0); end
  def read(*_arg0); end
  def readonly?; end
  def resize(_arg0); end
  def set_string(*_arg0); end
  def set_value(_arg0, _arg1, _arg2); end
  def set_values(_arg0, _arg1, _arg2); end
  def shared?; end
  def size; end
  def slice(*_arg0); end
  def to_s; end
  def transfer; end
  def valid?; end
  def values(*_arg0); end
  def write(*_arg0); end
  def xor!(_arg0); end
  def |(_arg0); end
  def ~; end

  private

  def initialize_copy(_arg0); end

  class << self
    def for(_arg0); end
    def map(*_arg0); end
    def size_of(_arg0); end
    def string(_arg0); end
  end
end

class IO::Buffer::AccessError < ::RuntimeError; end
class IO::Buffer::AllocationError < ::RuntimeError; end
IO::Buffer::BIG_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::EXTERNAL = T.let(T.unsafe(nil), Integer)
IO::Buffer::HOST_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::INTERNAL = T.let(T.unsafe(nil), Integer)
class IO::Buffer::InvalidatedError < ::RuntimeError; end
IO::Buffer::LITTLE_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::LOCKED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::LockedError < ::RuntimeError; end
IO::Buffer::MAPPED = T.let(T.unsafe(nil), Integer)
class IO::Buffer::MaskError < ::ArgumentError; end
IO::Buffer::NETWORK_ENDIAN = T.let(T.unsafe(nil), Integer)
IO::Buffer::PAGE_SIZE = T.let(T.unsafe(nil), Integer)
IO::Buffer::PRIVATE = T.let(T.unsafe(nil), Integer)
IO::Buffer::READONLY = T.let(T.unsafe(nil), Integer)
IO::Buffer::SHARED = T.let(T.unsafe(nil), Integer)
class IO::ConsoleMode; end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
