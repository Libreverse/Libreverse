# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `fiddle` gem.
# Please instead update this file by running `bin/tapioca gem fiddle`.


# source://fiddle//lib/fiddle/closure.rb#2
module Fiddle
  private

  # source://fiddle//lib/fiddle.rb#124
  def dlopen(library); end

  # source://fiddle//lib/fiddle.rb#4
  def dlunwrap(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def dlwrap(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def free(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def malloc(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def realloc(_arg0, _arg1); end

  class << self
    # source://fiddle//lib/fiddle.rb#128
    def dlopen(library); end

    # source://fiddle//lib/fiddle.rb#4
    def dlunwrap(_arg0); end

    # source://fiddle//lib/fiddle.rb#4
    def dlwrap(_arg0); end

    # source://fiddle//lib/fiddle.rb#4
    def free(_arg0); end

    # Returns the last +Error+ of the current executing +Thread+ or nil if none
    #
    # source://fiddle//lib/fiddle.rb#41
    def last_error; end

    # Sets the last +Error+ of the current executing +Thread+ to +error+
    #
    # source://fiddle//lib/fiddle.rb#46
    def last_error=(error); end

    # source://fiddle//lib/fiddle.rb#4
    def malloc(_arg0); end

    # source://fiddle//lib/fiddle.rb#4
    def realloc(_arg0, _arg1); end
  end
end

Fiddle::ALIGN_BOOL = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_INT16_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_INT32_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_INT64_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_INT8_T = T.let(T.unsafe(nil), Integer)
class Fiddle::ClearedReferenceError < ::Fiddle::Error; end

# source://fiddle//lib/fiddle/closure.rb#3
class Fiddle::Closure
  # @return [Closure] a new instance of Closure
  #
  # source://fiddle//lib/fiddle.rb#4
  def initialize(*_arg0); end

  # arguments of the FFI closure
  #
  # source://fiddle//lib/fiddle/closure.rb#34
  def args; end

  # the C type of the return of the FFI closure
  #
  # source://fiddle//lib/fiddle/closure.rb#31
  def ctype; end

  # source://fiddle//lib/fiddle.rb#4
  def free; end

  # @return [Boolean]
  #
  # source://fiddle//lib/fiddle.rb#4
  def freed?; end

  # source://fiddle//lib/fiddle.rb#4
  def to_i; end

  class << self
    # Create a new closure. If a block is given, the created closure
    # is automatically freed after the given block is executed.
    #
    # The all given arguments are passed to Fiddle::Closure.new. So
    # using this method without block equals to Fiddle::Closure.new.
    #
    # == Example
    #
    #   Fiddle::Closure.create(TYPE_INT, [TYPE_INT]) do |closure|
    #     # closure is freed automatically when this block is finished.
    #   end
    #
    # source://fiddle//lib/fiddle/closure.rb#16
    def create(*args); end
  end
end

# Extends Fiddle::Closure to allow for building the closure in a block
#
# source://fiddle//lib/fiddle/closure.rb#37
class Fiddle::Closure::BlockCaller < ::Fiddle::Closure
  # == Description
  #
  # Construct a new BlockCaller object.
  #
  # * +ctype+ is the C type to be returned
  # * +args+ are passed the callback
  # * +abi+ is the abi of the closure
  #
  # If there is an error in preparing the +ffi_cif+ or +ffi_prep_closure+,
  # then a RuntimeError will be raised.
  #
  # == Example
  #
  #   include Fiddle
  #
  #   cb = Closure::BlockCaller.new(TYPE_INT, [TYPE_INT]) do |one|
  #     one
  #   end
  #
  #   func = Function.new(cb, [TYPE_INT], TYPE_INT)
  #
  # @return [BlockCaller] a new instance of BlockCaller
  #
  # source://fiddle//lib/fiddle/closure.rb#60
  def initialize(ctype, args, abi = T.unsafe(nil), &block); end

  # Calls the constructed BlockCaller, with +args+
  #
  # For an example see Fiddle::Closure::BlockCaller.new
  #
  # source://fiddle//lib/fiddle/closure.rb#69
  def call(*args); end
end

class Fiddle::Error < ::StandardError; end

# source://fiddle//lib/fiddle/function.rb#3
class Fiddle::Function
  # @return [Function] a new instance of Function
  #
  # source://fiddle//lib/fiddle.rb#4
  def initialize(*_arg0); end

  # The ABI of the Function.
  #
  # source://fiddle//lib/fiddle/function.rb#5
  def abi; end

  # source://fiddle//lib/fiddle.rb#4
  def call(*_arg0); end

  # The name of this function
  #
  # source://fiddle//lib/fiddle/function.rb#11
  def name; end

  # Whether GVL is needed to call this function
  #
  # @return [Boolean]
  #
  # source://fiddle//lib/fiddle/function.rb#14
  def need_gvl?; end

  # The address of this function
  #
  # source://fiddle//lib/fiddle/function.rb#8
  def ptr; end

  # The integer memory location of this function
  #
  # source://fiddle//lib/fiddle/function.rb#19
  def to_i; end

  # Turn this function in to a proc
  #
  # source://fiddle//lib/fiddle/function.rb#24
  def to_proc; end
end

class Fiddle::Handle
  # @return [Handle] a new instance of Handle
  #
  # source://fiddle//lib/fiddle.rb#4
  def initialize(*_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def [](_arg0); end

  # @raise [DLError]
  #
  # source://fiddle//lib/fiddle.rb#4
  def close; end

  # @return [Boolean]
  #
  # source://fiddle//lib/fiddle.rb#4
  def close_enabled?; end

  # source://fiddle//lib/fiddle.rb#4
  def disable_close; end

  # source://fiddle//lib/fiddle.rb#4
  def enable_close; end

  # source://fiddle//lib/fiddle.rb#4
  def file_name; end

  # @raise [TypeError]
  #
  # source://fiddle//lib/fiddle.rb#4
  def sym(_arg0); end

  # @raise [TypeError]
  # @return [Boolean]
  #
  # source://fiddle//lib/fiddle.rb#4
  def sym_defined?(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def to_i; end

  # source://fiddle//lib/fiddle.rb#4
  def to_ptr; end

  class << self
    # source://fiddle//lib/fiddle.rb#4
    def [](_arg0); end

    # source://fiddle//lib/fiddle.rb#4
    def sym(_arg0); end

    # @return [Boolean]
    #
    # source://fiddle//lib/fiddle.rb#4
    def sym_defined?(_arg0); end
  end
end

class Fiddle::MemoryView
  # source://fiddle//lib/fiddle.rb#4
  def initialize(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def [](*_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def byte_size; end

  # source://fiddle//lib/fiddle.rb#4
  def format; end

  # source://fiddle//lib/fiddle.rb#4
  def item_size; end

  # source://fiddle//lib/fiddle.rb#4
  def ndim; end

  # source://fiddle//lib/fiddle.rb#4
  def obj; end

  # source://fiddle//lib/fiddle.rb#4
  def readonly?; end

  # source://fiddle//lib/fiddle.rb#4
  def release; end

  # source://fiddle//lib/fiddle.rb#4
  def shape; end

  # source://fiddle//lib/fiddle.rb#4
  def strides; end

  # source://fiddle//lib/fiddle.rb#4
  def sub_offsets; end

  # source://fiddle//lib/fiddle.rb#4
  def to_s; end

  class << self
    # source://fiddle//lib/fiddle.rb#4
    def export(_arg0); end
  end
end

Fiddle::NULL = T.let(T.unsafe(nil), Fiddle::Pointer)

class Fiddle::Pinned
  # @return [Pinned] a new instance of Pinned
  #
  # source://fiddle//lib/fiddle.rb#4
  def initialize(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def clear; end

  # @return [Boolean]
  #
  # source://fiddle//lib/fiddle.rb#4
  def cleared?; end

  # source://fiddle//lib/fiddle.rb#4
  def ref; end
end

# Pointer isn't thread safe for now
class Fiddle::Pointer
  # @return [Pointer] a new instance of Pointer
  #
  # source://fiddle//lib/fiddle.rb#4
  def initialize(*_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def +(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def +@; end

  # source://fiddle//lib/fiddle.rb#4
  def -(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def -@; end

  # source://fiddle//lib/fiddle.rb#4
  def <=>(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def ==(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def [](*_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def []=(*_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def call_free; end

  # @return [Boolean]
  #
  # source://fiddle//lib/fiddle.rb#4
  def eql?(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def free; end

  # source://fiddle//lib/fiddle.rb#4
  def free=(_arg0); end

  # @return [Boolean]
  #
  # source://fiddle//lib/fiddle.rb#4
  def freed?; end

  # source://fiddle//lib/fiddle.rb#4
  def inspect; end

  # @return [Boolean]
  #
  # source://fiddle//lib/fiddle.rb#4
  def null?; end

  # source://fiddle//lib/fiddle.rb#4
  def ptr; end

  # source://fiddle//lib/fiddle.rb#4
  def ref; end

  # source://fiddle//lib/fiddle.rb#4
  def size; end

  # source://fiddle//lib/fiddle.rb#4
  def size=(_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def to_i; end

  # source://fiddle//lib/fiddle.rb#4
  def to_int; end

  # source://fiddle//lib/fiddle.rb#4
  def to_s(*_arg0); end

  # source://fiddle//lib/fiddle.rb#4
  def to_str(*_arg0); end

  # @raise [NotImplementedError]
  #
  # source://fiddle//lib/fiddle.rb#4
  def to_value; end

  class << self
    # source://fiddle//lib/fiddle.rb#4
    def [](_arg0); end

    # source://fiddle//lib/fiddle.rb#4
    def malloc(*_arg0); end

    # source://fiddle//lib/fiddle.rb#4
    def read(_arg0, _arg1); end

    # source://fiddle//lib/fiddle.rb#4
    def to_ptr(_arg0); end

    # source://fiddle//lib/fiddle.rb#4
    def write(_arg0, _arg1); end
  end
end

Fiddle::Qfalse = T.let(T.unsafe(nil), Integer)
Fiddle::Qnil = T.let(T.unsafe(nil), Integer)
Fiddle::Qtrue = T.let(T.unsafe(nil), Integer)
Fiddle::Qundef = T.let(T.unsafe(nil), Integer)

# Add constants for backwards compat
#
# source://fiddle//lib/fiddle.rb#132
Fiddle::RTLD_GLOBAL = T.let(T.unsafe(nil), Integer)

# source://fiddle//lib/fiddle.rb#133
Fiddle::RTLD_LAZY = T.let(T.unsafe(nil), Integer)

# source://fiddle//lib/fiddle.rb#134
Fiddle::RTLD_NOW = T.let(T.unsafe(nil), Integer)

module Fiddle::Types; end
Fiddle::Types::BOOL = T.let(T.unsafe(nil), Integer)
Fiddle::Types::CHAR = T.let(T.unsafe(nil), Integer)
Fiddle::Types::CONST_STRING = T.let(T.unsafe(nil), Integer)
Fiddle::Types::DOUBLE = T.let(T.unsafe(nil), Integer)
Fiddle::Types::FLOAT = T.let(T.unsafe(nil), Integer)
Fiddle::Types::INT = T.let(T.unsafe(nil), Integer)
Fiddle::Types::INT16_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::INT32_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::INT64_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::INT8_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::INTPTR_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::LONG = T.let(T.unsafe(nil), Integer)
Fiddle::Types::LONG_LONG = T.let(T.unsafe(nil), Integer)
Fiddle::Types::PTRDIFF_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::SHORT = T.let(T.unsafe(nil), Integer)
Fiddle::Types::SIZE_T = T.let(T.unsafe(nil), Integer)

# FIXME: platform specific values
Fiddle::Types::SSIZE_T = T.let(T.unsafe(nil), Integer)

Fiddle::Types::UCHAR = T.let(T.unsafe(nil), Integer)
Fiddle::Types::UINT = T.let(T.unsafe(nil), Integer)
Fiddle::Types::UINT16_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::UINT32_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::UINT64_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::UINT8_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::UINTPTR_T = T.let(T.unsafe(nil), Integer)
Fiddle::Types::ULONG = T.let(T.unsafe(nil), Integer)
Fiddle::Types::ULONG_LONG = T.let(T.unsafe(nil), Integer)
Fiddle::Types::USHORT = T.let(T.unsafe(nil), Integer)
Fiddle::Types::VARIADIC = T.let(T.unsafe(nil), Integer)
Fiddle::Types::VOID = T.let(T.unsafe(nil), Integer)
Fiddle::Types::VOIDP = T.let(T.unsafe(nil), Integer)

# source://fiddle//lib/fiddle/version.rb#2
Fiddle::VERSION = T.let(T.unsafe(nil), String)

Fiddle::WINDOWS = T.let(T.unsafe(nil), FalseClass)
