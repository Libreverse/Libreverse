# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `json-ld` gem.
# Please instead update this file by running `bin/tapioca gem json-ld`.


# source://json-ld//lib/json/ld/extensions.rb#46
class Array
  include ::Enumerable

  # Optionally order items
  #
  # @param ordered [Boolean]
  # @return [Array]
  #
  # source://json-ld//lib/json/ld/extensions.rb#51
  def opt_sort(ordered: T.unsafe(nil)); end
end

# **`JSON::LD`** is a JSON-LD extension for RDF.rb.
#
# @author [Gregg Kellogg](http://greggkellogg.net/)
# @example Parsing RDF statements from a JSON-LD file
#   JSON::LD::Reader.open("etc/foaf.jld") do |reader|
#   reader.each_statement do |statement|
#   puts statement.inspect
#   end
#   end
# @example Requiring the `JSON::LD` module
#   require 'json/ld'
# @see http://www.w3.org/TR/REC-rdf-syntax/
# @see https://rubygems.org/gems/rdf
#
# source://json-ld//lib/json/ld.rb#26
module JSON::LD; end

# A JSON-LD processor based on the JsonLdProcessor interface.
#
# This API provides a clean mechanism that enables developers to convert JSON-LD data into a a variety of output formats that are easier to work with in various programming languages. If a JSON-LD API is provided in a programming environment, the entirety of the following API must be implemented.
#
# Note that the API method signatures are somewhat different than what is specified, as the use of Futures and explicit callback parameters is not as relevant for Ruby-based interfaces.
#
# @author [Gregg Kellogg](http://greggkellogg.net/)
# @see https://www.w3.org/TR/json-ld11-api/#the-application-programming-interface
#
# source://json-ld//lib/json/ld/api.rb#30
class JSON::LD::API
  include ::JSON::LD::Utils
  include ::JSON::LD::Expand
  include ::JSON::LD::Compact
  include ::JSON::LD::ToRDF
  include ::JSON::LD::Flatten
  include ::JSON::LD::FromRDF
  include ::JSON::LD::Frame
  include ::RDF::Util::Logger

  # Initialize the API, reading in any document and setting global options
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param context [String, #read, Hash, Array, JSON::LD::Context] An external context to use additionally to the context embedded in input when expanding the input.
  # @param input [String, #read, Hash, Array]
  # @param options [Hash{Symbol => Object}]
  # @raise [JsonLdError]
  # @return [API] a new instance of API
  # @yield [api]
  # @yieldparam [API]
  #
  # source://json-ld//lib/json/ld/api.rb#109
  def initialize(input, context, **options, &block); end

  # Input evaluation context
  #
  # @return [JSON::LD::Context]
  #
  # source://json-ld//lib/json/ld/api.rb#58
  def context; end

  # Input evaluation context
  #
  # @return [JSON::LD::Context]
  #
  # source://json-ld//lib/json/ld/api.rb#58
  def context=(_arg0); end

  # Current Blank Node Namer
  #
  # @return [JSON::LD::BlankNodeNamer]
  #
  # source://json-ld//lib/json/ld/api.rb#63
  def namer; end

  # Current input
  #
  # @return [String, #read, Hash, Array]
  #
  # source://json-ld//lib/json/ld/api.rb#53
  def value; end

  # Current input
  #
  # @return [String, #read, Hash, Array]
  #
  # source://json-ld//lib/json/ld/api.rb#53
  def value=(_arg0); end

  class << self
    # Adds a loader for some specific content type
    #
    # @param loader [Proc]
    # @param type [String]
    #
    # source://json-ld//lib/json/ld/api.rb#780
    def add_script_loader(type, loader); end

    # Compacts the given input according to the steps in the Compaction Algorithm. The input must be copied, compacted and returned if there are no errors. If the compaction fails, an appropirate exception must be thrown.
    #
    # If no context is provided, the input document is compacted using the top-level context of the document
    #
    # The resulting `Hash` is either returned or yielded, if a block is given.
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param context [String, #read, Hash, Array, JSON::LD::Context] The base context to use when compacting the input.
    # @param expanded [Boolean] (false) Input is already expanded
    # @param input [String, #read, Hash, Array] The JSON-LD object to copy and perform the compaction upon.
    # @param options [Hash{Symbol => Object}]
    # @param serializer [Proc] (nil)
    #   A Serializer instance used for generating the JSON serialization of the result. If absent, the internal Ruby objects are returned, which can be transformed to JSON externally via `#to_json`.
    #   See {JSON::LD::API.serializer}.
    # @raise [JsonLdError]
    # @return [Object, Hash] If a block is given, the result of evaluating the block is returned, otherwise, the compacted JSON-LD document
    # @see https://www.w3.org/TR/json-ld11-api/#compaction-algorithm
    # @yield jsonld
    # @yieldparam jsonld [Hash] The compacted JSON-LD document
    # @yieldreturn [Object] returned object
    #
    # source://json-ld//lib/json/ld/api.rb#235
    def compact(input, context, expanded: T.unsafe(nil), serializer: T.unsafe(nil), **options); end

    # Default document loader.
    #
    # @param extractAllScripts [Boolean] If set to `true`, when extracting JSON-LD script elements from HTML, unless a specific fragment identifier is targeted, extracts all encountered JSON-LD script elements using an array form, if necessary.
    # @param options [Hash<Symbol => Object>]
    # @param profile [String] When the resulting `contentType` is `text/html` or `application/xhtml+xml`, this option determines the profile to use for selecting a JSON-LD script elements.
    # @param requestProfile [String] One or more IRIs to use in the request as a profile parameter.
    # @param url [RDF::URI, String]
    # @raise [IOError]
    # @yield remote_document
    # @yieldparam remote_document [RemoteDocument, RDF::Util::File::RemoteDocument]
    #
    # source://json-ld//lib/json/ld/api.rb#734
    def documentLoader(url, extractAllScripts: T.unsafe(nil), profile: T.unsafe(nil), requestProfile: T.unsafe(nil), **options, &block); end

    # Expands the given input according to the steps in the Expansion Algorithm. The input must be copied, expanded and returned if there are no errors. If the expansion fails, an appropriate exception must be thrown.
    #
    # The resulting `Array` either returned or yielded
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param input [String, #read, Hash, Array] The JSON-LD object to copy and perform the expansion upon.
    # @param options [Hash{Symbol => Object}]
    # @param serializer [Proc] (nil)
    #   A Serializer method used for generating the JSON serialization of the result. If absent, the internal Ruby objects are returned, which can be transformed to JSON externally via `#to_json`.
    #   See {JSON::LD::API.serializer}.
    # @raise [JsonLdError]
    # @return [Object, Array<Hash>] If a block is given, the result of evaluating the block is returned, otherwise, the expanded JSON-LD document
    # @see https://www.w3.org/TR/json-ld11-api/#expansion-algorithm
    # @yield jsonld, base_iri
    # @yieldparam base_iri [RDF::URI] The document base as determined during expansion
    # @yieldparam jsonld [Array<Hash>] The expanded JSON-LD document
    # @yieldreturn [Object] returned object
    #
    # source://json-ld//lib/json/ld/api.rb#183
    def expand(input, framing: T.unsafe(nil), serializer: T.unsafe(nil), **options, &block); end

    # This algorithm flattens an expanded JSON-LD document by collecting all properties of a node in a single JSON object and labeling all blank nodes with blank node identifiers. This resulting uniform shape of the document, may drastically simplify the code required to process JSON-LD data in certain applications.
    #
    # The resulting `Array` is either returned, or yielded if a block is given.
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param context [String, #read, Hash, Array, JSON::LD::EvaluationContext] An optional external context to use additionally to the context embedded in input when expanding the input.
    # @param expanded [Boolean] (false) Input is already expanded
    # @param input [String, #read, Hash, Array] The JSON-LD object or array of JSON-LD objects to flatten or an IRI referencing the JSON-LD document to flatten.
    # @param options [Hash{Symbol => Object}]
    # @param serializer [Proc] (nil)
    #   A Serializer instance used for generating the JSON serialization of the result. If absent, the internal Ruby objects are returned, which can be transformed to JSON externally via `#to_json`.
    #   See {JSON::LD::API.serializer}.
    # @return [Object, Hash] If a block is given, the result of evaluating the block is returned, otherwise, the flattened JSON-LD document
    # @see https://www.w3.org/TR/json-ld11-api/#framing-algorithm
    # @yield jsonld
    # @yieldparam jsonld [Hash] The flattened JSON-LD document
    # @yieldreturn [Object] returned object
    #
    # source://json-ld//lib/json/ld/api.rb#290
    def flatten(input, context, expanded: T.unsafe(nil), serializer: T.unsafe(nil), **options); end

    # Frames the given input using the frame according to the steps in the Framing Algorithm. The input is used to build the framed output and is returned if there are no errors. If there are no matches for the frame, null must be returned. Exceptions must be thrown if there are errors.
    #
    # The resulting `Array` is either returned, or yielded if a block is given.
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param expanded [Boolean] (false) Input is already expanded
    # @param frame [String, #read, Hash, Array] The frame to use when re-arranging the data.
    # @param input [String, #read, Hash, Array] The JSON-LD object to copy and perform the framing on.
    # @param options [Hash] a customizable set of options
    # @raise [InvalidFrame]
    # @return [Object, Hash] If a block is given, the result of evaluating the block is returned, otherwise, the framed JSON-LD document
    # @see https://www.w3.org/TR/json-ld11-api/#framing-algorithm
    # @yield jsonld
    # @yieldparam jsonld [Hash] The framed JSON-LD document
    # @yieldreturn [Object] returned object
    #
    # source://json-ld//lib/json/ld/api.rb#382
    def frame(input, frame, expanded: T.unsafe(nil), serializer: T.unsafe(nil), **options); end

    # Take an ordered list of RDF::Statements and turn them into a JSON-LD document.
    #
    # The resulting `Array` is either returned or yielded, if a block is given.
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param input [RDF::Enumerable]
    # @param options [Hash{Symbol => Object}]
    # @param serializer [Proc] (nil)
    #   A Serializer instance used for generating the JSON serialization of the result. If absent, the internal Ruby objects are returned, which can be transformed to JSON externally via `#to_json`.
    #   See {JSON::LD::API.serializer}.
    # @param useNativeTypes [Boolean] (false) use native representations
    # @param useRdfType [Boolean] (false)
    #   If set to `true`, the JSON-LD processor will treat `rdf:type` like a normal property instead of using `@type`.
    # @return [Object, Hash] If a block is given, the result of evaluating the block is returned, otherwise, the expanded JSON-LD document
    # @yield jsonld
    # @yieldparam jsonld [Hash] The JSON-LD document in expanded form
    # @yieldreturn [Object] returned object
    #
    # source://json-ld//lib/json/ld/api.rb#759
    def fromRDF(input, useRdfType: T.unsafe(nil), useNativeTypes: T.unsafe(nil), serializer: T.unsafe(nil), **options); end

    # Take an ordered list of RDF::Statements and turn them into a JSON-LD document.
    #
    # The resulting `Array` is either returned or yielded, if a block is given.
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param input [RDF::Enumerable]
    # @param options [Hash{Symbol => Object}]
    # @param serializer [Proc] (nil)
    #   A Serializer instance used for generating the JSON serialization of the result. If absent, the internal Ruby objects are returned, which can be transformed to JSON externally via `#to_json`.
    #   See {JSON::LD::API.serializer}.
    # @param useNativeTypes [Boolean] (false) use native representations
    # @param useRdfType [Boolean] (false)
    #   If set to `true`, the JSON-LD processor will treat `rdf:type` like a normal property instead of using `@type`.
    # @return [Object, Hash] If a block is given, the result of evaluating the block is returned, otherwise, the expanded JSON-LD document
    # @yield jsonld
    # @yieldparam jsonld [Hash] The JSON-LD document in expanded form
    # @yieldreturn [Object] returned object
    #
    # source://json-ld//lib/json/ld/api.rb#585
    def fromRdf(input, useRdfType: T.unsafe(nil), useNativeTypes: T.unsafe(nil), serializer: T.unsafe(nil), **options); end

    # Uses built-in or provided documentLoader to retrieve a parsed document.
    #
    # @option options
    # @param allowed_content_types [Regexp] A regular expression matching other content types allowed
    #   beyond types for JSON and HTML.
    # @param base [String, RDF::URI] Location to use as documentUrl instead of `url`.
    # @param extractAllScripts [Boolean] If set to `true`, when extracting JSON-LD script elements from HTML, unless a specific fragment identifier is targeted, extracts all encountered JSON-LD script elements using an array form, if necessary.
    # @param options [Hash<Symbol => Object>]
    # @param profile [String] When the resulting `contentType` is `text/html` or `application/xhtml+xml`, this option determines the profile to use for selecting a JSON-LD script elements.
    # @param requestProfile [String] One or more IRIs to use in the request as a profile parameter.
    # @param url [RDF::URI, String]
    # @param validate [Boolean] (false)
    #   Allow only appropriate content types
    # @raise [JsonLdError]
    # @return [Object, RemoteDocument] If a block is given, the result of evaluating the block is returned, otherwise, the retrieved remote document and context information unless block given
    # @yield remote_document
    # @yieldparam remote_document [RemoteDocumentRemoteDocument, RDF::Util::File::RemoteDocument]
    # @yieldreturn [Object] returned object
    #
    # source://json-ld//lib/json/ld/api.rb#625
    def loadRemoteDocument(url, allowed_content_types: T.unsafe(nil), base: T.unsafe(nil), documentLoader: T.unsafe(nil), extractAllScripts: T.unsafe(nil), profile: T.unsafe(nil), requestProfile: T.unsafe(nil), validate: T.unsafe(nil), **options); end

    # Load one or more script tags from an HTML source.
    # Unescapes and uncomments input, returns the internal representation
    # Yields document base
    #
    # @param extractAllScripts [Boolean] (false)
    # @param input [String]
    # @param library [:nokogiri, :rexml] (nil)
    # @param options [Hash{Symbol => Object}]
    # @param profile [Boolean] (nil) Optional priortized profile when loading a single script by type.
    # @param url [String] Original URL
    #
    # source://json-ld//lib/json/ld/api.rb#794
    def load_html(input, url:, library: T.unsafe(nil), extractAllScripts: T.unsafe(nil), profile: T.unsafe(nil), **options); end

    # The default serializer for serialzing Ruby Objects to JSON.
    #
    # Defaults to `MultiJson.dump`
    #
    # @option options
    # @param args [Array<Object>] other arguments that may be passed for some specific implementation.
    # @param object [Object]
    # @param options [Hash<Symbol, Object>] options passed from the invoking context.
    #
    # source://json-ld//lib/json/ld/api.rb#900
    def serializer(object, *_args, **options); end

    # Processes the input according to the RDF Conversion Algorithm, calling the provided callback for each triple generated.
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param expanded [Boolean] (false) Input is already expanded
    # @param input [String, #read, Hash, Array] The JSON-LD object to process when outputting statements.
    # @param options [Hash] a customizable set of options
    # @raise [JsonLdError]
    # @return [RDF::Enumerable] set of statements, unless a block is given.
    # @yield statement
    # @yieldparam statement [RDF::Statement]
    #
    # source://json-ld//lib/json/ld/api.rb#758
    def toRDF(input, expanded: T.unsafe(nil), **options); end

    # Processes the input according to the RDF Conversion Algorithm, calling the provided callback for each triple generated.
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param expanded [Boolean] (false) Input is already expanded
    # @param input [String, #read, Hash, Array] The JSON-LD object to process when outputting statements.
    # @param options [Hash] a customizable set of options
    # @raise [JsonLdError]
    # @return [RDF::Enumerable] set of statements, unless a block is given.
    # @yield statement
    # @yieldparam statement [RDF::Statement]
    #
    # source://json-ld//lib/json/ld/api.rb#526
    def toRdf(input, expanded: T.unsafe(nil), **options); end

    # Validate JSON using JsonLint, if loaded
    #
    # source://json-ld//lib/json/ld/api.rb#908
    def validate_input(input, url:); end
  end
end

# source://json-ld//lib/json/ld/api.rb#48
JSON::LD::API::JSON_LD_PROCESSING_MODES = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/api.rb#46
JSON::LD::API::LINK_REL_ALTERNATE = T.let(T.unsafe(nil), Array)

# The following constants are used to reduce object allocations
#
# source://json-ld//lib/json/ld/api.rb#45
JSON::LD::API::LINK_REL_CONTEXT = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/api.rb#47
JSON::LD::API::LINK_TYPE_JSONLD = T.let(T.unsafe(nil), Array)

# Options used for open_file
#
# source://json-ld//lib/json/ld/api.rb#40
JSON::LD::API::OPEN_OPTS = T.let(T.unsafe(nil), Hash)

# A {RemoteDocument} is returned from a {documentLoader}.
#
# source://json-ld//lib/json/ld/api.rb#922
class JSON::LD::API::RemoteDocument
  # @option options
  # @param contentType [String] The Content-Type of the loaded document, exclusive of any optional parameters.
  # @param contextUrl [String] The URL of a remote context as specified by an HTTP Link header with rel=`http://www.w3.org/ns/json-ld#context`
  # @param document [RDF::Util::File::RemoteDocument]
  # @param documentUrl [String] The final URL of the loaded document. This is important to handle HTTP redirects properly.
  # @param options [Hash] a customizable set of options
  # @param profile [String] The value of any profile parameter retrieved as part of the original contentType.
  # @return [RemoteDocument] a new instance of RemoteDocument
  #
  # source://json-ld//lib/json/ld/api.rb#953
  def initialize(document, documentUrl: T.unsafe(nil), contentType: T.unsafe(nil), contextUrl: T.unsafe(nil), profile: T.unsafe(nil), **options); end

  # The Content-Type of the loaded document, exclusive of any optional parameters.
  #
  # @return [String]
  #
  # source://json-ld//lib/json/ld/api.rb#929
  def contentType; end

  # @return [String] The URL of a remote context as specified by an HTTP Link header with rel=`http://www.w3.org/ns/json-ld#context`
  #
  # source://json-ld//lib/json/ld/api.rb#933
  def contextUrl; end

  # @return [String] The URL of a remote context as specified by an HTTP Link header with rel=`http://www.w3.org/ns/json-ld#context`
  #
  # source://json-ld//lib/json/ld/api.rb#933
  def contextUrl=(_arg0); end

  # The parsed retrieved document.
  #
  # @return [Array<Hash>, Hash]
  #
  # source://json-ld//lib/json/ld/api.rb#937
  def document; end

  # The parsed retrieved document.
  #
  # @return [Array<Hash>, Hash]
  #
  # source://json-ld//lib/json/ld/api.rb#937
  def document=(_arg0); end

  # The final URL of the loaded document. This is important to handle HTTP redirects properly.
  #
  # @return [String]
  #
  # source://json-ld//lib/json/ld/api.rb#925
  def documentUrl; end

  # The final URL of the loaded document. This is important to handle HTTP redirects properly.
  #
  # @return [String]
  #
  # source://json-ld//lib/json/ld/api.rb#925
  def documentUrl=(_arg0); end

  # The value of any profile parameter retrieved as part of the original contentType.
  #
  # @return [String]
  #
  # source://json-ld//lib/json/ld/api.rb#941
  def profile; end

  # The value of any profile parameter retrieved as part of the original contentType.
  #
  # @return [String]
  #
  # source://json-ld//lib/json/ld/api.rb#941
  def profile=(_arg0); end
end

# Hash of recognized script types and the loaders that decode them
# into a hash or array of hashes.
#
# source://json-ld//lib/json/ld/api.rb#767
JSON::LD::API::SCRIPT_LOADERS = T.let(T.unsafe(nil), Hash)

# Utility class for mapping old blank node identifiers, or unnamed blank
# nodes to new identifiers
#
# source://json-ld//lib/json/ld/utils.rb#245
class JSON::LD::BlankNodeMapper < ::Hash
  # Get a new mapped name for `old`
  #
  # @param old [String] ("")
  # @return [String]
  #
  # source://json-ld//lib/json/ld/utils.rb#261
  def get_name(old = T.unsafe(nil)); end

  # Just return a Blank Node based on `old`. Manufactures
  # a node if `old` is nil or empty
  #
  # @param old [String] ("")
  # @return [String]
  #
  # source://json-ld//lib/json/ld/utils.rb#251
  def get_sym(old = T.unsafe(nil)); end
end

# source://json-ld//lib/json/ld/utils.rb#283
class JSON::LD::BlankNodeNamer < ::JSON::LD::BlankNodeMapper
  # @param prefix [String]
  # @return [BlankNodeNamer] a new instance of BlankNodeNamer
  #
  # source://json-ld//lib/json/ld/utils.rb#285
  def initialize(prefix); end

  # Get a new symbol mapped from `old`
  #
  # @param old [String] ("")
  # @return [String]
  #
  # source://json-ld//lib/json/ld/utils.rb#295
  def get_sym(old = T.unsafe(nil)); end
end

# source://json-ld//lib/json/ld/utils.rb#266
class JSON::LD::BlankNodeUniqer < ::JSON::LD::BlankNodeMapper
  # Use the uniquely generated bnodes, rather than a sequence
  #
  # @param old [String] ("")
  # @return [String]
  #
  # source://json-ld//lib/json/ld/utils.rb#271
  def get_sym(old = T.unsafe(nil)); end
end

# source://json-ld//lib/json/ld/compact.rb#5
module JSON::LD::Compact
  include ::JSON::LD::Utils

  # This algorithm compacts a JSON-LD document, such that the given context is applied. This must result in shortening any applicable IRIs to terms or compact IRIs, any applicable keywords to keyword aliases, and any applicable JSON-LD values expressed in expanded form to simple values such as strings or numbers.
  #
  # @param base [String, RDF::URI] (nil)
  #   Ensure output objects have keys ordered properly
  # @param element [Array, Hash]
  # @param property [String] (nil)
  #   Extra validatation
  # @return [Array, Hash]
  #
  # source://json-ld//lib/json/ld/compact.rb#21
  def compact(element, base: T.unsafe(nil), property: T.unsafe(nil), log_depth: T.unsafe(nil)); end
end

# The following constant is used to reduce object allocations in #compact below
#
# source://json-ld//lib/json/ld/compact.rb#9
JSON::LD::Compact::CONTAINER_MAPPING_LANGUAGE_INDEX_ID_TYPE = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/compact.rb#10
JSON::LD::Compact::EXPANDED_PROPERTY_DIRECTION_INDEX_LANGUAGE_VALUE = T.let(T.unsafe(nil), Array)

# Rack middleware for JSON-LD content negotiation.
#
# Uses HTTP Content Negotiation to serialize `Array` and `Hash` results as JSON-LD using 'profile' accept-params to invoke appropriate JSON-LD API methods.
#
# Allows black-listing and white-listing of two-part profiles where the second part denotes a URL of a _context_ or _frame_. (See {JSON::LD::Writer.accept?})
#
# Works along with `rack-linkeddata` for serializing data which is not in the form of an `RDF::Repository`.
#
# @example
#   use JSON::LD::Rack
# @see https://www.rubydoc.info/github/rack/rack/master/file/SPEC
# @see https://www.w3.org/TR/json-ld11/#iana-considerations
#
# source://json-ld//lib/json/ld/conneg.rb#25
class JSON::LD::ContentNegotiation
  # @return [ContentNegotiation] a new instance of ContentNegotiation
  #
  # source://json-ld//lib/json/ld/conneg.rb#42
  def initialize(app); end

  # @return [#call]
  #
  # source://json-ld//lib/json/ld/conneg.rb#29
  def app; end

  # Handles a Rack protocol request.
  # Parses Accept header to find appropriate mime-type and sets content_type accordingly.
  #
  # @param env [Hash{String => String}]
  # @return [Array(Integer, Hash, #each)] Status, Headers and Body
  # @see https://rubydoc.info/github/rack/rack/file/SPEC
  #
  # source://json-ld//lib/json/ld/conneg.rb#53
  def call(env); end

  # Serializes objects as JSON-LD. Defaults to expanded form, other forms
  # determined by presense of `profile` in accept-parms.
  #
  # @param body [RDF::Enumerable]
  # @param env [Hash{String => String}]
  # @param headers [Hash{String => Object}]
  # @param status [Integer]
  # @return [Array(Integer, Hash, #each)] Status, Headers and Body
  #
  # source://json-ld//lib/json/ld/conneg.rb#73
  def serialize(env, status, headers, body); end

  protected

  # Returns an array of quality, number of '*' in content-type, and number of non-'q' parameters
  #
  # source://json-ld//lib/json/ld/conneg.rb#155
  def accept_entry(entry); end

  # Returns a content type appropriate for the given `media_range`,
  # returns `nil` if `media_range` contains a wildcard subtype
  # that is not mapped.
  #
  # @param media_range [String, #to_s]
  # @return [String, nil]
  #
  # source://json-ld//lib/json/ld/conneg.rb#169
  def find_content_type_for_media_range(media_range); end

  # Outputs an HTTP `4xx` or `5xx` response.
  #
  # @param code [Integer, #to_i]
  # @param headers [Hash{String => String}]
  # @param message [String, #to_s]
  # @return [Array(Integer, Hash, #each)]
  #
  # source://json-ld//lib/json/ld/conneg.rb#199
  def http_error(code, message = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Outputs an HTTP `406 Not Acceptable` response.
  #
  # @param message [String, #to_s]
  # @return [Array(Integer, Hash, #each)]
  #
  # source://json-ld//lib/json/ld/conneg.rb#188
  def not_acceptable(message = T.unsafe(nil)); end

  # Parses an HTTP `Accept` header, returning an array of MIME content
  # types ordered by the precedence rules defined in HTTP/1.1 ยง14.1.
  #
  # @param header [String, #to_s]
  # @return [Array<String>]
  # @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1
  #
  # source://json-ld//lib/json/ld/conneg.rb#145
  def parse_accept_header(header); end

  class << self
    # * Registers JSON::LD::Rack, suitable for Sinatra application
    # * adds helpers
    #
    # @param app [Sinatra::Base]
    # @return [void]
    #
    # source://json-ld//lib/json/ld/conneg.rb#37
    def registered(app); end
  end
end

# source://json-ld//lib/json/ld/conneg.rb#26
JSON::LD::ContentNegotiation::VARY = T.let(T.unsafe(nil), Hash)

# source://json-ld//lib/json/ld/context.rb#10
class JSON::LD::Context
  include ::JSON::LD::Utils
  include ::RDF::Util::Logger

  # Create new evaluation context
  #
  # @option options
  # @option options
  # @option options
  # @param options [Hash]
  # @return [Context]
  # @yield [ec]
  # @yieldparam [Context]
  #
  # source://json-ld//lib/json/ld/context.rb#192
  def initialize(**options); end

  # Should values be represented using an array?
  #
  # @param term [Term, #to_s] in unexpanded form
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#1184
  def as_array?(term); end

  # The base.
  #
  # @return [RDF::URI] Current base IRI, used for expanding relative IRIs.
  #
  # source://json-ld//lib/json/ld/context.rb#57
  def base; end

  # @param value [String] must be an absolute IRI
  #
  # source://json-ld//lib/json/ld/context.rb#866
  def base=(value, **_options); end

  # Retrieve term coercion
  #
  # @param term [Term, #to_s] in unexpanded form
  # @return [RDF::URI, '@id']
  #
  # source://json-ld//lib/json/ld/context.rb#1170
  def coerce(term); end

  # Compacts an absolute IRI to the shortest matching term or compact IRI
  #
  # @param base [String, RDF::URI] for resolving document-relative IRIs
  # @param iri [RDF::URI]
  # @param reverse [Boolean] specifies whether a reverse property is being compacted
  # @param value [Object] Value, used to select among various maps for the same IRI
  # @param vocab [Boolean] specifies whether the passed iri should be compacted using the active context's vocabulary mapping
  # @return [String] compacted form of IRI
  # @see https://www.w3.org/TR/json-ld11-api/#iri-compaction
  #
  # source://json-ld//lib/json/ld/context.rb#1412
  def compact_iri(iri, base: T.unsafe(nil), reverse: T.unsafe(nil), value: T.unsafe(nil), vocab: T.unsafe(nil)); end

  # Compact a value
  #
  # FIXME: revisit the specification version of this.
  #
  # @param base [String, RDF::URI] for resolving document-relative IRIs
  # @param property [String] Associated property used to find coercion rules
  # @param value [Hash] Value (literal or IRI), in full object representation, to be compacted
  # @raise [JsonLdError] if the iri cannot be expanded
  # @return [Hash] Object representation of value
  # @see https://www.w3.org/TR/json-ld11-api/#value-compaction
  #
  # source://json-ld//lib/json/ld/context.rb#1662
  def compact_value(property, value, base: T.unsafe(nil)); end

  # Retrieve container mapping, add it if `value` is provided
  #
  # @param term [Term, #to_s] in unexpanded form
  # @return [Array<'@index', '@language', '@index', '@set', '@type', '@id', '@graph'>]
  #
  # source://json-ld//lib/json/ld/context.rb#1158
  def container(term); end

  # Retrieve content of a term
  #
  # @param term [Term, #to_s] in unexpanded form
  # @return [Hash]
  #
  # source://json-ld//lib/json/ld/context.rb#1196
  def content(term); end

  # @return [RDF::URI] base IRI of the context, if loaded remotely.
  #
  # source://json-ld//lib/json/ld/context.rb#60
  def context_base; end

  # @return [RDF::URI] base IRI of the context, if loaded remotely.
  #
  # source://json-ld//lib/json/ld/context.rb#60
  def context_base=(_arg0); end

  # Create Term Definition
  #
  # Term definitions are created by parsing the information in the given local context for the given term. If the given term is a compact IRI, it may omit an IRI mapping by depending on its prefix having its own term definition. If the prefix is a key in the local context, then its term definition must first be created, through recursion, before continuing. Because a term definition can depend on other term definitions, a mechanism must be used to detect cyclical dependencies. The solution employed here uses a map, defined, that keeps track of whether or not a term has been defined or is currently in the process of being defined. This map is checked before any recursion is attempted.
  #
  # After all dependencies for a term have been defined, the rest of the information in the local context for the given term is taken into account, creating the appropriate IRI mapping, container mapping, and type mapping or language mapping for the term.
  #
  # @param base [String, RDF::URI] for resolving document-relative IRIs
  # @param defined [Hash]
  # @param local_context [Hash]
  # @param override_protected [Boolean] Protected terms may be cleared.
  # @param protected [Boolean] if true, causes all terms to be marked protected
  # @param remote_contexts [Array<String>]
  # @param term [String]
  # @param validate_scoped [Boolean] (true).
  #   Validate scoped context, loading if necessary.
  #   If false, do not load scoped contexts.
  # @raise [JsonLdError] Represents a cyclical term dependency
  # @see https://www.w3.org/TR/json-ld11-api/index.html#create-term-definition
  #
  # source://json-ld//lib/json/ld/context.rb#512
  def create_term_definition(local_context, term, defined, base: T.unsafe(nil), override_protected: T.unsafe(nil), protected: T.unsafe(nil), remote_contexts: T.unsafe(nil), validate_scoped: T.unsafe(nil)); end

  # Default direction
  #
  # This adds a direction to plain strings that aren't otherwise coerced
  #
  # @return ["lrt", "rtl"]
  #
  # source://json-ld//lib/json/ld/context.rb#87
  def default_direction; end

  # @param value [String]
  #
  # source://json-ld//lib/json/ld/context.rb#899
  def default_direction=(value, **_options); end

  # Default language
  #
  # This adds a language to plain strings that aren't otherwise coerced
  #
  # @return [String]
  #
  # source://json-ld//lib/json/ld/context.rb#81
  def default_language; end

  # @param value [String]
  #
  # source://json-ld//lib/json/ld/context.rb#883
  def default_language=(value, **options); end

  # Retrieve the text direction associated with a term, or the default direction otherwise
  #
  # @param term [Term, #to_s] in unexpanded form
  # @return [String]
  #
  # source://json-ld//lib/json/ld/context.rb#1243
  def direction(term); end

  # Duplicate an active context, allowing it to be modified.
  #
  # source://json-ld//lib/json/ld/context.rb#1763
  def dup; end

  # Initial context, without mappings, vocab or default language
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#861
  def empty?; end

  # Expand an IRI. Relative IRIs are expanded against any document base.
  #
  # @param as_string [Boolean] (false) transform RDF::Resource values to string
  # @param base [String, RDF::URI] for resolving document-relative IRIs
  # @param defined [Hash] Used during Context Processing.
  # @param documentRelative [Boolean] (false)
  # @param local_context [Hash] Used during Context Processing.
  # @param options [Hash{Symbol => Object}]
  # @param value [String] A keyword, term, prefix:suffix or possibly relative IRI
  # @param vocab [Boolean] (false)
  # @raise [JSON::LD::JsonLdError::InvalidIRIMapping] if the value cannot be expanded
  # @return [RDF::Resource, String] IRI or String, if it's a keyword
  # @see https://www.w3.org/TR/json-ld11-api/#iri-expansion
  #
  # source://json-ld//lib/json/ld/context.rb#1301
  def expand_iri(value, as_string: T.unsafe(nil), base: T.unsafe(nil), defined: T.unsafe(nil), documentRelative: T.unsafe(nil), local_context: T.unsafe(nil), vocab: T.unsafe(nil), **_options); end

  # If active property has a type mapping in the active context set to @id or @vocab, a JSON object with a single member @id whose value is the result of using the IRI Expansion algorithm on value is returned.
  #
  # Otherwise, the result will be a JSON object containing an @value member whose value is the passed value. Additionally, an @type member will be included if there is a type mapping associated with the active property or an @language member if value is a string and there is language mapping associated with the active property.
  #
  # @param base [String, RDF::URI] for resolving document-relative IRIs
  # @param options [Hash{Symbol => Object}]
  # @param property [String] Associated property used to find coercion rules
  # @param rdfDirection [Boolean] (nil) decode i18n datatype if i18n-datatype
  # @param useNativeTypes [Boolean] (false) use native representations
  # @param value [Hash, String] Value (literal or IRI) to be expanded
  # @raise [RDF::ReaderError] if the iri cannot be expanded
  # @return [Hash] Object representation of value
  # @see https://www.w3.org/TR/json-ld11-api/#value-expansion
  #
  # source://json-ld//lib/json/ld/context.rb#1612
  def expand_value(property, value, useNativeTypes: T.unsafe(nil), rdfDirection: T.unsafe(nil), base: T.unsafe(nil), **_options); end

  # Find a term definition
  #
  # @param term [Term, #to_s] in unexpanded form
  # @return [Term]
  #
  # source://json-ld//lib/json/ld/context.rb#1149
  def find_definition(term); end

  # Build a context from an RDF::Vocabulary definition.
  #
  # @example building from an external vocabulary definition
  #
  #   g = RDF::Graph.load("http://schema.org/docs/schema_org_rdfa.html")
  #
  #   context = JSON::LD::Context.new.from_vocabulary(g,
  #   vocab: "http://schema.org/",
  #   prefixes: {schema: "http://schema.org/"},
  #   language: "en")
  # @note requires rdf/vocab gem.
  # @param graph [RDF::Queryable]
  # @return [self]
  #
  # source://json-ld//lib/json/ld/context.rb#1062
  def from_vocabulary(graph); end

  # source://json-ld//lib/json/ld/context.rb#1750
  def inspect; end

  # @return [Hash{RDF::URI => String}] Reverse mappings from IRI to term only for terms, not CURIEs XXX
  #
  # source://json-ld//lib/json/ld/context.rb#67
  def iri_to_term; end

  # @return [Hash{RDF::URI => String}] Reverse mappings from IRI to term only for terms, not CURIEs XXX
  #
  # source://json-ld//lib/json/ld/context.rb#67
  def iri_to_term=(_arg0); end

  # Retrieve the language associated with a term, or the default language otherwise
  #
  # @param term [Term, #to_s] in unexpanded form
  # @return [String]
  #
  # source://json-ld//lib/json/ld/context.rb#1229
  def language(term); end

  # Merge in a context, creating a new context with updates from `context`
  #
  # @param context [Context]
  # @param override_protected [Boolean] Allow or disallow protected terms to be changed
  # @return [Context]
  #
  # source://json-ld//lib/json/ld/context.rb#459
  def merge(context, override_protected: T.unsafe(nil)); end

  # @return [BlankNodeNamer]
  #
  # source://json-ld//lib/json/ld/context.rb#100
  def namer; end

  # @return [BlankNodeNamer]
  #
  # source://json-ld//lib/json/ld/context.rb#100
  def namer=(_arg0); end

  # Retrieve nest of a term.
  # value of nest must be @nest or a term that resolves to @nest
  #
  # @param term [Term, #to_s] in unexpanded form
  # @raise JsonLdError::InvalidNestValue if nesting term exists and is not a term resolving to `@nest` in the current context.
  # @return [String] Nesting term
  #
  # source://json-ld//lib/json/ld/context.rb#1208
  def nest(term); end

  # @return [Hash{Symbol => Object}] Global options used in generating IRIs
  #
  # source://json-ld//lib/json/ld/context.rb#97
  def options; end

  # @return [Hash{Symbol => Object}] Global options used in generating IRIs
  #
  # source://json-ld//lib/json/ld/context.rb#97
  def options=(_arg0); end

  # Create an Evaluation Context
  #
  # When processing a JSON-LD data structure, each processing rule is applied using information provided by the active context. This section describes how to produce an active context.
  #
  # The active context contains the active term definitions which specify how properties and values have to be interpreted as well as the current base IRI, the vocabulary mapping and the default language. Each term definition consists of an IRI mapping, a boolean flag reverse property, an optional type mapping or language mapping, and an optional container mapping. A term definition can not only be used to map a term to an IRI, but also to map a term to a keyword, in which case it is referred to as a keyword alias.
  #
  # When processing, the active context is initialized without any term definitions, vocabulary mapping, or default language. If a local context is encountered during processing, a new active context is created by cloning the existing active context. Then the information from the local context is merged into the new active context. Given that local contexts may contain references to remote contexts, this includes their retrieval.
  #
  # @param base [String, #to_s] The Base IRI to use when expanding the document. This overrides the value of `input` if it is a _IRI_. If not specified and `input` is not an _IRI_, the base IRI defaults to the current document IRI if in a browser context, or the empty string if there is no document context.
  # @param local_context [String, #read, Array, Hash, Context]
  # @param override_protected [Boolean] Protected terms may be cleared.
  # @param propagate [Boolean] (true)
  #   If false, retains any previously defined term, which can be rolled back when the descending into a new node object changes.
  # @param remote_contexts [Array<String>] ([])
  # @param validate_scoped [Boolean] (true).
  #   Validate scoped context, loading if necessary.
  #   If false, do not load scoped contexts.
  # @raise [JsonLdError] on a remote context load error, syntax error, or a reference to a term which is not defined.
  # @return [Context]
  # @see https://www.w3.org/TR/json-ld11-api/index.html#context-processing-algorithm
  #
  # source://json-ld//lib/json/ld/context.rb#243
  def parse(local_context, base: T.unsafe(nil), override_protected: T.unsafe(nil), propagate: T.unsafe(nil), remote_contexts: T.unsafe(nil), validate_scoped: T.unsafe(nil)); end

  # Previous definition for this context. This is used for rolling back type-scoped contexts.
  #
  # @return [Context]
  #
  # source://json-ld//lib/json/ld/context.rb#71
  def previous_context; end

  # Previous definition for this context. This is used for rolling back type-scoped contexts.
  #
  # @return [Context]
  #
  # source://json-ld//lib/json/ld/context.rb#71
  def previous_context=(_arg0); end

  # Retrieve, or check processing mode.
  #
  # * With no arguments, retrieves the current set processingMode.
  # * With an argument, verifies that the processingMode is at least that provided, either as an integer, or a string of the form "json-ld-1.x"
  # * If expecting 1.1, and not set, it has the side-effect of setting mode to json-ld-1.1.
  #
  # @param expected [String, Number] (nil)
  # @return [String]
  #
  # source://json-ld//lib/json/ld/context.rb#921
  def processingMode(expected = T.unsafe(nil)); end

  # Set processing mode.
  #
  # * With an argument, verifies that the processingMode is at least that provided, either as an integer, or a string of the form "json-ld-1.x"
  #
  # If contex has a @version member, it's value MUST be 1.1, otherwise an "invalid @version value" has been detected, and processing is aborted.
  # If processingMode has been set, and it is not "json-ld-1.1", a "processing mode conflict" has been detecting, and processing is aborted.
  #
  # @param value [String, Number]
  # @raise [JsonLdError::ProcessingModeConflict]
  # @return [String]
  #
  # source://json-ld//lib/json/ld/context.rb#945
  def processingMode=(value = T.unsafe(nil), **_options); end

  # Set propagation
  # @note: by the time this is called, the work has already been done.
  #
  # @param value [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#986
  def propagate=(value, **_options); end

  # Context is property-scoped
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#75
  def property_scoped; end

  # Context is property-scoped
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#75
  def property_scoped=(_arg0); end

  # Is this a reverse term
  #
  # @param term [Term, #to_s] in unexpanded form
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#1257
  def reverse?(term); end

  # Given a term or IRI, find a reverse term definition matching that term. If the term is already reversed, find a non-reversed version.
  #
  # @param term [Term, #to_s]
  # @return [Term] related term definition
  #
  # source://json-ld//lib/json/ld/context.rb#1267
  def reverse_term(term); end

  # Generate @context
  #
  # If a context was supplied in global options, use that, otherwise, generate one
  # from this representation.
  #
  # @param options [Hash{Symbol => Object}] ({})
  # @param provided_context [Array, Hash, Context, IO, StringIO] (nil)
  #   Original context to use, if available
  # @return [Hash]
  #
  # source://json-ld//lib/json/ld/context.rb#1010
  def serialize(provided_context: T.unsafe(nil), **_options); end

  # Set term mapping
  #
  # @param term [#to_s]
  # @param value [RDF::URI, String, nil]
  # @return [TermDefinition]
  #
  # source://json-ld//lib/json/ld/context.rb#1130
  def set_mapping(term, value); end

  # Term definitions
  #
  # @return [Hash{String => TermDefinition}]
  #
  # source://json-ld//lib/json/ld/context.rb#64
  def term_definitions; end

  # Turn this into a source for a new instantiation
  #
  # @param aliases [Array<String>] Other URLs to alias when preloading
  # @return [String]
  #
  # source://json-ld//lib/json/ld/context.rb#1727
  def to_rb(*aliases); end

  # Default vocabulary
  #
  # Sets the default vocabulary used for expanding terms which
  # aren't otherwise absolute IRIs
  #
  # @return [RDF::URI]
  #
  # source://json-ld//lib/json/ld/context.rb#94
  def vocab; end

  # If context has a @vocab member: if its value is not a valid absolute IRI or null trigger an INVALID_VOCAB_MAPPING error; otherwise set the active context's vocabulary mapping to its value and remove the @vocab member from context.
  #
  # @param value [String] must be an absolute IRI
  #
  # source://json-ld//lib/json/ld/context.rb#961
  def vocab=(value, **_options); end

  protected

  # Reverse term mapping, typically used for finding aliases for keys.
  #
  # Returns either the original value, or a mapping for this value.
  #
  # @example
  #   {"@context": {"id": "@id"}, "@id": "foo"} => {"id": "foo"}
  # @param value [RDF::URI, String]
  # @return [String]
  #
  # source://json-ld//lib/json/ld/context.rb#1802
  def alias(value); end

  # Determine if `term` is a suitable term.
  # Term may be any valid JSON string.
  #
  # @param term [String]
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#1789
  def term_valid?(term); end

  private

  # Keep track of allocated BNodes
  #
  # Don't actually use the name provided, to prevent name alias issues.
  #
  # @return [RDF::Node]
  #
  # source://json-ld//lib/json/ld/context.rb#1843
  def bnode(value = T.unsafe(nil)); end

  # Ensure @container mapping is appropriate
  # The result is the original container definition. For IRI containers, this is necessary to be able to determine the @type mapping for string values
  #
  # source://json-ld//lib/json/ld/context.rb#2038
  def check_container(container, _local_context, _defined, term); end

  # Inverse Context creation
  #
  # When there is more than one term that could be chosen to compact an IRI, it has to be ensured that the term selection is both deterministic and represents the most context-appropriate choice whilst taking into consideration algorithmic complexity.
  #
  # In order to make term selections, the concept of an inverse context is introduced. An inverse context is essentially a reverse lookup table that maps container mappings, type mappings, and language mappings to a simple term for a given active context. A inverse context only needs to be generated for an active context if it is being used for compaction.
  #
  # To make use of an inverse context, a list of preferred container mappings and the type mapping or language mapping are gathered for a particular value associated with an IRI. These parameters are then fed to the Term Selection algorithm, which will find the term that most appropriately matches the value's mappings.
  #
  # @example Basic structure of resulting inverse context
  #   {
  #   "http://example.com/term": {
  #   "@language": {
  #   "@null": "term",
  #   "@none": "term",
  #   "en": "term",
  #   "ar_rtl": "term"
  #   },
  #   "@type": {
  #   "@reverse": "term",
  #   "@none": "term",
  #   "http://datatype": "term"
  #   },
  #   "@any": {
  #   "@none": "term",
  #   }
  #   }
  #   }
  # @return [Hash{String => Hash{String => String}}]
  # @todo May want to include @set along with container to allow selecting terms using @set over those without @set. May require adding some notion of value cardinality to compact_iri
  #
  # source://json-ld//lib/json/ld/context.rb#1878
  def inverse_context; end

  # Used for testing
  # Retrieve language mappings
  #
  # @deprecated
  # @return [Array<String>]
  #
  # source://json-ld//lib/json/ld/context.rb#2028
  def languages; end

  # Reads the `@context` from an IO
  #
  # source://json-ld//lib/json/ld/context.rb#1816
  def load_context(io, **options); end

  # Used for testing
  # Retrieve term mapping
  #
  # @param term [String, #to_s]
  # @return [RDF::URI, String]
  #
  # source://json-ld//lib/json/ld/context.rb#2019
  def mapping(term); end

  # Used for testing
  # Retrieve term mappings
  #
  # @return [Array<RDF::URI>]
  #
  # source://json-ld//lib/json/ld/context.rb#2005
  def mappings; end

  # Removes a base IRI from the given absolute IRI.
  #
  # @param base [String] the base used for making `iri` relative
  # @param iri [String] the absolute IRI
  # @return [String] the relative IRI if relative to base, otherwise the absolute IRI.
  #
  # source://json-ld//lib/json/ld/context.rb#1980
  def remove_base(base, iri); end

  # This algorithm, invoked via the IRI Compaction algorithm, makes use of an active context's inverse context to find the term that is best used to compact an IRI. Other information about a value associated with the IRI is given, including which container mappings and which type mapping or language mapping would be best used to express the value.
  #
  # @param containers [Array<String>] represents an ordered list of preferred container mappings
  # @param iri [String]
  # @param preferred_values [Array<String>] for the type mapping or language mapping
  # @param type_language [String] indicates whether to look for a term with a matching type mapping or language mapping
  # @return [String]
  #
  # source://json-ld//lib/json/ld/context.rb#1948
  def select_term(iri, containers, type_language, preferred_values); end

  # source://json-ld//lib/json/ld/context.rb#1826
  def uri(value); end

  class << self
    # Add preloaded context. In the block form, the context is lazy evaulated on first use.
    #
    # @param context [Context] (nil)
    # @param url [String, RDF::URI]
    # @yieldreturn [Context]
    #
    # source://json-ld//lib/json/ld/context.rb#34
    def add_preloaded(url, context = T.unsafe(nil), &block); end

    # Alias a previousliy loaded context
    #
    # @param a [String, RDF::URI]
    # @param url [String, RDF::URI]
    #
    # source://json-ld//lib/json/ld/context.rb#42
    def alias_preloaded(a, url); end

    # Class-level cache used for retaining parsed remote contexts.
    #
    # @private
    # @return [RDF::Util::Cache]
    #
    # source://json-ld//lib/json/ld/context.rb#138
    def cache; end

    # Class-level cache inverse contexts.
    #
    # @private
    # @return [RDF::Util::Cache]
    #
    # source://json-ld//lib/json/ld/context.rb#147
    def inverse_cache; end

    # Allow caching of well-known contexts
    #
    # @private
    #
    # source://json-ld//lib/json/ld/context.rb#154
    def new(**options); end

    # Create a new context by parsing a context.
    #
    # @param base [String, #to_s] (nil)
    #   The Base IRI to use when expanding the document. This overrides the value of `input` if it is a _IRI_. If not specified and `input` is not an _IRI_, the base IRI defaults to the current document IRI if in a browser context, or the empty string if there is no document context.
    # @param local_context [String, #read, Array, Hash, Context]
    # @param override_protected [Boolean] (false)
    #   Protected terms may be cleared.
    # @param propagate [Boolean] (true)
    #   If false, retains any previously defined term, which can be rolled back when the descending into a new node object changes.
    # @raise [JsonLdError] on a remote context load error, syntax error, or a reference to a term which is not defined.
    # @return [Context]
    # @see #initialize
    # @see #parse
    #
    # source://json-ld//lib/json/ld/context.rb#117
    def parse(local_context, base: T.unsafe(nil), override_protected: T.unsafe(nil), propagate: T.unsafe(nil), **options); end
  end
end

# Defines the maximum number of interned URI references that can be held
# cached in memory at any one time.
#
# source://json-ld//lib/json/ld/context.rb#26
JSON::LD::Context::CACHE_SIZE = T.let(T.unsafe(nil), Integer)

# The following constants are used to reduce object allocations in #compact_iri below
#
# source://json-ld//lib/json/ld/context.rb#1387
JSON::LD::Context::CONTAINERS_GRAPH = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1388
JSON::LD::Context::CONTAINERS_GRAPH_INDEX = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1389
JSON::LD::Context::CONTAINERS_GRAPH_INDEX_INDEX = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1390
JSON::LD::Context::CONTAINERS_GRAPH_SET = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1391
JSON::LD::Context::CONTAINERS_ID_TYPE = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1392
JSON::LD::Context::CONTAINERS_ID_VOCAB = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1393
JSON::LD::Context::CONTAINERS_INDEX_SET = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1394
JSON::LD::Context::CONTAINERS_LANGUAGE = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1395
JSON::LD::Context::CONTAINERS_VALUE = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1396
JSON::LD::Context::CONTAINERS_VOCAB_ID = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1811
JSON::LD::Context::CONTEXT_BASE_FRAG_OR_QUERY = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/context.rb#1808
JSON::LD::Context::CONTEXT_CONTAINER_ARRAY_TERMS = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/context.rb#1809
JSON::LD::Context::CONTEXT_CONTAINER_ID_GRAPH = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/context.rb#1810
JSON::LD::Context::CONTEXT_CONTAINER_INDEX_GRAPH = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/context.rb#1812
JSON::LD::Context::CONTEXT_TYPE_ID_VOCAB = T.let(T.unsafe(nil), Array)

# The following constants are used to reduce object allocations in #create_term_definition below
#
# source://json-ld//lib/json/ld/context.rb#483
JSON::LD::Context::ID_NULL_OBJECT = T.let(T.unsafe(nil), Hash)

# Initial contexts, defined on first access
#
# source://json-ld//lib/json/ld/context.rb#21
JSON::LD::Context::INITIAL_CONTEXTS = T.let(T.unsafe(nil), Hash)

# source://json-ld//lib/json/ld/context.rb#485
JSON::LD::Context::JSON_LD_10_EXPECTED_KEYS = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/context.rb#488
JSON::LD::Context::JSON_LD_10_TYPE_VALUES = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/context.rb#486
JSON::LD::Context::JSON_LD_11_EXPECTED_KEYS = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/context.rb#489
JSON::LD::Context::JSON_LD_11_TYPE_VALUES = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/context.rb#487
JSON::LD::Context::JSON_LD_EXPECTED_KEYS = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/context.rb#484
JSON::LD::Context::NON_TERMDEF_KEYS = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/context.rb#490
JSON::LD::Context::PREFIX_URI_ENDINGS = T.let(T.unsafe(nil), Set)

# Preloaded contexts.
# To avoid runtime context parsing and downloading, contexts may be pre-loaded by implementations.
#
# @return [Hash{Symbol => Context}]
#
# source://json-ld//lib/json/ld/context.rb#18
JSON::LD::Context::PRELOADED = T.let(T.unsafe(nil), Hash)

# Term Definitions specify how properties and values have to be interpreted as well as the current vocabulary mapping and the default language
#
# source://json-ld//lib/json/ld/context.rb#2103
class JSON::LD::Context::TermDefinition
  # Create a new Term Mapping with an ID
  #
  # @param container_mapping [Set<'@index', '@language', '@index', '@set', '@type', '@id', '@graph'>]
  # @param direction_mapping ["ltr", "rtl"] Direction mapping of term, `false` is used if there is an explicit direction mapping for this term
  # @param id [String]
  # @param language_mapping [String] Language mapping of term, `false` is used if there is an explicit language mapping for this term
  # @param nest [String] term used for nest properties
  # @param prefix [Boolean] Term may be used as a prefix
  # @param protected [Boolean] mark resulting context as protected
  # @param reverse_property [Boolean]
  # @param simple [Boolean] This is a simple term definition, not an expanded term definition
  # @param term [String]
  # @param type_mapping [String] Type mapping
  # @return [TermDefinition] a new instance of TermDefinition
  #
  # source://json-ld//lib/json/ld/context.rb#2178
  def initialize(term, id: T.unsafe(nil), index: T.unsafe(nil), type_mapping: T.unsafe(nil), container_mapping: T.unsafe(nil), language_mapping: T.unsafe(nil), direction_mapping: T.unsafe(nil), reverse_property: T.unsafe(nil), nest: T.unsafe(nil), protected: T.unsafe(nil), simple: T.unsafe(nil), prefix: T.unsafe(nil), context: T.unsafe(nil)); end

  # Check if term definitions are identical, modulo @protected
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#2317
  def ==(other); end

  # If container mapping was defined along with @set
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#2311
  def as_set?; end

  # Base container mapping, without @set
  #
  # @return [Array<'@index', '@language', '@index', '@set', '@type', '@id', '@graph'>] Container mapping
  #
  # source://json-ld//lib/json/ld/context.rb#2115
  def container_mapping; end

  # Set container mapping, from an array which may include @set
  #
  # source://json-ld//lib/json/ld/context.rb#2229
  def container_mapping=(mapping); end

  # Term-specific context
  #
  # @return [Hash{String => Object}]
  #
  # source://json-ld//lib/json/ld/context.rb#2144
  def context; end

  # Term-specific context
  #
  # @return [Hash{String => Object}]
  #
  # source://json-ld//lib/json/ld/context.rb#2144
  def context=(_arg0); end

  # Direction of term, `false` is used if there is explicit direction mapping mapping for this term.
  #
  # @return ["ltr", "rtl"] direction_mapping
  #
  # source://json-ld//lib/json/ld/context.rb#2126
  def direction_mapping; end

  # Direction of term, `false` is used if there is explicit direction mapping mapping for this term.
  #
  # @return ["ltr", "rtl"] direction_mapping
  #
  # source://json-ld//lib/json/ld/context.rb#2126
  def direction_mapping=(_arg0); end

  # @return [RDF::URI] IRI map
  #
  # source://json-ld//lib/json/ld/context.rb#2105
  def id; end

  # @return [RDF::URI] IRI map
  #
  # source://json-ld//lib/json/ld/context.rb#2105
  def id=(_arg0); end

  # Property used for data indexing; defaults to @index
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#2137
  def index; end

  # Property used for data indexing; defaults to @index
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#2137
  def index=(_arg0); end

  # source://json-ld//lib/json/ld/context.rb#2333
  def inspect; end

  # Language mapping of term, `false` is used if there is an explicit language mapping for this term.
  #
  # @return [String] Language mapping
  #
  # source://json-ld//lib/json/ld/context.rb#2122
  def language_mapping; end

  # Language mapping of term, `false` is used if there is an explicit language mapping for this term.
  #
  # @return [String] Language mapping
  #
  # source://json-ld//lib/json/ld/context.rb#2122
  def language_mapping=(_arg0); end

  # Returns true if the term matches a compact IRI
  #
  # @param iri [String] the compact IRI
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#2224
  def match_compact_iri?(iri); end

  # Returns true if the term matches a IRI
  #
  # @param iri [String] the IRI
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#2216
  def match_iri?(iri); end

  # @return [String] Term used for nest properties
  #
  # source://json-ld//lib/json/ld/context.rb#2118
  def nest; end

  # @return [String] Term used for nest properties
  #
  # source://json-ld//lib/json/ld/context.rb#2118
  def nest=(_arg0); end

  # Indicate that term may be used as a prefix
  #
  # source://json-ld//lib/json/ld/context.rb#2140
  def prefix=(_arg0); end

  # This is an appropriate term to use as the prefix of a compact IRI
  #
  # @return [Boolean] simple
  #
  # source://json-ld//lib/json/ld/context.rb#2158
  def prefix?; end

  # Term is protected.
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#2148
  def protected=(_arg0); end

  # Term is protected.
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#2208
  def protected?; end

  # @return [Boolean] Reverse Property
  #
  # source://json-ld//lib/json/ld/context.rb#2129
  def reverse_property; end

  # @return [Boolean] Reverse Property
  #
  # source://json-ld//lib/json/ld/context.rb#2129
  def reverse_property=(_arg0); end

  # This is a simple term definition, not an expanded term definition
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#2133
  def simple; end

  # This is a simple term definition, not an expanded term definition
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/context.rb#2133
  def simple=(_arg0); end

  # This is a simple term definition, not an expanded term definition
  #
  # @return [Boolean] simple
  #
  # source://json-ld//lib/json/ld/context.rb#2152
  def simple?; end

  # @return [String] term name
  #
  # source://json-ld//lib/json/ld/context.rb#2108
  def term; end

  # @return [String] term name
  #
  # source://json-ld//lib/json/ld/context.rb#2108
  def term=(_arg0); end

  # Output Hash or String definition for this definition considering @language and @vocab
  #
  # @param context [Context]
  # @return [String, Hash{String => Array[String], String}]
  #
  # source://json-ld//lib/json/ld/context.rb#2251
  def to_context_definition(context); end

  # Turn this into a source for a new instantiation
  # FIXME: context serialization
  #
  # @return [String]
  #
  # source://json-ld//lib/json/ld/context.rb#2293
  def to_rb; end

  # @return [String] Type mapping
  #
  # source://json-ld//lib/json/ld/context.rb#2111
  def type_mapping; end

  # @return [String] Type mapping
  #
  # source://json-ld//lib/json/ld/context.rb#2111
  def type_mapping=(_arg0); end

  private

  # source://json-ld//lib/json/ld/context.rb#2354
  def prefix_colon; end
end

# Default context when compacting without one being specified
#
# source://json-ld//lib/json/ld.rb#47
JSON::LD::DEFAULT_CONTEXT = T.let(T.unsafe(nil), String)

# Expand module, used as part of API
#
# source://json-ld//lib/json/ld/expand.rb#9
module JSON::LD::Expand
  include ::JSON::LD::Utils

  # Expand an Array or Object given an active context and performing local context expansion.
  #
  # @param active_property [String]
  # @param context [Context]
  # @param framing [Boolean] (false)
  #   Special rules for expanding a frame
  # @param from_map [Boolean] Expanding from a map, which could be an `@type` map, so don't clear out context term definitions
  # @param input [Array, Hash]
  # @return [Array<Hash{String => Object}>]
  #
  # source://json-ld//lib/json/ld/expand.rb#31
  def expand(input, active_property, context, framing: T.unsafe(nil), from_map: T.unsafe(nil), log_depth: T.unsafe(nil)); end

  private

  # Expand each key and value of element adding them to result
  #
  # source://json-ld//lib/json/ld/expand.rb#246
  def expand_object(input, active_property, context, output_object, expanded_active_property:, framing:, type_key:, type_scoped_context:, log_depth: T.unsafe(nil)); end
end

# The following constant is used to reduce object allocations
#
# source://json-ld//lib/json/ld/expand.rb#13
JSON::LD::Expand::CONTAINER_INDEX_ID_TYPE = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld/expand.rb#17
JSON::LD::Expand::KEYS_INCLUDED_TYPE_REVERSE = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/expand.rb#16
JSON::LD::Expand::KEYS_SET_LIST_INDEX = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/expand.rb#15
JSON::LD::Expand::KEYS_VALUE_LANGUAGE_TYPE_INDEX_DIRECTION = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/expand.rb#14
JSON::LD::Expand::KEY_ID = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/flatten.rb#7
module JSON::LD::Flatten
  include ::JSON::LD::Utils

  # Create annotations
  #
  # Updates a node map from which annotations have been folded into embedded triples to re-extract the annotations.
  #
  # Map entries where the key is of the form of a canonicalized JSON object are used to find keys with the `@id` and property components. If found, the original map entry is removed and entries added to an `@annotation` property of the associated value.
  #
  # * Keys which are of the form of a canonicalized JSON object are examined in inverse order of length.
  # * Deserialize the key into a map, and re-serialize the value of `@id`.
  # * If the map contains an entry with that value (after re-canonicalizing, as appropriate), and the associated antry has a item which matches the non-`@id` item from the map, the node is used to create an `@annotation` entry within that value.
  #
  # @param node_map [Hash{String => Hash}]
  # @return [Hash{String => Hash}]
  #
  # source://json-ld//lib/json/ld/flatten.rb#216
  def create_annotations(node_map); end

  # This algorithm creates a JSON object node map holding an indexed representation of the graphs and nodes represented in the passed expanded document. All nodes that are not uniquely identified by an IRI get assigned a (new) blank node identifier. The resulting node map will have a member for every graph in the document whose value is another object with a member for every node represented in the document. The default graph is stored under the @default member, all other graphs are stored under their graph name.
  #
  # For RDF-star/JSON-LD-star:
  #   * Values of `@id` can be an object (embedded node); when these are used as keys in a Node Map, they are serialized as canonical JSON, and de-serialized when flattening.
  #   * The presence of `@annotation` implies an embedded node and the annotation object is removed from the node/value object in which it appears.
  #
  # @param active_graph [String] The name of the currently active graph that the processor should use when processing.
  # @param active_property [String] (nil)
  #   Property within current node
  # @param active_subject [String] (nil)
  #   Node identifier
  # @param element [Array, Hash] Expanded JSON-LD input
  # @param graph_map [Hash] A map of graph name to subjects
  # @param list [Array] (nil)
  #   Used when property value is a list
  # @param reverse [Boolean] (false)
  #   Processing a reverse relationship
  #
  # source://json-ld//lib/json/ld/flatten.rb#30
  def create_node_map(element, graph_map, active_graph: T.unsafe(nil), active_subject: T.unsafe(nil), active_property: T.unsafe(nil), reverse: T.unsafe(nil), list: T.unsafe(nil)); end

  # Rename blank nodes recursively within an embedded object
  #
  # @param node [Object]
  # @return [Hash]
  #
  # source://json-ld//lib/json/ld/flatten.rb#253
  def rename_bnodes(node); end

  private

  # Merge nodes from all graphs in the graph_map into a new node map
  #
  # @param graph_map [Hash{String => Hash}]
  # @return [Hash]
  #
  # source://json-ld//lib/json/ld/flatten.rb#274
  def merge_node_map_graphs(graph_map); end
end

# JSON-LD format specification.
#
# @example Obtaining an JSON-LD format class
#   RDF::Format.for(:jsonld)           #=> JSON::LD::Format
#   RDF::Format.for("etc/foaf.jsonld")
#   RDF::Format.for(:file_name         => "etc/foaf.jsonld")
#   RDF::Format.for(file_extension: "jsonld")
#   RDF::Format.for(:content_type   => "application/ld+json")
# @example Obtaining serialization format MIME types
#   RDF::Format.content_types      #=> {"application/ld+json" => [JSON::LD::Format],
#   "application/x-ld+json" => [JSON::LD::Format]}
# @example Obtaining serialization format file extension mappings
#   RDF::Format.file_extensions    #=> {:jsonld => [JSON::LD::Format] }
# @see https://w3c.github.io/json-ld-api/tests/
# @see https://www.w3.org/TR/json-ld11/
#
# source://json-ld//lib/json/ld/format.rb#24
class JSON::LD::Format < ::RDF::Format
  class << self
    # Hash of CLI commands appropriate for this format:
    #
    # * `expand` => {JSON::LD::API.expand}
    # * `compact` => {JSON::LD::API.compact}
    # * `flatten` => {JSON::LD::API.flatten}
    # * `frame` => {JSON::LD::API.frame}
    #
    # @return [Hash{Symbol => Hash}]
    #
    # source://json-ld//lib/json/ld/format.rb#124
    def cli_commands; end

    # Execute the body of a CLI command, generic for each different API method based on definitions on {LD_FORMATS}.
    #
    # Expands the input, or transforms from an RDF format based on the `:format` option, and then executes the appropriate command based on `:output_format` and does appropriate output serialization.
    #
    # @private
    #
    # source://json-ld//lib/json/ld/format.rb#83
    def cli_exec(command, files, output: T.unsafe(nil), **options); end

    # Sample detection to see if it matches JSON-LD
    #
    # Use a text sample to detect the format of an input file. Sub-classes implement
    # a matcher sufficient to detect probably format matches, including disambiguating
    # between other similar formats.
    #
    # @param sample [String] Beginning several bytes (~ 1K) of input.
    # @return [Boolean]
    #
    # source://json-ld//lib/json/ld/format.rb#43
    def detect(sample); end

    # Override normal format name
    #
    # source://json-ld//lib/json/ld/format.rb#218
    def name; end

    # Override normal symbol generation
    #
    # source://json-ld//lib/json/ld/format.rb#212
    def to_sym; end
  end
end

# Specify how to execute CLI commands for each supported format.
# Derived formats (e.g., YAML-LD) define their own entrypoints.
#
# source://json-ld//lib/json/ld/format.rb#51
JSON::LD::Format::LD_FORMATS = T.let(T.unsafe(nil), Hash)

# source://json-ld//lib/json/ld/frame.rb#7
module JSON::LD::Frame
  include ::JSON::LD::Utils

  # Replace `@null` with `null`, removing it from arrays.
  #
  # @param input [Array, Hash]
  # @return [Array, Hash]
  #
  # source://json-ld//lib/json/ld/frame.rb#296
  def cleanup_null(input); end

  # Replace @preserve keys with the values, also replace @null with null.
  #
  # @param input [Array, Hash]
  # @return [Array, Hash]
  #
  # source://json-ld//lib/json/ld/frame.rb#273
  def cleanup_preserve(input); end

  # Recursively find and count blankNode identifiers.
  #
  # @return [Hash{String => Integer}]
  #
  # source://json-ld//lib/json/ld/frame.rb#220
  def count_blank_node_identifiers(input); end

  # source://json-ld//lib/json/ld/frame.rb#226
  def count_blank_node_identifiers_internal(input, results); end

  # Frame input. Input is expected in expanded form, but frame is in compacted form.
  #
  # @param frame [Hash{String => Object}]
  # @param options [Hash{Symbol => Object}] ({})
  # @param ordered [Boolean] (true)
  #   Ensure output objects have keys ordered properly
  # @param parent [Hash{String => Object}] (nil)
  #   Parent subject or top-level array
  # @param property [String] (nil)
  #   The parent property.
  # @param state [Hash{Symbol => Object}] Current framing state
  # @param subjects [Array<String>] The subjects to filter
  # @raise [JSON::LD::InvalidFrame]
  #
  # source://json-ld//lib/json/ld/frame.rb#26
  def frame(state, subjects, frame, parent: T.unsafe(nil), property: T.unsafe(nil), ordered: T.unsafe(nil), **options); end

  # Prune BNode identifiers recursively
  #
  # @param bnodes_to_clear [Array<String>]
  # @param input [Array, Hash]
  # @return [Array, Hash]
  #
  # source://json-ld//lib/json/ld/frame.rb#248
  def prune_bnodes(input, bnodes_to_clear); end

  private

  # Adds framing output to the given parent.
  #
  # @param output the output to add.
  # @param parent the parent to add to.
  # @param property the parent property, null for an array parent.
  #
  # source://json-ld//lib/json/ld/frame.rb#570
  def add_frame_output(parent, property, output); end

  # Creates an implicit frame when recursing through subject matches. If a frame doesn't have an explicit frame for a particular property, then a wildcard child frame will be created that uses the same flags that the parent frame used.
  #
  # @param flags [Hash] the current framing flags.
  # @return [Array<Hash>] the implicit frame.
  #
  # source://json-ld//lib/json/ld/frame.rb#583
  def create_implicit_frame(flags); end

  # Checks the current subject stack to see if embedding the given subject would cause a circular reference.
  #
  # @param graph the graph the subject to embed is in.
  # @param subject_stack the current stack of subjects.
  # @param subject_to_embed the subject to embed.
  # @return true if a circular reference would be created, false if not.
  #
  # source://json-ld//lib/json/ld/frame.rb#486
  def creates_circular_reference(subject_to_embed, graph, subject_stack); end

  # Returns true if the given node matches the given frame.
  #
  # Matches either based on explicit type inclusion where the node has any type listed in the frame. If the frame has empty types defined matches nodes not having a @type. If the frame has a type of {} defined matches nodes having any type defined.
  #
  # Otherwise, does duck typing, where the node must have any or all of the properties defined in the frame, depending on the `requireAll` flag.
  #
  # @param flags [Hash{Symbol => Object}] the frame flags.
  # @param frame [Hash{String => Object}] the frame to check.
  # @param state [Hash{Symbol => Object}] Current framing state
  # @param subject [Hash{String => Object}] the subject to check.
  # @return [Boolean] true if the node matches, false if not.
  #
  # source://json-ld//lib/json/ld/frame.rb#346
  def filter_subject(subject, frame, state, flags); end

  # Returns a map of all of the subjects that match a parsed frame.
  #
  # @param flags [Hash{Symbol => String}] the frame flags.
  # @param frame [Hash{String => Object}]
  # @param state [Hash{Symbol => Object}] Current framing state
  # @param subjects [Array<String>] The subjects to filter
  # @return all of the matched subjects.
  #
  # source://json-ld//lib/json/ld/frame.rb#326
  def filter_subjects(state, subjects, frame, flags); end

  # Gets the frame flag value for the given flag name.
  #
  # @param frame the frame.
  # @param name the flag name.
  # @param options the framing options.
  # @return the flag value.
  #
  # source://json-ld//lib/json/ld/frame.rb#500
  def get_frame_flag(frame, options, name); end

  # Node matches if it is a node, and matches the pattern as a frame
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/frame.rb#592
  def node_match?(pattern, value, state, flags); end

  # Removes an existing embed.
  #
  # @param id the @id of the embed to remove.
  # @param state the current framing state.
  #
  # source://json-ld//lib/json/ld/frame.rb#521
  def remove_embed(state, id); end

  # source://json-ld//lib/json/ld/frame.rb#459
  def validate_frame(frame); end

  # Value matches if it is a value, and matches the value pattern.
  #
  # * `pattern` is empty
  # * @values are the same, or `pattern[@value]` is a wildcard, and
  # * @types are the same or `value[@type]` is not null and `pattern[@type]` is `{}`, or `value[@type]` is null and `pattern[@type]` is null or `[]`, and
  # * @languages are the same or `value[@language]` is not null and `pattern[@language]` is `{}`, or `value[@language]` is null and `pattern[@language]` is null or `[]`.
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/frame.rb#605
  def value_match?(pattern, value); end
end

# source://json-ld//lib/json/ld/frame.rb#622
JSON::LD::Frame::FRAMING_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/from_rdf.rb#7
module JSON::LD::FromRDF
  include ::JSON::LD::Utils

  # Generate a JSON-LD array representation from an array of `RDF::Statement`.
  # Representation is in expanded form
  #
  # @param dataset [Array<RDF::Statement>, RDF::Enumerable]
  # @param extendedRepresentation [false] Use the extended internal representation for native types.
  # @param useNativeTypes [Boolean] (false) use native representations
  # @param useRdfType [Boolean] (false)
  #   If set to `true`, the JSON-LD processor will treat `rdf:type` like a normal property instead of using `@type`.
  # @return [Array<Hash>] the JSON-LD document in normalized form
  #
  # source://json-ld//lib/json/ld/from_rdf.rb#22
  def from_statements(dataset, useRdfType: T.unsafe(nil), useNativeTypes: T.unsafe(nil), extendedRepresentation: T.unsafe(nil)); end

  private

  # source://json-ld//lib/json/ld/from_rdf.rb#194
  def resource_representation(resource, useNativeTypes, extendedRepresentation); end
end

# source://json-ld//lib/json/ld/from_rdf.rb#192
JSON::LD::FromRDF::RDF_LITERAL_NATIVE_TYPES = T.let(T.unsafe(nil), Set)

# JSON-LD profiles
#
# source://json-ld//lib/json/ld.rb#43
JSON::LD::JSON_LD_NS = T.let(T.unsafe(nil), String)

# source://json-ld//lib/json/ld.rb#103
JSON::LD::JSON_STATE = T.let(T.unsafe(nil), JSON::Ext::Generator::State)

# source://json-ld//lib/json/ld.rb#118
class JSON::LD::JsonLdError < ::StandardError
  # source://json-ld//lib/json/ld.rb#123
  def code; end

  # source://json-ld//lib/json/ld.rb#119
  def to_s; end
end

# source://json-ld//lib/json/ld.rb#127
class JSON::LD::JsonLdError::CollidingKeywords < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#128
class JSON::LD::JsonLdError::ConflictingIndexes < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#174
class JSON::LD::JsonLdError::ContextOverflow < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#129
class JSON::LD::JsonLdError::CyclicIRIMapping < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#170
class JSON::LD::JsonLdError::IRIConfusedWithPrefix < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#130
class JSON::LD::JsonLdError::InvalidAnnotation < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#163
class JSON::LD::JsonLdError::InvalidBaseDirection < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#131
class JSON::LD::JsonLdError::InvalidBaseIRI < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#132
class JSON::LD::JsonLdError::InvalidContainerMapping < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#133
class JSON::LD::JsonLdError::InvalidContextEntry < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#134
class JSON::LD::JsonLdError::InvalidContextNullification < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#135
class JSON::LD::JsonLdError::InvalidDefaultLanguage < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#180
class JSON::LD::JsonLdError::InvalidEmbedValue < ::JSON::LD::JsonLdError::InvalidFrame; end

# source://json-ld//lib/json/ld.rb#152
class JSON::LD::JsonLdError::InvalidEmbeddedNode < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#179
class JSON::LD::JsonLdError::InvalidFrame < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#141
class JSON::LD::JsonLdError::InvalidIRIMapping < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#136
class JSON::LD::JsonLdError::InvalidIdValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#139
class JSON::LD::JsonLdError::InvalidImportValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#140
class JSON::LD::JsonLdError::InvalidIncludedValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#137
class JSON::LD::JsonLdError::InvalidIndexValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#142
class JSON::LD::JsonLdError::InvalidJsonLiteral < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#143
class JSON::LD::JsonLdError::InvalidKeywordAlias < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#145
class JSON::LD::JsonLdError::InvalidLanguageMapValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#144
class JSON::LD::JsonLdError::InvalidLanguageMapping < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#146
class JSON::LD::JsonLdError::InvalidLanguageTaggedString < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#147
class JSON::LD::JsonLdError::InvalidLanguageTaggedValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#148
class JSON::LD::JsonLdError::InvalidLocalContext < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#149
class JSON::LD::JsonLdError::InvalidNestValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#150
class JSON::LD::JsonLdError::InvalidPrefixValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#151
class JSON::LD::JsonLdError::InvalidPropagateValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#153
class JSON::LD::JsonLdError::InvalidRemoteContext < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#154
class JSON::LD::JsonLdError::InvalidReverseProperty < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#155
class JSON::LD::JsonLdError::InvalidReversePropertyMap < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#156
class JSON::LD::JsonLdError::InvalidReversePropertyValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#157
class JSON::LD::JsonLdError::InvalidReverseValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#158
class JSON::LD::JsonLdError::InvalidScopedContext < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#159
class JSON::LD::JsonLdError::InvalidScriptElement < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#160
class JSON::LD::JsonLdError::InvalidSetOrListObject < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#161
class JSON::LD::JsonLdError::InvalidStreamingKeyOrder < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#162
class JSON::LD::JsonLdError::InvalidTermDefinition < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#165
class JSON::LD::JsonLdError::InvalidTypeMapping < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#166
class JSON::LD::JsonLdError::InvalidTypeValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#164
class JSON::LD::JsonLdError::InvalidTypedValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#167
class JSON::LD::JsonLdError::InvalidValueObject < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#168
class JSON::LD::JsonLdError::InvalidValueObjectValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#138
class JSON::LD::JsonLdError::InvalidVersionValue < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#169
class JSON::LD::JsonLdError::InvalidVocabMapping < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#171
class JSON::LD::JsonLdError::KeywordRedefinition < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#172
class JSON::LD::JsonLdError::LoadingDocumentFailed < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#173
class JSON::LD::JsonLdError::LoadingRemoteContextFailed < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#175
class JSON::LD::JsonLdError::MissingIncludedReferent < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#176
class JSON::LD::JsonLdError::MultipleContextLinkHeaders < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#178
class JSON::LD::JsonLdError::ProcessingModeConflict < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#177
class JSON::LD::JsonLdError::ProtectedTermRedefinition < ::JSON::LD::JsonLdError; end

# source://json-ld//lib/json/ld.rb#52
JSON::LD::KEYWORDS = T.let(T.unsafe(nil), Set)

# source://json-ld//lib/json/ld.rb#111
JSON::LD::MAX_CONTEXTS_LOADED = T.let(T.unsafe(nil), Integer)

# Acceptable MultiJson adapters
#
# source://json-ld//lib/json/ld.rb#50
JSON::LD::MUTLI_JSON_ADAPTERS = T.let(T.unsafe(nil), Array)

# Datatypes that are expressed in a native form and don't expand or compact
#
# source://json-ld//lib/json/ld.rb#101
JSON::LD::NATIVE_DATATYPES = T.let(T.unsafe(nil), Array)

# Regexp matching an NCName.
#
# source://json-ld//lib/json/ld.rb#86
JSON::LD::NC_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://json-ld//lib/json/ld.rb#44
JSON::LD::PROFILES = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld.rb#115
JSON::LD::RDF_DIRECTION = T.let(T.unsafe(nil), RDF::URI)

# URI Constants
#
# source://json-ld//lib/json/ld.rb#114
JSON::LD::RDF_JSON = T.let(T.unsafe(nil), RDF::URI)

# source://json-ld//lib/json/ld.rb#116
JSON::LD::RDF_LANGUAGE = T.let(T.unsafe(nil), RDF::URI)

# A JSON-LD parser in Ruby.
#
# @author [Gregg Kellogg](http://greggkellogg.net/)
# @see https://www.w3.org/TR/json-ld11-api
#
# source://json-ld//lib/json/ld/reader.rb#10
class JSON::LD::Reader < ::RDF::Reader
  include ::JSON::LD::Utils
  include ::JSON::LD::ToRDF
  include ::JSON::LD::StreamingReader

  # Initializes the JSON-LD reader instance.
  #
  # @param input [IO, File, String]
  # @param options [Hash{Symbol => Object}] any additional options (see `RDF::Reader#initialize` and {JSON::LD::API.initialize})
  # @raise [RDF::ReaderError] if the JSON document cannot be loaded
  # @return [Reader] a new instance of Reader
  # @yield [reader] `self`
  # @yieldparam reader [RDF::Reader]
  # @yieldreturn [void] ignored
  #
  # source://json-ld//lib/json/ld/reader.rb#76
  def initialize(input = T.unsafe(nil), **options, &block); end

  # @private
  # @see RDF::Reader#each_statement
  #
  # source://json-ld//lib/json/ld/reader.rb#100
  def each_statement(&block); end

  # @private
  # @see RDF::Reader#each_triple
  #
  # source://json-ld//lib/json/ld/reader.rb#113
  def each_triple; end

  class << self
    # JSON-LD Reader options
    #
    # @see https://ruby-rdf.github.io/rdf/RDF/Reader#options-class_method
    #
    # source://json-ld//lib/json/ld/reader.rb#17
    def options; end
  end
end

# Simple Ruby reflector class to provide native
# access to JSON-LD objects
#
# source://json-ld//lib/json/ld/resource.rb#7
class JSON::LD::Resource
  include ::Enumerable
  include ::RDF::Countable
  include ::RDF::Enumerable

  # A new resource from the parsed graph
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param node_definition [Hash{String => Object}]
  # @param options [Hash{Symbol => Object}]
  # @return [Resource] a new instance of Resource
  #
  # source://json-ld//lib/json/ld/resource.rb#94
  def initialize(node_definition, **options); end

  # Anonymous resources have BNode ids or no schema:url
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/resource.rb#56
  def anonymous?; end

  # @return [Hash<String => Object] Object representation of resource] Hash<String => Object] Object representation of resource
  #
  # source://json-ld//lib/json/ld/resource.rb#11
  def attributes; end

  # Is this resource clean (i.e., saved to mongo?)
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/resource.rb#23
  def clean?; end

  # @return [JSON::LD::Context] Context associated with this resource
  #
  # source://json-ld//lib/json/ld/resource.rb#17
  def context; end

  # Reverse resolution of resource attributes.
  # Just returns `attributes` if
  # resource is unresolved. Otherwise, replaces `Resource`
  # values with node references.
  #
  # Result is expanded and re-compacted to get to normalized
  # representation.
  #
  # @return [Hash] deresolved attribute hash
  #
  # source://json-ld//lib/json/ld/resource.rb#126
  def deresolve; end

  # Is this resource dirty (i.e., not yet saved to mongo?)
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/resource.rb#31
  def dirty?; end

  # Enumerate over statements associated with this resource
  #
  # source://json-ld//lib/json/ld/resource.rb#166
  def each(&block); end

  # Return a hash of this object, suitable for use by for ETag
  #
  # @return [Integer]
  #
  # source://json-ld//lib/json/ld/resource.rb#112
  def hash; end

  # @return [String] ID of this resource
  #
  # source://json-ld//lib/json/ld/resource.rb#14
  def id; end

  # source://json-ld//lib/json/ld/resource.rb#240
  def inspect; end

  # Access individual fields, from subject definition
  #
  # source://json-ld//lib/json/ld/resource.rb#236
  def method_missing(method, *_args); end

  # Is this a new resource, which has not yet been
  # synched or created within the DB?
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/resource.rb#70
  def new?; end

  # Access individual fields, from subject definition
  #
  # source://json-ld//lib/json/ld/resource.rb#230
  def property(prop_name); end

  # Has this resource been reconciled against a mongo ID?
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/resource.rb#39
  def reconciled?; end

  # Update node references using the provided map.
  # This replaces node references with Resources,
  # either stub or instantiated.
  #
  # Node references with ids not in the reference_map
  # will cause stub resources to be added to the map.
  #
  # @param reference_map [Hash{String => Resource}]
  # @return [Resource] self
  #
  # source://json-ld//lib/json/ld/resource.rb#180
  def resolve(reference_map); end

  # Has this resource been resolved so that
  # all references are to other Resources?
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/resource.rb#48
  def resolved?; end

  # Override this method to implement save using
  # an appropriate storage mechanism.
  #
  # Save the object to the Mongo collection
  # use Upsert to create things that don't exist.
  # First makes sure that the resource is valid.
  #
  # @raise [NotImplementedError]
  # @return [Boolean] true or false if resource not saved
  #
  # source://json-ld//lib/json/ld/resource.rb#224
  def save; end

  # Is this a stub resource, which has not yet been
  # synched or created within the DB?
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/resource.rb#63
  def stub?; end

  # Serialize to JSON-LD, minus `@context` using
  # a deresolved version of the attributes
  #
  # @param options [Hash]
  # @return [String] serizlied JSON representation of resource
  #
  # source://json-ld//lib/json/ld/resource.rb#160
  def to_json(**options); end
end

# A streaming JSON-LD parser in Ruby.
#
# @author [Gregg Kellogg](http://greggkellogg.net/)
# @see http://json-ld.org/spec/ED/20110507/
#
# source://json-ld//lib/json/ld/streaming_reader.rb#14
module JSON::LD::StreamingReader
  include ::JSON::LD::Utils
  include ::JSON::LD::ToRDF

  # The base URI to use when resolving relative URIs
  #
  # @return [RDF::URI]
  #
  # source://json-ld//lib/json/ld/streaming_reader.rb#20
  def base; end

  # Returns the value of attribute namer.
  #
  # source://json-ld//lib/json/ld/streaming_reader.rb#21
  def namer; end

  # @see RDF::Reader#each_statement
  #
  # source://json-ld//lib/json/ld/streaming_reader.rb#29
  def stream_statement; end

  private

  # Wrapps parse_object to handle JSON literals and reversed properties
  #
  # source://json-ld//lib/json/ld/streaming_reader.rb#578
  def emit_object(input, active_property, context, subject, predicate, **options, &block); end

  # Process input as an ordered list
  #
  # @return [RDF::Resource] the list head
  #
  # source://json-ld//lib/json/ld/streaming_reader.rb#617
  def parse_list(input, active_property, context, &block); end

  # Parse a node object, or array of node objects
  #
  # @param active_property [String] The unexpanded property referencing this object
  # @param context [Context]
  # @param extra_type [RDF::URI] from a type map
  # @param from_map [Boolean] Expanding from a map, which could be an `@type` map, so don't clear out context term definitions
  # @param graph_is_named [Boolean] Use of `@graph` implies a named graph; not true at the top-level.
  # @param input [Array, Hash]
  # @param language [String] from a language map
  # @param node_id [RDF::Resource] from an id map
  # @param predicate [RDF::URI] the predicate part of the reference
  # @param subject [RDF::Resource] referencing this object
  # @return [void]
  # @yield [RDF::Statement(subject, predicate, node_id)]
  #
  # source://json-ld//lib/json/ld/streaming_reader.rb#74
  def parse_object(input, active_property, context, subject: T.unsafe(nil), predicate: T.unsafe(nil), from_map: T.unsafe(nil), extra_type: T.unsafe(nil), language: T.unsafe(nil), node_id: T.unsafe(nil), graph_is_named: T.unsafe(nil), &block); end

  # source://json-ld//lib/json/ld/streaming_reader.rb#425
  def parse_property(input, active_property, context, subject, predicate, &block); end

  class << self
    # source://json-ld//lib/json/ld/streaming_reader.rb#23
    def format; end
  end
end

# Streaming writer interface.
#
# Writes an array of statements serialized in expanded JSON-LD. No provision for turning rdf:first/rest into @list encodings.
#
# @author [Gregg Kellogg](http://greggkellogg.net/)
#
# source://json-ld//lib/json/ld/streaming_writer.rb#10
module JSON::LD::StreamingWriter
  # Complete open statements
  #
  # @return [void] `self`
  #
  # source://json-ld//lib/json/ld/streaming_writer.rb#78
  def stream_epilogue; end

  # Write out array start, and note not to prepend node-separating ','
  #
  # @return [void] `self`
  #
  # source://json-ld//lib/json/ld/streaming_writer.rb#14
  def stream_prologue; end

  # Write a statement, creating a current node definition, if necessary.
  #
  # Once a new/first statement is seen, terminate the current node definition and compact if provided a context.
  #
  # Also expects all statements in the same context to be contained in a block including all subjects in a block (except for list elements)
  #
  # Note that if list elements are not received in order using the same subject and property, this may cause a bad serialization.
  #
  # @return [void] `self`
  #
  # source://json-ld//lib/json/ld/streaming_writer.rb#41
  def stream_statement(statement); end

  private

  # source://json-ld//lib/json/ld/streaming_writer.rb#101
  def end_graph; end

  # source://json-ld//lib/json/ld/streaming_writer.rb#110
  def end_node; end

  # source://json-ld//lib/json/ld/streaming_writer.rb#91
  def start_graph(resource); end
end

# source://json-ld//lib/json/ld/to_rdf.rb#9
module JSON::LD::ToRDF
  include ::JSON::LD::Utils

  # @param graph_name [RDF::Resource]
  # @param item [Hash{String => Object}]
  # @param quoted [Boolean] emitted triples are quoted triples.
  # @return RDF::Resource the subject of this item
  # @yield statement
  # @yieldparam statement [RDF::Statement]
  #
  # source://json-ld//lib/json/ld/to_rdf.rb#19
  def item_to_rdf(item, graph_name: T.unsafe(nil), quoted: T.unsafe(nil), &block); end

  # Create a new named node using the sequence
  #
  # source://json-ld//lib/json/ld/to_rdf.rb#191
  def node; end

  # Parse a List
  #
  # @param list [Array] The Array to serialize as a list
  # @return [Array<RDF::Statement>] Statements for each item in the list
  # @yield statement
  # @yieldparam statement [RDF::Resource]
  #
  # source://json-ld//lib/json/ld/to_rdf.rb#167
  def parse_list(list, graph_name: T.unsafe(nil), &block); end
end

# source://json-ld//lib/json/ld/utils.rb#5
module JSON::LD::Utils
  # Adds a value to a subject. If the value is an array, all values in the
  # array will be added.
  #
  # @param allow_duplicate [Boolean] (true)
  #   true to allow duplicates, false not to (uses
  #   a simple shallow comparison of subject ID or value).
  # @param property [String] the property that relates the value to the subject.
  # @param property_is_array [Boolean] (false)
  #   true if the property is always an array, false if not.
  # @param subject [Hash] the hash to add the value to.
  # @param value [Object] the value to add.
  # @param value_is_array [Boolean] (false)
  #   true if the value to be added should be preserved as an array (lists)
  #
  # source://json-ld//lib/json/ld/utils.rb#163
  def add_value(subject, property, value, property_is_array: T.unsafe(nil), value_is_array: T.unsafe(nil), allow_duplicate: T.unsafe(nil)); end

  # Represent as an array
  #
  # @param object [Object]
  # @return [Array<Object>]
  #
  # source://json-ld//lib/json/ld/utils.rb#120
  def as_array(object); end

  # Represent an id as an IRI or Blank Node
  #
  # @param base [RDF::URI] (nil)
  # @param id [String]
  # @return [RDF::Resource]
  #
  # source://json-ld//lib/json/ld/utils.rb#105
  def as_resource(id, base = T.unsafe(nil)); end

  # Is value a blank node? Value is a blank node
  #
  # @param value [Object]
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/utils.rb#41
  def blank_node?(value); end

  # Compares two JSON-LD values for equality. Two JSON-LD values will be
  # considered equal if:
  #
  # 1. They are both primitives of the same type and value.
  # 2. They are both @values with the same @value, @type, @language,
  #   and @index, OR
  # 3. They both have @ids that are the same.
  #
  # @param v1 [Object] the first value.
  # @param v2 [Object] the second value.
  # @return [Boolean] v1 and v2 are considered equal
  #
  # source://json-ld//lib/json/ld/utils.rb#137
  def compare_values(v1, v2); end

  # Is value an expaned @graph?
  #
  # Note: A value is a graph if all of these hold true:
  # 1. It is an object.
  # 2. It has an `@graph` key.
  # 3. It may have '@context', '@id' or '@index'
  #
  # @param value [Object]
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/utils.rb#60
  def graph?(value); end

  # Determines if the given value is a property of the given subject.
  #
  # @param property [String] the property to check.
  # @param subject [Hash] the subject to check.
  # @param value [Object] the value to check.
  # @return [Boolean] true if the value exists, false if not.
  #
  # source://json-ld//lib/json/ld/utils.rb#206
  def has_value?(subject, property, value); end

  # Is value annotated?
  #
  # @param value [Object]
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/utils.rb#87
  def index?(value); end

  # Is value an expaned @list?
  #
  # @param value [Object]
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/utils.rb#78
  def list?(value); end

  # Is value a node? A value is a node if
  # * it is a Hash
  # * it is not a @value, @set or @list
  # * it has more than 1 key or any key is not @id
  #
  # @param value [Object]
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/utils.rb#13
  def node?(value); end

  # Is value a node or a node reference reference?
  #
  # @param value [Object]
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/utils.rb#31
  def node_or_ref?(value); end

  # Is value a node reference?
  #
  # @param value [Object]
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/utils.rb#23
  def node_reference?(value); end

  # Returns True if the given subject has the given property.
  #
  # @param property the property to look for.
  # @param subject the subject to check.
  # @return [Boolean] true if the subject has the given property, false if not.
  #
  # source://json-ld//lib/json/ld/utils.rb#193
  def property?(subject, property); end

  # Is value a simple graph (lacking @id)?
  #
  # @param value [Object]
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/utils.rb#69
  def simple_graph?(value); end

  # Is value literal?
  #
  # @param value [Object]
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/utils.rb#96
  def value?(value); end

  private

  # Merge the last value into an array based for the specified key if hash is not null and value is not already in that array
  #
  # source://json-ld//lib/json/ld/utils.rb#228
  def merge_value(hash, key, value); end
end

# source://json-ld//lib/json/ld/utils.rb#225
JSON::LD::Utils::UTIL_GRAPH_KEYS = T.let(T.unsafe(nil), Array)

# source://json-ld//lib/json/ld/version.rb#5
module JSON::LD::VERSION
  class << self
    # @return [Array(Integer, Integer, Integer)]
    #
    # source://json-ld//lib/json/ld/version.rb#25
    def to_a; end

    # @return [String]
    #
    # source://json-ld//lib/json/ld/version.rb#13
    def to_s; end

    # @return [String]
    #
    # source://json-ld//lib/json/ld/version.rb#19
    def to_str; end
  end
end

# source://json-ld//lib/json/ld/version.rb#7
JSON::LD::VERSION::EXTRA = T.let(T.unsafe(nil), T.untyped)

# source://json-ld//lib/json/ld/version.rb#7
JSON::LD::VERSION::MAJOR = T.let(T.unsafe(nil), String)

# source://json-ld//lib/json/ld/version.rb#7
JSON::LD::VERSION::MINOR = T.let(T.unsafe(nil), String)

# source://json-ld//lib/json/ld/version.rb#9
JSON::LD::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://json-ld//lib/json/ld/version.rb#7
JSON::LD::VERSION::TINY = T.let(T.unsafe(nil), String)

# source://json-ld//lib/json/ld/version.rb#6
JSON::LD::VERSION::VERSION_FILE = T.let(T.unsafe(nil), String)

# A JSON-LD parser in Ruby.
#
# Note that the natural interface is to write a whole graph at a time.
# Writing statements or Triples will create a graph to add them to
# and then serialize the graph.
#
# The writer will add prefix definitions, and use them for creating @context definitions, and minting CURIEs
#
# Select the :expand option to output JSON-LD in expanded form
#
# @author [Gregg Kellogg](http://greggkellogg.net/)
# @example Creating @@context prefix definitions in output
#   JSON::LD::Writer.buffer(
#   prefixes: {
#   nil => "http://example.com/ns#",
#   foaf: "http://xmlns.com/foaf/0.1/"}
#   ) do |writer|
#   graph.each_statement do |statement|
#   writer << statement
#   end
#   end
# @example Obtaining a JSON-LD writer class
#   RDF::Writer.for(:jsonld)         #=> JSON::LD::Writer
#   RDF::Writer.for("etc/test.json")
#   RDF::Writer.for(:file_name      => "etc/test.json")
#   RDF::Writer.for(file_extension: "json")
#   RDF::Writer.for(:content_type   => "application/turtle")
# @example Serializing RDF graph into an JSON-LD file
#   JSON::LD::Writer.open("etc/test.json") do |writer|
#   writer << graph
#   end
# @example Serializing RDF statements into an JSON-LD file
#   JSON::LD::Writer.open("etc/test.json") do |writer|
#   graph.each_statement do |statement|
#   writer << statement
#   end
#   end
# @example Serializing RDF statements into an JSON-LD string
#   JSON::LD::Writer.buffer do |writer|
#   graph.each_statement do |statement|
#   writer << statement
#   end
#   end
# @see https://www.w3.org/TR/json-ld11-api/
# @see https://www.w3.org/TR/json-ld11-api/#the-normalization-algorithm
#
# source://json-ld//lib/json/ld/writer.rb#59
class JSON::LD::Writer < ::RDF::Writer
  include ::JSON::LD::StreamingWriter
  include ::JSON::LD::Utils

  # Initializes the JSON-LD writer instance.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash{Symbol => Object}] any additional options
  # @param output [IO, File] the output stream
  # @return [Writer] a new instance of Writer
  # @yield [writer]
  # @yield [writer] `self`
  # @yieldparam writer [RDF::Writer]
  # @yieldparam writer [RDF::Writer]
  # @yieldreturn [void]
  #
  # source://json-ld//lib/json/ld/writer.rb#254
  def initialize(output = T.unsafe(nil), **options, &block); end

  # @return [Context] context used to load and administer contexts
  #
  # source://json-ld//lib/json/ld/writer.rb#71
  def context; end

  # @return [RDF::Graph] Graph of statements serialized
  #
  # source://json-ld//lib/json/ld/writer.rb#67
  def graph; end

  # Outputs the Serialized JSON-LD representation of all stored statements.
  #
  # If provided a context or prefixes, we'll create a context
  # and use it to compact the output. Otherwise, we return un-compacted JSON-LD
  #
  # @return [void]
  # @see #write_triple
  #
  # source://json-ld//lib/json/ld/writer.rb#313
  def write_epilogue; end

  # Necessary for streaming
  #
  # @return [void] `self`
  #
  # source://json-ld//lib/json/ld/writer.rb#300
  def write_prologue; end

  # Outputs the N-Quads representation of a statement.
  #
  # @param object [RDF::Term]
  # @param predicate [RDF::URI]
  # @param subject [RDF::Resource]
  # @return [void]
  #
  # source://json-ld//lib/json/ld/writer.rb#288
  def write_quad(subject, predicate, object, graph_name); end

  # Addes a triple to be serialized
  #
  # @abstract
  # @param object [RDF::Value]
  # @param predicate [RDF::URI]
  # @param subject [RDF::Resource]
  # @return [void]
  #
  # source://json-ld//lib/json/ld/writer.rb#277
  def write_triple(subject, predicate, object); end

  class << self
    # Use parameters from accept-params to determine if the parameters are acceptable to invoke this writer. The `accept_params` will subsequently be provided to the writer instance.
    #
    # @param accept_params [Hash{Symbol => String}]
    # @return [Boolean]
    # @see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1
    # @yield [accept_params] if a block is given, returns the result of evaluating that block
    # @yieldparam accept_params [Hash{Symbol => String}]
    #
    # source://json-ld//lib/json/ld/writer.rb#203
    def accept?(accept_params); end

    # Returns the value of attribute black_list.
    #
    # source://json-ld//lib/json/ld/writer.rb#193
    def black_list; end

    # Returns default context used for compacted profile without an explicit context URL
    #
    # @return [String]
    #
    # source://json-ld//lib/json/ld/writer.rb#214
    def default_context; end

    # Sets default context used for compacted profile without an explicit context URL
    #
    # @param url [String]
    #
    # source://json-ld//lib/json/ld/writer.rb#221
    def default_context=(_arg0); end

    # JSON-LD Writer options
    #
    # @see https://ruby-rdf.github.io/rdf/RDF/Writer#options-class_method
    #
    # source://json-ld//lib/json/ld/writer.rb#76
    def options; end

    # Returns the value of attribute white_list.
    #
    # source://json-ld//lib/json/ld/writer.rb#193
    def white_list; end
  end
end

# source://json-ld//lib/json/ld/extensions.rb#3
module RDF; end

# source://json-ld//lib/json/ld/extensions.rb#35
class RDF::Literal
  include ::RDF::Value
  include ::Comparable

  # Validate extended RDF
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/extensions.rb#37
  def valid_extended?; end
end

# source://json-ld//lib/json/ld/extensions.rb#4
class RDF::Node
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Term

  # Odd case of appending to a BNode identifier
  #
  # source://json-ld//lib/json/ld/extensions.rb#6
  def +(other); end

  # Validate extended RDF
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/extensions.rb#30
  def valid_extended?; end
end

# source://json-ld//lib/json/ld/extensions.rb#11
class RDF::Statement
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Term

  # Validate extended RDF
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/extensions.rb#13
  def valid_extended?; end
end

# source://json-ld//lib/json/ld/extensions.rb#21
class RDF::URI
  include ::RDF::Value
  include ::Comparable
  include ::RDF::Term

  # Validate extended RDF
  #
  # @return [Boolean]
  #
  # source://json-ld//lib/json/ld/extensions.rb#23
  def valid_extended?; end
end
