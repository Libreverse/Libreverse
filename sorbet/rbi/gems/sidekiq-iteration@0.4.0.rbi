# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq-iteration` gem.
# Please instead update this file by running `bin/tapioca gem sidekiq-iteration`.


class Sidekiq::JobRetry
  include ::SidekiqIteration::JobRetryPatch
end

# source://sidekiq-iteration//lib/sidekiq_iteration/throttling.rb#3
module SidekiqIteration
  class << self
    # Configures a delay duration to wait before resuming an interrupted job.
    #
    # Defaults to nil which means interrupted jobs will be retried immediately.
    # This value will be ignored when an interruption is raised by a throttle enumerator,
    # where the throttle backoff value will take precedence over this setting.
    #
    # @example
    #   SidekiqIteration.default_retry_backoff = 10.seconds
    #
    # source://sidekiq-iteration//lib/sidekiq_iteration.rb#36
    def default_retry_backoff; end

    # Configures a delay duration to wait before resuming an interrupted job.
    #
    # Defaults to nil which means interrupted jobs will be retried immediately.
    # This value will be ignored when an interruption is raised by a throttle enumerator,
    # where the throttle backoff value will take precedence over this setting.
    #
    # @example
    #   SidekiqIteration.default_retry_backoff = 10.seconds
    #
    # source://sidekiq-iteration//lib/sidekiq_iteration.rb#36
    def default_retry_backoff=(_arg0); end

    # source://sidekiq-iteration//lib/sidekiq_iteration.rb#46
    def logger; end

    # Set a custom logger for sidekiq-iteration.
    # Defaults to `Sidekiq.logger`.
    #
    # @example
    #   SidekiqIteration.logger = Logger.new("log/sidekiq-iteration.log")
    #
    # source://sidekiq-iteration//lib/sidekiq_iteration.rb#44
    def logger=(_arg0); end

    # Use this to _always_ interrupt the job after it's been running for more than N seconds.
    #
    # This setting will make it to always interrupt a job after it's been iterating for 5 minutes.
    # Defaults to nil which means that jobs will not be interrupted except on termination signal.
    #
    # @example Global setting
    #   SidekiqIteration.max_job_runtime = 5.minutes
    # @example Per-job setting
    #   class MyJob
    #   # ...
    #   self.max_job_runtime = 1.minute
    #   # ...
    #   end
    #
    # source://sidekiq-iteration//lib/sidekiq_iteration.rb#25
    def max_job_runtime; end

    # Use this to _always_ interrupt the job after it's been running for more than N seconds.
    #
    # This setting will make it to always interrupt a job after it's been iterating for 5 minutes.
    # Defaults to nil which means that jobs will not be interrupted except on termination signal.
    #
    # @example Global setting
    #   SidekiqIteration.max_job_runtime = 5.minutes
    # @example Per-job setting
    #   class MyJob
    #   # ...
    #   self.max_job_runtime = 1.minute
    #   # ...
    #   end
    #
    # source://sidekiq-iteration//lib/sidekiq_iteration.rb#25
    def max_job_runtime=(_arg0); end

    # @private
    #
    # source://sidekiq-iteration//lib/sidekiq_iteration.rb#51
    def stopping; end

    # @private
    #
    # source://sidekiq-iteration//lib/sidekiq_iteration.rb#51
    def stopping=(_arg0); end
  end
end

# @private
#
# source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#5
class SidekiqIteration::ActiveRecordEnumerator
  # @return [ActiveRecordEnumerator] a new instance of ActiveRecordEnumerator
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#8
  def initialize(relation, columns: T.unsafe(nil), batch_size: T.unsafe(nil), order: T.unsafe(nil), cursor: T.unsafe(nil)); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#77
  def batches; end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#66
  def records; end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#86
  def relations; end

  private

  # (x, y) >= (a, b) iff (x > a or (x = a and y >= b))
  # (x, y) <= (a, b) iff (x < a or (x = a and y <= b))
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#192
  def apply_cursor(relation); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#119
  def arel_column(column); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#111
  def batch_order(columns, order); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#215
  def column_value(value); end

  # @return [Boolean]
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#246
  def composite_primary_key?; end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#223
  def cursor_operators; end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#182
  def cursor_value(record); end

  # @return [Boolean]
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#242
  def first_iteration?; end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#238
  def increment_iteration; end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#135
  def next_batch(load:); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#164
  def pluck_columns(batch); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#96
  def primary_key_index(columns, relation); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#127
  def records_size; end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#131
  def relations_size; end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#211
  def serialize_column_values(column_values); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#250
  def unwrap_array(array); end
end

# source://sidekiq-iteration//lib/sidekiq_iteration/active_record_enumerator.rb#6
SidekiqIteration::ActiveRecordEnumerator::SQL_DATETIME_WITH_NSEC = T.let(T.unsafe(nil), String)

# CsvEnumerator makes it possible to write an Iteration job
# that uses CSV file as a collection to iterate.
#
# @example Enumerator to iterate on batches of rows
#   def build_enumerator(cursor:)
#   csv = CSV.open('tmp/files', { converters: :integer, headers: true })
#   csv_batches_enumerator(csv, cursor: cursor)
#   end
#
#   def each_iteration(row)
#   ...
#   end
# @example Enumerator to iterate on rows
#   def build_enumerator(cursor:)
#   csv = CSV.open('tmp/files', { converters: :integer, headers: true })
#   csv_enumerator(csv, cursor: cursor)
#   end
#
#   def each_iteration(row)
#   ...
#   end
# @private
#
# source://sidekiq-iteration//lib/sidekiq_iteration/csv_enumerator.rb#28
class SidekiqIteration::CsvEnumerator
  # Constructs CsvEnumerator instance based on a CSV file.
  #
  # @example
  #   csv = CSV.open('tmp/files', { converters: :integer, headers: true })
  #   SidekiqIteration::CsvEnumerator.new(csv).rows(cursor: cursor)
  # @param csv [CSV] An instance of CSV object
  # @return [SidekiqIteration::CsvEnumerator]
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/csv_enumerator.rb#38
  def initialize(csv); end

  # Constructs a enumerator on batches of CSV rows
  #
  # @return [Enumerator] Enumerator instance
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/csv_enumerator.rb#59
  def batches(cursor:, batch_size: T.unsafe(nil)); end

  # Constructs a enumerator on CSV rows
  #
  # @return [Enumerator] Enumerator instance
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/csv_enumerator.rb#49
  def rows(cursor:); end

  private

  # source://sidekiq-iteration//lib/sidekiq_iteration/csv_enumerator.rb#68
  def count_of_rows_in_file; end
end

# source://sidekiq-iteration//lib/sidekiq_iteration/enumerators.rb#8
module SidekiqIteration::Enumerators
  # Builds Enumerator from Active Record Relation and enumerates on batches of records.
  # Each Enumerator tick moves the cursor +batch_size+ rows forward.
  #
  # @example
  #   def build_enumerator(product_id, cursor:)
  #   active_record_batches_enumerator(
  #   Comment.where(product_id: product_id).select(:id),
  #   cursor: cursor,
  #   batch_size: 100
  #   )
  #   end
  #
  #   def each_iteration(batch_of_comments, product_id)
  #   comment_ids = batch_of_comments.map(&:id)
  #   CommentService.call(comment_ids: comment_ids)
  #   end
  # @see #active_record_records_enumerator
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/enumerators.rb#91
  def active_record_batches_enumerator(scope, cursor:, **options); end

  # Builds Enumerator from Active Record Relation. Each Enumerator tick moves the cursor one row forward.
  #
  # +columns:+ argument is used to build the actual query for iteration. +columns+: defaults to primary key:
  #
  #   1) SELECT * FROM users ORDER BY id LIMIT 100
  #
  # When iteration is resumed, +cursor:+ and +columns:+ values will be used to continue from the point
  # where iteration stopped:
  #
  #   2) SELECT * FROM users WHERE id > $CURSOR ORDER BY id LIMIT 100
  #
  # +columns:+ can also take more than one column. In that case, +cursor+ will contain serialized values
  # of all columns at the point where iteration stopped.
  #
  # Consider this example with +columns: [:created_at, :id]+. Here's the query will use on the first iteration:
  #
  #   1) SELECT * FROM "products" ORDER BY created_at, id LIMIT 100
  #
  # And the query on the next iteration:
  #
  #   2) SELECT * FROM "products"
  #        WHERE (created_at > '$LAST_CREATED_AT_CURSOR'
  #          OR (created_at = '$LAST_CREATED_AT_CURSOR' AND (id > '$LAST_ID_CURSOR')))
  #        ORDER BY created_at, id LIMIT 100
  #
  # As a result of this query pattern, if the values in these columns change for the records in scope during
  # iteration, they may be skipped or yielded multiple times depending on the nature of the update and the
  # cursor's value. If the value gets updated to a greater value than the cursor's value, it will get yielded
  # again. Similarly, if the value gets updated to a lesser value than the cursor's value, it will get skipped.
  #
  # @example
  #   def build_enumerator(cursor:)
  #   active_record_records_enumerator(User.all, cursor: cursor)
  #   end
  #
  #   def each_iteration(user)
  #   user.notify_about_something
  #   end
  # @option options
  # @option options
  # @option options
  # @param cursor [Object] offset to start iteration from, usually an id
  # @param options [Hash] a customizable set of options
  # @param scope [ActiveRecord::Relation] scope to iterate
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/enumerators.rb#69
  def active_record_records_enumerator(scope, cursor:, **options); end

  # Builds Enumerator from Active Record Relation and enumerates on batches, yielding Active Record Relations.
  #
  # @example
  #   def build_enumerator(product_id, cursor:)
  #   active_record_relations_enumerator(
  #   Product.find(product_id).comments,
  #   cursor: cursor,
  #   batch_size: 100,
  #   )
  #   end
  #
  #   def each_iteration(batch_of_comments, product_id)
  #   # batch_of_comments will be a Comment::ActiveRecord_Relation
  #   batch_of_comments.update_all(deleted: true)
  #   end
  # @see #active_record_records_enumerator
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/enumerators.rb#112
  def active_record_relations_enumerator(scope, cursor:, **options); end

  # Builds Enumerator object from a given array, using +cursor+ as an offset.
  #
  # @example
  #   array_enumerator(['build', 'enumerator', 'from', 'any', 'array'], cursor: cursor)
  # @param array [Array]
  # @param cursor [Integer] offset to start iteration from
  # @raise [ArgumentError]
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/enumerators.rb#17
  def array_enumerator(array, cursor:); end

  # Builds Enumerator from a CSV file and enumerates on batches of records.
  #
  # @example
  #   def build_enumerator(import_id, cursor:)
  #   import = Import.find(import_id)
  #   csv_batches_enumerator(import.csv, cursor: cursor)
  #   end
  #
  #   def each_iteration(batch_of_csv_rows)
  #   # ...
  #   end
  # @option options
  # @param csv [CSV] an instance of CSV object
  # @param cursor [Integer] offset to start iteration from
  # @param options [Hash] a customizable set of options
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/enumerators.rb#151
  def csv_batches_enumerator(csv, cursor:, **options); end

  # Builds Enumerator from a CSV file.
  #
  # @example
  #   def build_enumerator(import_id, cursor:)
  #   import = Import.find(import_id)
  #   csv_enumerator(import.csv, cursor: cursor)
  #   end
  #
  #   def each_iteration(csv_row)
  #   # insert csv_row to database
  #   end
  # @param csv [CSV] an instance of CSV object
  # @param cursor [Integer] offset to start iteration from
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/enumerators.rb#131
  def csv_enumerator(csv, cursor:); end

  # Builds Enumerator for nested iteration.
  #
  # @example
  #   def build_enumerator(cursor:)
  #   nested_enumerator(
  #   [
  #   ->(cursor) { active_record_records_enumerator(Shop.all, cursor: cursor) },
  #   ->(shop, cursor) { active_record_records_enumerator(shop.products, cursor: cursor) },
  #   ->(_shop, product, cursor) { active_record_relations_enumerator(product.product_variants, cursor: cursor) }
  #   ],
  #   cursor: cursor
  #   )
  #   end
  #
  #   def each_iteration(product_variants_relation)
  #   # do something
  #   end
  # @param cursor [Array<Object>] array of offsets for each of the enums to start iteration from
  # @param enums [Array<Proc>] an Array of Procs, each should return an Enumerator.
  #   Each proc from enums should accept the yielded items from the parent enumerators and the `cursor` as its arguments.
  #   Each proc's `cursor` argument is its part from the `build_enumerator`'s `cursor` array.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/enumerators.rb#178
  def nested_enumerator(enums, cursor:); end
end

# source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#7
module SidekiqIteration::Iteration
  include ::SidekiqIteration::Enumerators

  mixes_in_class_methods ::SidekiqIteration::Iteration::ClassMethods
  mixes_in_class_methods ::SidekiqIteration::Throttling

  # @private
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#70
  def initialize; end

  # A hook to override that will be called around each iteration.
  # Can be useful for some metrics collection, performance tracking etc.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#92
  def around_iteration; end

  # The enumerator to be iterated over.
  #
  # @raise [NotImplementedError] with a message advising subclasses to
  #   implement an override for this method.
  # @return [Enumerator]
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#117
  def build_enumerator(*_arg0); end

  # Returns the value of attribute current_run_iterations.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#56
  def current_run_iterations; end

  # Returns the value of attribute cursor_position.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#56
  def cursor_position; end

  # The action to be performed on each item from the enumerator.
  #
  # @raise [NotImplementedError] with a message advising subclasses to
  #   implement an override for this method.
  # @return [void]
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#128
  def each_iteration(*_arg0); end

  # Returns the value of attribute executions.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#56
  def executions; end

  # A hook to override that will be called when the job finished iterating.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#107
  def on_complete; end

  # A hook to override that will be called when the job resumes iterating.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#97
  def on_resume; end

  # A hook to override that will be called each time the job is interrupted.
  # This can be due to throttling (throttle enumerator), `max_job_runtime` configuration,
  # or sidekiq restarting.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#103
  def on_shutdown; end

  # A hook to override that will be called when the job starts iterating.
  # Is called only once, for the first time.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#87
  def on_start; end

  # @private
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#79
  def perform(*arguments); end

  # The time when the job starts running. If the job is interrupted and runs again,
  # the value is updated.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#63
  def start_time; end

  # Returns the value of attribute times_interrupted.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#56
  def times_interrupted; end

  # The total time the job has been running, including multiple iterations.
  # The time isn't reset if the job is interrupted.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#67
  def total_time; end

  private

  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#229
  def adjust_total_time; end

  # @raise [ArgumentError]
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#233
  def assert_enumerator!(enum); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#133
  def extract_previous_runs_metadata(arguments); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#254
  def find_throttle_condition; end

  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#260
  def handle_completed(completed); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#147
  def interruptible_perform(*arguments); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#180
  def iterate_with_enumerator(enumerator, arguments); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#248
  def output_interrupt_summary; end

  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#212
  def reenqueue_iteration_job; end

  class << self
    # @private
    # @private
    #
    # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#11
    def included(base); end
  end
end

# @private
#
# source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#31
module SidekiqIteration::Iteration::ClassMethods
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#32
  def inherited(base); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#47
  def max_job_runtime; end

  # Sets the attribute max_job_runtime
  #
  # @param value the value to set the attribute max_job_runtime to.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#45
  def max_job_runtime=(_arg0); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/iteration.rb#37
  def method_added(method_name); end
end

# @private
#
# source://sidekiq-iteration//lib/sidekiq_iteration/job_retry_patch.rb#7
module SidekiqIteration::JobRetryPatch
  private

  # source://sidekiq-iteration//lib/sidekiq_iteration/job_retry_patch.rb#20
  def add_sidekiq_iteration_metadata(jobinst, msg); end

  # The method was renamed in https://github.com/mperham/sidekiq/commit/0676a5202e89aa9da4ad7991f4111b97a9d8a0a4.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/job_retry_patch.rb#15
  def attempt_retry(jobinst, msg, queue, exception); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/job_retry_patch.rb#9
  def process_retry(jobinst, msg, queue, exception); end
end

# @private
#
# source://sidekiq-iteration//lib/sidekiq_iteration/nested_enumerator.rb#5
class SidekiqIteration::NestedEnumerator
  # @return [NestedEnumerator] a new instance of NestedEnumerator
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/nested_enumerator.rb#6
  def initialize(enums, cursor: T.unsafe(nil)); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/nested_enumerator.rb#19
  def each(&block); end

  private

  # source://sidekiq-iteration//lib/sidekiq_iteration/nested_enumerator.rb#26
  def iterate(current_items, current_cursor, index, &block); end
end

# source://sidekiq-iteration//lib/sidekiq_iteration/throttling.rb#4
module SidekiqIteration::Throttling
  # @private
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/throttling.rb#29
  def throttle_conditions; end

  # @private
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/throttling.rb#26
  def throttle_conditions=(_arg0); end

  # Add a condition under which this job will be throttled.
  #
  # @param backoff [Numeric, #call] (30) a custom backoff (in seconds).
  #   This is the time to wait before retrying the job.
  # @yieldparam job [Sidekiq::Job] current sidekiq job that is yielded to `condition` proc
  # @yieldreturn [Boolean] whether the throttle condition is being met,
  #   indicating that the job should throttle.
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/throttling.rb#41
  def throttle_on(backoff: T.unsafe(nil), &condition); end
end

# @private
#
# source://sidekiq-iteration//lib/sidekiq_iteration/throttling.rb#6
class SidekiqIteration::Throttling::ThrottleCondition
  # @return [ThrottleCondition] a new instance of ThrottleCondition
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/throttling.rb#7
  def initialize(condition, backoff); end

  # source://sidekiq-iteration//lib/sidekiq_iteration/throttling.rb#16
  def backoff; end

  # @return [Boolean]
  #
  # source://sidekiq-iteration//lib/sidekiq_iteration/throttling.rb#12
  def valid?(job); end
end

# source://sidekiq-iteration//lib/sidekiq_iteration/version.rb#4
SidekiqIteration::VERSION = T.let(T.unsafe(nil), String)
