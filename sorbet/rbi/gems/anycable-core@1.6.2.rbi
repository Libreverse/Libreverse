# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `anycable-core` gem.
# Please instead update this file by running `bin/tapioca gem anycable-core`.


# AnyCable allows to use any websocket service (written in any language) as a replacement
# for ActionCable server.
#
# AnyCable includes an RPC server (gRPC by default), which is used by external WS server to execute commands
# (authentication, subscription authorization, client-to-server messages).
#
# Broadcasting messages to WS is done through _broadcast adapter_ (Redis Pub/Sub by default).
#
# source://anycable-core//lib/anycable/version.rb#3
module AnyCable
  class << self
    # Raw broadcast message to the channel, sends only string!
    # To send hash or object use ActionCable.server.broadcast instead!
    #
    # source://anycable-core//lib/anycable.rb#99
    def broadcast(*_arg0, **_arg1, &_arg2); end

    # source://anycable-core//lib/anycable.rb#79
    def broadcast_adapter; end

    # source://anycable-core//lib/anycable.rb#84
    def broadcast_adapter=(adapter); end

    # Register a custom block that will be called
    # when an exception is raised during RPC call
    #
    # source://anycable-core//lib/anycable.rb#65
    def capture_exception(&block); end

    # source://anycable-core//lib/anycable.rb#55
    def config; end

    # @yield [config]
    #
    # source://anycable-core//lib/anycable.rb#59
    def configure; end

    # Register a callback to be invoked before
    # the server starts
    #
    # source://anycable-core//lib/anycable.rb#71
    def configure_server(&block); end

    # Provide connection factory which
    # is a callable object with build
    # a Connection object
    #
    # source://anycable-core//lib/anycable.rb#37
    def connection_factory; end

    # Provide connection factory which
    # is a callable object with build
    # a Connection object
    #
    # source://anycable-core//lib/anycable.rb#37
    def connection_factory=(_arg0); end

    # source://anycable-core//lib/anycable.rb#46
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    #
    # source://anycable-core//lib/anycable.rb#42
    def logger=(_arg0); end

    # Returns the value of attribute middleware.
    #
    # source://anycable-core//lib/anycable.rb#44
    def middleware; end

    # source://anycable-core//lib/anycable.rb#103
    def rpc_handler; end

    # Sets the attribute rpc_handler
    #
    # @param value the value to set the attribute rpc_handler to.
    #
    # source://anycable-core//lib/anycable.rb#42
    def rpc_handler=(_arg0); end

    # Provide a method to build a server to serve RPC
    #
    # source://anycable-core//lib/anycable.rb#40
    def server_builder; end

    # Provide a method to build a server to serve RPC
    #
    # source://anycable-core//lib/anycable.rb#40
    def server_builder=(_arg0); end

    # source://anycable-core//lib/anycable.rb#75
    def server_callbacks; end

    private

    # Sets the attribute middleware
    #
    # @param value the value to set the attribute middleware to.
    #
    # source://anycable-core//lib/anycable.rb#109
    def middleware=(_arg0); end
  end
end

# source://anycable-core//lib/anycable/broadcast_adapters/base.rb#4
module AnyCable::BroadcastAdapters
  private

  # source://anycable-core//lib/anycable/broadcast_adapters.rb#9
  def lookup_adapter(args); end

  class << self
    # source://anycable-core//lib/anycable/broadcast_adapters.rb#9
    def lookup_adapter(args); end
  end
end

# source://anycable-core//lib/anycable/broadcast_adapters/base.rb#5
class AnyCable::BroadcastAdapters::Base
  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#41
  def announce!; end

  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#10
  def batching(enabled = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#25
  def batching?; end

  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#29
  def broadcast(stream, payload, options = T.unsafe(nil)); end

  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#37
  def broadcast_command(command, **payload); end

  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#21
  def finish_batching; end

  # @raise [NotImplementedError]
  #
  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#6
  def raw_broadcast(_data); end

  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#17
  def start_batching; end

  private

  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#47
  def batching_enabled=(val); end

  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#54
  def batching_enabled_stack; end

  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#58
  def current_batch; end

  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#73
  def logger; end

  # source://anycable-core//lib/anycable/broadcast_adapters/base.rb#62
  def maybe_flush_batch; end
end

# source://anycable-core//lib/anycable/rpc.rb#75
class AnyCable::CommandMessage < ::Google::Protobuf::AbstractMessage
  include ::AnyCable::WithConnectionState
end

# source://anycable-core//lib/anycable/rpc.rb#79
class AnyCable::CommandResponse < ::Google::Protobuf::AbstractMessage
  include ::AnyCable::WithConnectionState
  include ::AnyCable::StatusPredicates
end

# AnyCable configuration.
#
# source://anycable-core//lib/anycable/config.rb#9
class AnyCable::Config < ::Anyway::Config
  include ::AnyCable::GRPC::Config

  # source://anycable-core//lib/anycable/config.rb#109
  def broadcast_key!; end

  # source://anycable-core//lib/anycable/config.rb#28
  def debug?; end

  # source://anycable-core//lib/anycable/config.rb#104
  def http_broadcast_url; end

  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/config.rb#100
  def http_health_port_provided?; end

  # source://anycable-core//lib/anycable/config.rb#121
  def http_rpc_secret!; end

  # source://anycable-core//lib/anycable/config.rb#132
  def jwt_secret; end

  # source://anycable-core//lib/anycable/config.rb#92
  def load(*_args); end

  # source://anycable-core//lib/anycable/config.rb#96
  def log_level; end

  # source://anycable-core//lib/anycable/config.rb#28
  def nats_dont_randomize_servers?; end

  # source://anycable-core//lib/anycable/config.rb#28
  def redis_tls_verify?; end

  # source://anycable-core//lib/anycable/config.rb#28
  def sid_header_enabled?; end

  # source://anycable-core//lib/anycable/config.rb#128
  def streams_secret; end

  # Build HTTP health server parameters
  #
  # source://anycable-core//lib/anycable/config.rb#215
  def to_http_health_params; end

  # Build options for NATS.connect
  #
  # source://anycable-core//lib/anycable/config.rb#207
  def to_nats_params; end

  # Build Redis parameters
  #
  # source://anycable-core//lib/anycable/config.rb#173
  def to_redis_params; end

  # source://anycable-core//lib/anycable/config.rb#28
  def version_check_enabled?; end

  private

  # source://anycable-core//lib/anycable/config.rb#245
  def detect_presets; end

  # source://anycable-core//lib/anycable/config.rb#271
  def infer_from_application_secret(phrase); end

  # source://anycable-core//lib/anycable/config.rb#251
  def load_fly_presets; end

  # source://anycable-core//lib/anycable/config.rb#234
  def load_presets; end

  # source://anycable-core//lib/anycable/config.rb#224
  def parse_sentinel(sentinel); end

  # source://anycable-core//lib/anycable/config.rb#263
  def write_preset(key, value, preset:); end

  class << self
    # Add usage txt for CLI
    #
    # source://anycable-core//lib/anycable/config.rb#17
    def usage(txt); end

    # source://anycable-core//lib/anycable/config.rb#21
    def usages; end
  end
end

# These phareses are used to infer secret keys from the application secret
# and MUST match the ones used in AnyCable (Go)
#
# source://anycable-core//lib/anycable/config.rb#12
AnyCable::Config::BROADCAST_SECRET_PHRASE = T.let(T.unsafe(nil), String)

# source://anycable-core//lib/anycable/config.rb#13
AnyCable::Config::HTTP_RPC_SECRET_PHRASE = T.let(T.unsafe(nil), String)

class AnyCable::ConnectionRequest < ::Google::Protobuf::AbstractMessage; end

# source://anycable-core//lib/anycable/rpc.rb#70
class AnyCable::ConnectionResponse < ::Google::Protobuf::AbstractMessage
  include ::AnyCable::WithConnectionState
  include ::AnyCable::StatusPredicates
end

# source://anycable-core//lib/anycable/rpc.rb#84
class AnyCable::DisconnectRequest < ::Google::Protobuf::AbstractMessage
  include ::AnyCable::WithConnectionState
end

# source://anycable-core//lib/anycable/rpc.rb#88
class AnyCable::DisconnectResponse < ::Google::Protobuf::AbstractMessage
  include ::AnyCable::StatusPredicates
end

# source://anycable-core//lib/anycable/rpc.rb#94
class AnyCable::Env < ::Google::Protobuf::AbstractMessage
  # Returns the value of attribute sid.
  #
  # source://anycable-core//lib/anycable/rpc.rb#95
  def sid; end

  # Sets the attribute sid
  #
  # @param value the value to set the attribute sid to.
  #
  # source://anycable-core//lib/anycable/rpc.rb#95
  def sid=(_arg0); end
end

class AnyCable::EnvResponse < ::Google::Protobuf::AbstractMessage; end

# source://anycable-core//lib/anycable/exceptions_handling.rb#4
module AnyCable::ExceptionsHandling
  class << self
    # source://anycable-core//lib/anycable/exceptions_handling.rb#10
    def <<(block); end

    # source://anycable-core//lib/anycable/exceptions_handling.rb#6
    def add_handler(block); end

    # source://anycable-core//lib/anycable/exceptions_handling.rb#12
    def notify(exp, method_name, message); end

    private

    # source://anycable-core//lib/anycable/exceptions_handling.rb#30
    def handlers; end

    # source://anycable-core//lib/anycable/exceptions_handling.rb#24
    def procify(block); end
  end
end

# source://anycable-core//lib/anycable/grpc.rb#6
module AnyCable::GRPC; end

# source://anycable-core//lib/anycable/grpc/config.rb#22
module AnyCable::GRPC::Config
  # source://anycable-core//lib/anycable/grpc/config.rb#61
  def enhance_grpc_server_args(opts); end

  # source://anycable-core//lib/anycable/grpc/config.rb#23
  def log_grpc; end

  # Add alias explicitly, 'cause previous alias refers to the original log_grpc method
  #
  # source://anycable-core//lib/anycable/grpc/config.rb#28
  def log_grpc?; end

  # source://anycable-core//lib/anycable/grpc/config.rb#51
  def normalized_grpc_server_args; end

  # source://anycable-core//lib/anycable/grpc/config.rb#69
  def tls_credentials; end

  # Build gRPC server parameters
  #
  # source://anycable-core//lib/anycable/grpc/config.rb#31
  def to_grpc_params; end
end

# RPC service handler
#
# source://anycable-core//lib/anycable/grpc/handler.rb#10
class AnyCable::GRPC::Handler < ::AnyCable::GRPC::Service
  # source://anycable-core//lib/anycable/grpc/handler.rb#20
  def command(request, call); end

  # Handle connection request from WebSocket server
  #
  # source://anycable-core//lib/anycable/grpc/handler.rb#12
  def connect(request, call); end

  # source://anycable-core//lib/anycable/grpc/handler.rb#16
  def disconnect(request, call); end
end

# Wrapper over gRPC kit server.
#
# Basic example:
#
#   # create new server listening on the loopback interface with 50051 port
#   server = AnyCable::GrpcKit::Server.new(host: "127.0.0.1:50051")
#
#   # run gRPC server in bakground
#   server.start
#
#   # stop server
#   server.stop
#
# source://anycable-core//lib/anycable/grpc/server.rb#29
class AnyCable::GRPC::Server
  # @return [Server] a new instance of Server
  #
  # source://anycable-core//lib/anycable/grpc/server.rb#32
  def initialize(host:, logger: T.unsafe(nil), **options); end

  # Returns the value of attribute grpc_server.
  #
  # source://anycable-core//lib/anycable/grpc/server.rb#30
  def grpc_server; end

  # Returns the value of attribute host.
  #
  # source://anycable-core//lib/anycable/grpc/server.rb#30
  def host; end

  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/grpc/server.rb#69
  def running?; end

  # Start gRPC server in background and
  # wait untill it ready to accept connections
  #
  # source://anycable-core//lib/anycable/grpc/server.rb#40
  def start; end

  # Stop gRPC server if it's running
  #
  # source://anycable-core//lib/anycable/grpc/server.rb#61
  def stop; end

  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/grpc/server.rb#73
  def stopped?; end

  # source://anycable-core//lib/anycable/grpc/server.rb#54
  def wait_till_terminated; end

  private

  # source://anycable-core//lib/anycable/grpc/server.rb#94
  def build_health_checker; end

  # source://anycable-core//lib/anycable/grpc/server.rb#85
  def build_server(**options); end

  # source://anycable-core//lib/anycable/grpc/server.rb#81
  def logger; end

  # source://anycable-core//lib/anycable/grpc/server.rb#107
  def server_credentials(cert: T.unsafe(nil), pkey: T.unsafe(nil)); end

  # Returns the value of attribute start_thread.
  #
  # source://anycable-core//lib/anycable/grpc/server.rb#79
  def start_thread; end
end

# source://anycable-core//lib/anycable/grpc/rpc_services_pb.rb#10
class AnyCable::GRPC::Service
  include ::GRPC::GenericService
  extend ::GRPC::GenericService::Dsl

  # source://anycable-core//lib/anycable/grpc/rpc_services_pb.rb#18
  def command(*_arg0); end

  # source://anycable-core//lib/anycable/grpc/rpc_services_pb.rb#17
  def connect(*_arg0); end

  # source://anycable-core//lib/anycable/grpc/rpc_services_pb.rb#19
  def disconnect(*_arg0); end
end

# source://anycable-core//lib/anycable/grpc/rpc_services_pb.rb#22
class AnyCable::GRPC::Stub < ::GRPC::ClientStub
  # source://anycable-core//lib/anycable/grpc/rpc_services_pb.rb#22
  def initialize(host, creds, **kw); end

  # source://anycable-core//lib/anycable/grpc/rpc_services_pb.rb#22
  def command(req, metadata = T.unsafe(nil)); end

  # source://anycable-core//lib/anycable/grpc/rpc_services_pb.rb#22
  def connect(req, metadata = T.unsafe(nil)); end

  # source://anycable-core//lib/anycable/grpc/rpc_services_pb.rb#22
  def disconnect(req, metadata = T.unsafe(nil)); end
end

# source://anycable-core//lib/anycable/httrpc/server.rb#4
module AnyCable::HTTRPC; end

# source://anycable-core//lib/anycable/httrpc/server.rb#5
class AnyCable::HTTRPC::Server
  # @return [Server] a new instance of Server
  #
  # source://anycable-core//lib/anycable/httrpc/server.rb#6
  def initialize(token: T.unsafe(nil)); end

  # source://anycable-core//lib/anycable/httrpc/server.rb#15
  def call(env); end

  private

  # source://anycable-core//lib/anycable/httrpc/server.rb#54
  def build_meta(env); end

  # Returns the value of attribute token.
  #
  # source://anycable-core//lib/anycable/httrpc/server.rb#52
  def token; end
end

# Server for HTTP healthchecks.
#
# Basic usage:
#
#  # create a new healthcheck server for a specified
#  # server listening on the port
#  health_server = AnyCable::HealthServer.new(server, port)
#
#  # start health server in background
#  health_server.start
#
#  # stop health server
#  health_server.stop
#
# source://anycable-core//lib/anycable/health_server.rb#17
class AnyCable::HealthServer
  # @return [HealthServer] a new instance of HealthServer
  #
  # source://anycable-core//lib/anycable/health_server.rb#23
  def initialize(server, port:, logger: T.unsafe(nil), path: T.unsafe(nil)); end

  # Returns the value of attribute http_server.
  #
  # source://anycable-core//lib/anycable/health_server.rb#21
  def http_server; end

  # Returns the value of attribute path.
  #
  # source://anycable-core//lib/anycable/health_server.rb#21
  def path; end

  # Returns the value of attribute port.
  #
  # source://anycable-core//lib/anycable/health_server.rb#21
  def port; end

  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/health_server.rb#45
  def running?; end

  # Returns the value of attribute server.
  #
  # source://anycable-core//lib/anycable/health_server.rb#21
  def server; end

  # source://anycable-core//lib/anycable/health_server.rb#31
  def start; end

  # source://anycable-core//lib/anycable/health_server.rb#39
  def stop; end

  private

  # source://anycable-core//lib/anycable/health_server.rb#55
  def build_server; end

  # source://anycable-core//lib/anycable/health_server.rb#51
  def logger; end
end

# source://anycable-core//lib/anycable/health_server.rb#19
AnyCable::HealthServer::FAILURE_RESPONSE = T.let(T.unsafe(nil), Array)

# source://anycable-core//lib/anycable/health_server.rb#18
AnyCable::HealthServer::SUCCESS_RESPONSE = T.let(T.unsafe(nil), Array)

# source://anycable-core//lib/anycable/jwt.rb#8
module AnyCable::JWT
  class << self
    # @raise [ArgumentError]
    #
    # source://anycable-core//lib/anycable/jwt.rb#100
    def decode(token, secret_key: T.unsafe(nil)); end

    # @raise [ArgumentError]
    #
    # source://anycable-core//lib/anycable/jwt.rb#84
    def encode(payload, expires_at: T.unsafe(nil), secret_key: T.unsafe(nil), ttl: T.unsafe(nil)); end

    # Returns the value of attribute jwt_impl.
    #
    # source://anycable-core//lib/anycable/jwt.rb#82
    def jwt_impl; end

    # Sets the attribute jwt_impl
    #
    # @param value the value to set the attribute jwt_impl to.
    #
    # source://anycable-core//lib/anycable/jwt.rb#82
    def jwt_impl=(_arg0); end
  end
end

# Basic JWT encode/decode implementation suitable to our needs
# and not requiring external dependencies
#
# source://anycable-core//lib/anycable/jwt.rb#17
module AnyCable::JWT::BasicImpl
  class << self
    # source://anycable-core//lib/anycable/jwt.rb#31
    def decode(token, secret_key); end

    # source://anycable-core//lib/anycable/jwt.rb#21
    def encode(payload, secret_key); end

    # source://anycable-core//lib/anycable/jwt.rb#59
    def secure_compare(a, b); end

    # source://anycable-core//lib/anycable/jwt.rb#72
    def sign(data, secret_key); end
  end
end

# source://anycable-core//lib/anycable/jwt.rb#18
AnyCable::JWT::BasicImpl::ALGORITHM = T.let(T.unsafe(nil), String)

# source://anycable-core//lib/anycable/jwt.rb#9
class AnyCable::JWT::DecodeError < ::StandardError; end

# source://anycable-core//lib/anycable/jwt.rb#13
class AnyCable::JWT::ExpiredSignature < ::AnyCable::JWT::DecodeError; end

# source://anycable-core//lib/anycable/jwt.rb#11
class AnyCable::JWT::VerificationError < ::AnyCable::JWT::DecodeError; end

# Middleware is an analague of Rack middlewares but for AnyCable RPC calls
#
# source://anycable-core//lib/anycable/middleware.rb#5
class AnyCable::Middleware
  # @raise [NotImplementedError]
  #
  # source://anycable-core//lib/anycable/middleware.rb#6
  def call(_method_name, _request, _meta); end
end

# Middleware chain is used to build the list of
# gRPC server interceptors.
#
# Each interceptor should be a subsclass of
# AnyCable::Middleware and implement `#call` method.
#
# source://anycable-core//lib/anycable/middleware_chain.rb#12
class AnyCable::MiddlewareChain
  # @return [MiddlewareChain] a new instance of MiddlewareChain
  #
  # source://anycable-core//lib/anycable/middleware_chain.rb#13
  def initialize; end

  # source://anycable-core//lib/anycable/middleware_chain.rb#33
  def call(method_name, request, meta = T.unsafe(nil), &block); end

  # source://anycable-core//lib/anycable/middleware_chain.rb#24
  def freeze; end

  # source://anycable-core//lib/anycable/middleware_chain.rb#29
  def to_a; end

  # source://anycable-core//lib/anycable/middleware_chain.rb#18
  def use(middleware); end

  private

  # source://anycable-core//lib/anycable/middleware_chain.rb#61
  def build_middleware(middleware); end

  # source://anycable-core//lib/anycable/middleware_chain.rb#57
  def check_frozen!; end

  # source://anycable-core//lib/anycable/middleware_chain.rb#41
  def execute_next_middleware(ind, method_name, request, meta, block); end

  # Returns the value of attribute mu.
  #
  # source://anycable-core//lib/anycable/middleware_chain.rb#51
  def mu; end

  # Returns the value of attribute registry.
  #
  # source://anycable-core//lib/anycable/middleware_chain.rb#51
  def registry; end

  # source://anycable-core//lib/anycable/middleware_chain.rb#53
  def sync; end
end

# source://anycable-core//lib/anycable/middlewares/exceptions.rb#4
module AnyCable::Middlewares; end

# Checks that RPC client version is compatible with
# the current RPC proto version
#
# source://anycable-core//lib/anycable/middlewares/check_version.rb#7
class AnyCable::Middlewares::CheckVersion < ::AnyCable::Middleware
  # @return [CheckVersion] a new instance of CheckVersion
  #
  # source://anycable-core//lib/anycable/middlewares/check_version.rb#10
  def initialize(version); end

  # source://anycable-core//lib/anycable/middlewares/check_version.rb#14
  def call(_method, _request, meta); end

  # Returns the value of attribute version.
  #
  # source://anycable-core//lib/anycable/middlewares/check_version.rb#8
  def version; end

  private

  # source://anycable-core//lib/anycable/middlewares/check_version.rb#22
  def check_version(metadata); end
end

# Set sid for request.env from metadata
#
# source://anycable-core//lib/anycable/middlewares/env_sid.rb#6
class AnyCable::Middlewares::EnvSid < ::AnyCable::Middleware
  # source://anycable-core//lib/anycable/middlewares/env_sid.rb#7
  def call(_method, request, meta); end
end

# source://anycable-core//lib/anycable/middlewares/exceptions.rb#5
class AnyCable::Middlewares::Exceptions < ::AnyCable::Middleware
  # source://anycable-core//lib/anycable/middlewares/exceptions.rb#6
  def call(method_name, request, _meta); end

  private

  # source://anycable-core//lib/anycable/middlewares/exceptions.rb#19
  def notify_exception(exp, method_name, request); end

  # source://anycable-core//lib/anycable/middlewares/exceptions.rb#23
  def response_class(method_name); end
end

# source://anycable-core//lib/anycable/socket.rb#7
AnyCable::PRESENCE_KEY = T.let(T.unsafe(nil), String)

# Current RPC proto version (used for compatibility checks)
#
# source://anycable-core//lib/anycable/rpc.rb#10
AnyCable::PROTO_VERSION = T.let(T.unsafe(nil), String)

class AnyCable::PresenceResponse < ::Google::Protobuf::AbstractMessage; end

# source://anycable-core//lib/anycable/rpc/handlers/connect.rb#4
module AnyCable::RPC; end

# Generic RPC handler
#
# source://anycable-core//lib/anycable/rpc/handler.rb#10
class AnyCable::RPC::Handler
  include ::AnyCable::RPC::Handlers::Connect
  include ::AnyCable::RPC::Handlers::Disconnect
  include ::AnyCable::RPC::Handlers::Command

  # @return [Handler] a new instance of Handler
  #
  # source://anycable-core//lib/anycable/rpc/handler.rb#15
  def initialize(middleware: T.unsafe(nil)); end

  # source://anycable-core//lib/anycable/rpc/handler.rb#20
  def handle(cmd, data, meta = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/rpc/handler.rb#26
  def supported?(cmd); end

  private

  # source://anycable-core//lib/anycable/rpc/handler.rb#38
  def build_env_response(socket); end

  # source://anycable-core//lib/anycable/rpc/handler.rb#45
  def build_presence_response(socket); end

  # source://anycable-core//lib/anycable/rpc/handler.rb#34
  def build_socket(env:); end

  # Returns the value of attribute commands.
  #
  # source://anycable-core//lib/anycable/rpc/handler.rb#32
  def commands; end

  # source://anycable-core//lib/anycable/rpc/handler.rb#62
  def factory; end

  # source://anycable-core//lib/anycable/rpc/handler.rb#58
  def logger; end

  # Returns the value of attribute middleware.
  #
  # source://anycable-core//lib/anycable/rpc/handler.rb#32
  def middleware; end
end

# source://anycable-core//lib/anycable/rpc/handlers/connect.rb#5
module AnyCable::RPC::Handlers; end

# source://anycable-core//lib/anycable/rpc/handlers/command.rb#6
module AnyCable::RPC::Handlers::Command
  # source://anycable-core//lib/anycable/rpc/handlers/command.rb#7
  def command(message); end
end

# source://anycable-core//lib/anycable/rpc/handlers/connect.rb#6
module AnyCable::RPC::Handlers::Connect
  # source://anycable-core//lib/anycable/rpc/handlers/connect.rb#7
  def connect(request); end
end

# source://anycable-core//lib/anycable/rpc/handlers/disconnect.rb#6
module AnyCable::RPC::Handlers::Disconnect
  # source://anycable-core//lib/anycable/rpc/handlers/disconnect.rb#7
  def disconnect(request); end
end

# source://anycable-core//lib/anycable/rpc.rb#11
AnyCable::SESSION_KEY = T.let(T.unsafe(nil), String)

# Serializer is responsible for converting Ruby objects to and from a transferrable format (e.g., for identifiers, connection/channel state, etc.).
# It relies on configurable `.object_serializer` to handle non-primitive values and handles Hash/Array seririlzation.
#
# source://anycable-core//lib/anycable/serializer.rb#6
module AnyCable::Serializer
  class << self
    # Deserialize previously serialized value to a Ruby object.
    #
    # source://anycable-core//lib/anycable/serializer.rb#27
    def deserialize(val); end

    # Returns the value of attribute object_serializer.
    #
    # source://anycable-core//lib/anycable/serializer.rb#8
    def object_serializer; end

    # Sets the attribute object_serializer
    #
    # @param value the value to set the attribute object_serializer to.
    #
    # source://anycable-core//lib/anycable/serializer.rb#8
    def object_serializer=(_arg0); end

    # source://anycable-core//lib/anycable/serializer.rb#10
    def serialize(obj); end
  end
end

# Socket mock to be used with application connection
#
# source://anycable-core//lib/anycable/socket.rb#10
class AnyCable::Socket
  # @return [Socket] a new instance of Socket
  #
  # source://anycable-core//lib/anycable/socket.rb#52
  def initialize(env:); end

  # source://anycable-core//lib/anycable/socket.rb#103
  def close; end

  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/socket.rb#109
  def closed?; end

  # source://anycable-core//lib/anycable/socket.rb#137
  def cstate; end

  # source://anycable-core//lib/anycable/socket.rb#125
  def env; end

  # source://anycable-core//lib/anycable/socket.rb#131
  def istate; end

  # Returns the value of attribute presence.
  #
  # source://anycable-core//lib/anycable/socket.rb#50
  def presence; end

  # @raise [ArgumentError]
  #
  # source://anycable-core//lib/anycable/socket.rb#77
  def presence_join(broadcasting, id, info); end

  # @raise [ArgumentError]
  #
  # source://anycable-core//lib/anycable/socket.rb#86
  def presence_leave(id); end

  # source://anycable-core//lib/anycable/socket.rb#117
  def session; end

  # source://anycable-core//lib/anycable/socket.rb#121
  def session=(val); end

  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/socket.rb#113
  def stop_streams?; end

  # source://anycable-core//lib/anycable/socket.rb#99
  def streams; end

  # source://anycable-core//lib/anycable/socket.rb#61
  def subscribe(_channel, broadcasting); end

  # Returns the value of attribute transmissions.
  #
  # source://anycable-core//lib/anycable/socket.rb#50
  def transmissions; end

  # source://anycable-core//lib/anycable/socket.rb#57
  def transmit(websocket_message); end

  # source://anycable-core//lib/anycable/socket.rb#65
  def unsubscribe(_channel, broadcasting); end

  # source://anycable-core//lib/anycable/socket.rb#92
  def unsubscribe_from_all(_channel); end

  # source://anycable-core//lib/anycable/socket.rb#73
  def whisper(_channel, broadcasting); end

  private

  # source://anycable-core//lib/anycable/socket.rb#170
  def base_rack_env; end

  # source://anycable-core//lib/anycable/socket.rb#201
  def build_headers(headers); end

  # Build Rack env from request
  #
  # source://anycable-core//lib/anycable/socket.rb#148
  def build_rack_env; end

  # Returns the value of attribute request_env.
  #
  # source://anycable-core//lib/anycable/socket.rb#145
  def request_env; end
end

# Represents the per-connection store
# (for example, used to keep session beetween RPC calls)
#
# source://anycable-core//lib/anycable/socket.rb#13
class AnyCable::Socket::State
  # @return [State] a new instance of State
  #
  # source://anycable-core//lib/anycable/socket.rb#16
  def initialize(from); end

  # source://anycable-core//lib/anycable/socket.rb#25
  def [](key); end

  # source://anycable-core//lib/anycable/socket.rb#38
  def []=(key, val); end

  # source://anycable-core//lib/anycable/socket.rb#40
  def changed_fields; end

  # Returns the value of attribute dirty_keys.
  #
  # source://anycable-core//lib/anycable/socket.rb#14
  def dirty_keys; end

  # source://anycable-core//lib/anycable/socket.rb#21
  def read(key); end

  # Returns the value of attribute source.
  #
  # source://anycable-core//lib/anycable/socket.rb#14
  def source; end

  # source://anycable-core//lib/anycable/socket.rb#27
  def write(key, val); end
end

module AnyCable::Status
  class << self
    # source://anycable-core//lib/anycable/protos/rpc_pb.rb#23
    def descriptor; end

    # source://anycable-core//lib/anycable/protos/rpc_pb.rb#23
    def lookup(_arg0); end

    # source://anycable-core//lib/anycable/protos/rpc_pb.rb#23
    def resolve(_arg0); end
  end
end

# source://anycable-core//lib/anycable/protos/rpc_pb.rb#23
AnyCable::Status::ERROR = T.let(T.unsafe(nil), Integer)

# source://anycable-core//lib/anycable/protos/rpc_pb.rb#23
AnyCable::Status::FAILURE = T.let(T.unsafe(nil), Integer)

# source://anycable-core//lib/anycable/protos/rpc_pb.rb#23
AnyCable::Status::SUCCESS = T.let(T.unsafe(nil), Integer)

# Status predicates
#
# source://anycable-core//lib/anycable/rpc.rb#56
module AnyCable::StatusPredicates
  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/rpc.rb#65
  def error?; end

  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/rpc.rb#61
  def failure?; end

  # @return [Boolean]
  #
  # source://anycable-core//lib/anycable/rpc.rb#57
  def success?; end
end

# source://anycable-core//lib/anycable/streams.rb#8
module AnyCable::Streams
  class << self
    # source://anycable-core//lib/anycable/streams.rb#10
    def signed(stream_name); end

    # @raise [ArgumentError]
    #
    # source://anycable-core//lib/anycable/streams.rb#16
    def verified(signed_stream_name); end

    private

    # @raise [ArgumentError]
    #
    # source://anycable-core//lib/anycable/streams.rb#29
    def signature(val); end
  end
end

# source://anycable-core//lib/anycable/version.rb#4
AnyCable::VERSION = T.let(T.unsafe(nil), String)

# source://anycable-core//lib/anycable/socket.rb#6
AnyCable::WHISPER_KEY = T.let(T.unsafe(nil), String)

# Add setters/getter for cstate field
#
# source://anycable-core//lib/anycable/rpc.rb#14
module AnyCable::WithConnectionState
  # source://anycable-core//lib/anycable/rpc.rb#15
  def initialize(session: T.unsafe(nil), **other); end

  # source://anycable-core//lib/anycable/rpc.rb#38
  def cstate; end

  # source://anycable-core//lib/anycable/rpc.rb#42
  def cstate=(val); end

  # source://anycable-core//lib/anycable/rpc.rb#46
  def istate; end

  # source://anycable-core//lib/anycable/rpc.rb#50
  def istate=(val); end

  # source://anycable-core//lib/anycable/rpc.rb#31
  def session; end

  # source://anycable-core//lib/anycable/rpc.rb#23
  def session=(val); end
end

class Grpc::Health::V1::HealthCheckRequest < ::Google::Protobuf::AbstractMessage; end
class Grpc::Health::V1::HealthCheckResponse < ::Google::Protobuf::AbstractMessage; end
module Grpc::Health::V1::HealthCheckResponse::ServingStatus; end
