# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `trailblazer-activity-dsl-linear` gem.
# Please instead update this file by running `bin/tapioca gem trailblazer-activity-dsl-linear`.


# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/builder.rb#1
module Trailblazer; end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear.rb#4
class Trailblazer::Activity
  class << self
    # FastTrack
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#181
    def FastTrack(**options, &block); end

    # Path
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#87
    def Path(**options, &block); end

    # Railway
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#127
    def Railway(**options, &block); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear.rb#5
module Trailblazer::Activity::DSL; end

# Implementing a specific DSL, simplified version of the {Magnetic DSL} from 2017.
#
# Produces {Implementation} and {Intermediate}.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear.rb#9
module Trailblazer::Activity::DSL::Linear
  class << self
    # Normalizer-steps to implement {:input} and {:output}
    # Returns an Extension instance to be thrown into the `step` DSL arguments.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#7
    def VariableMapping(input_id: T.unsafe(nil), output_id: T.unsafe(nil), **options); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#15
class Trailblazer::Activity::DSL::Linear::DataVariableName; end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear.rb#20
module Trailblazer::Activity::DSL::Linear::Deprecate
  class << self
    # Used in combination with `Activity::Deprecate.warn`. Guesses the location
    # of the method call from the stacktrace.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear.rb#23
    def dsl_caller_location; end
  end
end

# Data Structures used in the DSL. They're mostly created from helpers
# and then get processed in the normalizer.
#
# @private
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#9
class Trailblazer::Activity::DSL::Linear::Extension < ::Struct
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#10
  def call(*args, &block); end

  # Returns the value of attribute callable
  #
  # @return [Object] the current value of callable
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#9
  def callable; end

  # Sets the attribute callable
  #
  # @param value [Object] the value to set the attribute callable to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#9
  def callable=(_); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#9
    def [](*_arg0); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#9
    def inspect; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#9
    def keyword_init?; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#9
    def members; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#9
    def new(*_arg0); end
  end
end

# Shortcut functions for the DSL.
# Those are included in {Strategy} so they're available to all Strategy users such
# as {Railway} or {Operation}.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#20
module Trailblazer::Activity::DSL::Linear::Helper
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#102
  def DataVariable; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#33
  def End(semantic); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#98
  def Extension(*args, **kws); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#45
  def Id(id); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#86
  def In(**kws); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#94
  def Inject(*args, **kws); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#90
  def Out(**kws); end

  # Output( Left, :failure )
  #   Output( :failure ) #=> Output::Semantic
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#27
  def Output(signal, semantic = T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#49
  def Path(end_task: T.unsafe(nil), end_id: T.unsafe(nil), **options, &block); end

  # Computes the {:outputs} options for {activity}.
  #
  # @param :strict If true, all outputs of {activity} will be wired to the track named after the
  #   output's semantic.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#67
  def Subprocess(activity, patch: T.unsafe(nil), strict: T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#41
  def Track(color, wrap_around: T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#37
  def end_id(semantic:, **_arg1); end
end

# This is the namespace container for {Contract::}, {Policy::} and friends.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#22
module Trailblazer::Activity::DSL::Linear::Helper::Constants; end

# Normalizer logic for {Path() do ... end}.
#
# TODO: it would be cool to be able to connect an (empty) path to specific termini,
#       this would work if we could add multiple magnetic_to.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#10
module Trailblazer::Activity::DSL::Linear::Helper::Path
  private

  # Connect last row of the {sequence} to the given step via its {Id}
  # Useful when steps needs to be inserted in between {Start} and {connect Id()}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#99
  def connect_for_sequence(sequence, connect_to:); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#50
  def convert_path_to_track(track_color: T.unsafe(nil), connect_to: T.unsafe(nil), before: T.unsafe(nil), block: T.unsafe(nil), terminus: T.unsafe(nil), **options); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#99
    def connect_for_sequence(sequence, connect_to:); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#50
    def convert_path_to_track(track_color: T.unsafe(nil), connect_to: T.unsafe(nil), before: T.unsafe(nil), block: T.unsafe(nil), terminus: T.unsafe(nil), **options); end
  end
end

# Normalizer steps to handle Path() macro.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#12
module Trailblazer::Activity::DSL::Linear::Helper::Path::Normalizer
  private

  # Convert all occurrences of Path() to a corresponding {Track}.
  # The {Track} instance contains all additional {adds} steps and
  # is picked up in {Normalizer.normalize_connections_from_dsl}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#38
  def convert_paths_to_tracks(ctx, non_symbol_options:, block: T.unsafe(nil), **_arg3); end

  # Replace a block-expecting {PathBranch} instance with another one that's holding
  # the global {:block} from {#step ... do end}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#17
  def forward_block_for_path_branch(ctx, options:, normalizer_options:, library_options:, **_arg4); end

  class << self
    # Convert all occurrences of Path() to a corresponding {Track}.
    # The {Track} instance contains all additional {adds} steps and
    # is picked up in {Normalizer.normalize_connections_from_dsl}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#38
    def convert_paths_to_tracks(ctx, non_symbol_options:, block: T.unsafe(nil), **_arg3); end

    # Replace a block-expecting {PathBranch} instance with another one that's holding
    # the global {:block} from {#step ... do end}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper/path.rb#17
    def forward_block_for_path_branch(ctx, options:, normalizer_options:, library_options:, **_arg4); end
  end
end

# TODO: remove this deprecation for 1.1.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear.rb#11
module Trailblazer::Activity::DSL::Linear::Insert
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear.rb#12
    def method(name); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/merge.rb#4
module Trailblazer::Activity::DSL::Linear::Merge
  class << self
    # Compile-time logic to merge two activities.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/merge.rb#19
    def call(old_seq, new_seq, end_id: T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/merge.rb#28
    def strip_start_and_ends(seq, end_id:); end
  end
end

# Class methods for {Strategy}.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/merge.rb#6
module Trailblazer::Activity::DSL::Linear::Merge::DSL
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/merge.rb#7
  def merge!(activity); end
end

# Normalizers are linear activities that process and normalize the options from a specific DSL call,
# such as `#step` or `#pass`. All defaulting should happen through the normalizer. An invoked
# normalizer produces an options hash that has to contain an [:adds] key with a ADDS structure usable
# for {Sequence.apply_adds}.
#
# They're usually invoked from {Strategy#invoke_normalizer_for!}, which is called from {Path#step},
# {Railway#pass}, etc.
#
# Most parts of Normalizer are documented: https://trailblazer.to/2.1/docs/internals.html#internals-dsl-normalizer
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#5
module Trailblazer::Activity::DSL::Linear::Normalizer
  private

  # The generic normalizer not tied to `step` or friends.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#80
  def Normalizer(prepend_to_default_outputs: T.unsafe(nil)); end

  # Wrap user's normalizer task in a {Pipeline::TaskAdapter} so it executes with
  # convenient kw args.
  #
  # Example
  #   normalizer_task = Normalizer.Task(method(:normalize_id))
  #
  #   # will call {normalizer_task} and pass ctx variables as kwargs, as follows
  #   def normalize_id(ctx, id: false, task:, **)
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#75
  def Task(user_step); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#260
  def clone_duplicate_activity(ctx, task:, sequence:, **_arg3); end

  # TODO: document DataVariable() => :name
  # Compile data that goes into the sequence row.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#301
  def compile_data(ctx, non_symbol_options:, default_variables_for_data: T.unsafe(nil), **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#291
  def create_add(ctx, row:, sequence_insert:, **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#295
  def create_adds(ctx, add:, adds:, **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#287
  def create_row(ctx, task:, wirings:, magnetic_to:, data:, **_arg5); end

  # Whenever {:replace} and {:inherit} are passed, automatically assign {:id}.
  # DISCUSS: this step could be nested in {inherit_option}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#279
  def id_with_inherit_and_replace(ctx, id: T.unsafe(nil), replace: T.unsafe(nil), inherit: T.unsafe(nil), **_arg4); end

  # TODO: remove this! it doesn't receive correct ciruit_options.
  # DISCUSS: should we remove this special case?
  # This handles
  #   step task: :instance_method_exposing_circuit_interface
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#152
  def macro_options_with_symbol_task(ctx, options:, **_arg2); end

  # {:library_options} such as :sequence, :dsl_track, etc.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#204
  def merge_library_options(ctx, options:, library_options:, **_arg3); end

  # {:normalizer_options} such as {:track_name} get overridden by user/macro.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#215
  def merge_normalizer_options(ctx, normalizer_options:, options:, **_arg3); end

  # make ctx[:options] the actual ctx
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#209
  def merge_user_options(ctx, options:, user_options:, **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#219
  def normalize_context(ctx, flow_options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#247
  def normalize_duplications(ctx, replace: T.unsafe(nil), **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#188
  def normalize_id(ctx, task:, id: T.unsafe(nil), **_arg3); end

  # Move DSL user options such as {Output(:success) => Track(:found)} to
  # a new key {options[:non_symbol_options]}.
  # This allows using {options} as a {**ctx}-able hash in Ruby 2.6 and 3.0.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#269
  def normalize_non_symbol_options(ctx, options:, **_arg2); end

  # TODO: remove {#normalize_override} in 1.2.0 (Used in macro-contract tests).
  # {:override} really only makes sense for {step Macro(), {override: true}} where the {user_options}
  # dictate the overriding.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#195
  def normalize_override(ctx, id:, override: T.unsafe(nil), **_arg3); end

  # Processes {:before,:after,:replace,:delete} options and
  # defaults to {before: "End.success"} which, yeah.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#227
  def normalize_sequence_insert(ctx, end_id:, **_arg2); end

  # After this step, options is always a hash.
  #
  # Specific to the "step DSL": if the first argument is a callable, wrap it in a {step_interface_builder}
  # since its interface expects the step interface, but the circuit will call it with circuit interface.
  #
  # @param The [:options] first argument passed to {#step}
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#168
  def normalize_step_interface(ctx, options:, **_arg2); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#255
  def raise_on_duplicate_id(ctx, id:, sequence:, **_arg3); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#238
  def sequence_insert_options; end

  # @param :wrap_task If true, the {:task} is wrapped using the step_interface_builder, meaning the
  #   task is expecting the step interface.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#182
  def wrap_task_with_step_interface(ctx, step_interface_builder:, task:, wrap_task: T.unsafe(nil), **_arg4); end

  class << self
    # The generic normalizer not tied to `step` or friends.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#80
    def Normalizer(prepend_to_default_outputs: T.unsafe(nil)); end

    # Wrap user's normalizer task in a {Pipeline::TaskAdapter} so it executes with
    # convenient kw args.
    #
    # Example
    #   normalizer_task = Normalizer.Task(method(:normalize_id))
    #
    #   # will call {normalizer_task} and pass ctx variables as kwargs, as follows
    #   def normalize_id(ctx, id: false, task:, **)
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#75
    def Task(user_step); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#260
    def clone_duplicate_activity(ctx, task:, sequence:, **_arg3); end

    # TODO: document DataVariable() => :name
    # Compile data that goes into the sequence row.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#301
    def compile_data(ctx, non_symbol_options:, default_variables_for_data: T.unsafe(nil), **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#291
    def create_add(ctx, row:, sequence_insert:, **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#295
    def create_adds(ctx, add:, adds:, **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#287
    def create_row(ctx, task:, wirings:, magnetic_to:, data:, **_arg5); end

    # Extend a particular normalizer with new steps and save it on the activity.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#52
    def extend!(activity_class, *step_methods); end

    # Whenever {:replace} and {:inherit} are passed, automatically assign {:id}.
    # DISCUSS: this step could be nested in {inherit_option}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#279
    def id_with_inherit_and_replace(ctx, id: T.unsafe(nil), replace: T.unsafe(nil), inherit: T.unsafe(nil), **_arg4); end

    # TODO: remove this! it doesn't receive correct ciruit_options.
    # DISCUSS: should we remove this special case?
    # This handles
    #   step task: :instance_method_exposing_circuit_interface
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#152
    def macro_options_with_symbol_task(ctx, options:, **_arg2); end

    # {:library_options} such as :sequence, :dsl_track, etc.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#204
    def merge_library_options(ctx, options:, library_options:, **_arg3); end

    # {:normalizer_options} such as {:track_name} get overridden by user/macro.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#215
    def merge_normalizer_options(ctx, normalizer_options:, options:, **_arg3); end

    # make ctx[:options] the actual ctx
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#209
    def merge_user_options(ctx, options:, user_options:, **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#219
    def normalize_context(ctx, flow_options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#247
    def normalize_duplications(ctx, replace: T.unsafe(nil), **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#188
    def normalize_id(ctx, task:, id: T.unsafe(nil), **_arg3); end

    # Move DSL user options such as {Output(:success) => Track(:found)} to
    # a new key {options[:non_symbol_options]}.
    # This allows using {options} as a {**ctx}-able hash in Ruby 2.6 and 3.0.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#269
    def normalize_non_symbol_options(ctx, options:, **_arg2); end

    # TODO: remove {#normalize_override} in 1.2.0 (Used in macro-contract tests).
    # {:override} really only makes sense for {step Macro(), {override: true}} where the {user_options}
    # dictate the overriding.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#195
    def normalize_override(ctx, id:, override: T.unsafe(nil), **_arg3); end

    # Processes {:before,:after,:replace,:delete} options and
    # defaults to {before: "End.success"} which, yeah.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#227
    def normalize_sequence_insert(ctx, end_id:, **_arg2); end

    # After this step, options is always a hash.
    #
    # Specific to the "step DSL": if the first argument is a callable, wrap it in a {step_interface_builder}
    # since its interface expects the step interface, but the circuit will call it with circuit interface.
    #
    # @param The [:options] first argument passed to {#step}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#168
    def normalize_step_interface(ctx, options:, **_arg2); end

    # Helper for normalizers.
    # To be applied on {Pipeline} instances.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#34
    def prepend_to(pipe, insertion_id, insertion); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#255
    def raise_on_duplicate_id(ctx, id:, sequence:, **_arg3); end

    # Helper for normalizers.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#44
    def replace(pipe, insertion_id, _arg2); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#238
    def sequence_insert_options; end

    # @param :wrap_task If true, the {:task} is wrapped using the step_interface_builder, meaning the
    #   task is expecting the step interface.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#182
    def wrap_task_with_step_interface(ctx, step_interface_builder:, task:, wrap_task: T.unsafe(nil), **_arg4); end
  end
end

# Implements {:extensions} option and allows adding taskWrap extensions using
# Linear::Normalizer::Extensions.Extension().
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#8
module Trailblazer::Activity::DSL::Linear::Normalizer::Extensions
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#13
  def Extension(is_generic: T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#30
  def compile_extensions(ctx, non_symbol_options:, **_arg2); end

  # Don't record Extension()s created by the DSL! This happens in VariableMapping, for instance.
  # Either the user also inherits I/O tuples and the extension will be recreated,
  # or they really don't want this particular extension to be inherited.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#45
  def compile_recorded_extensions(ctx, non_symbol_options:, **_arg2); end

  # Convert {:extensions} option to {Extension} tuples. The new way of adding extensions is
  #   step ..., Extension() => my_extension
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#19
  def convert_extensions_option_to_tuples(ctx, non_symbol_options:, extensions: T.unsafe(nil), **_arg3); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#13
    def Extension(is_generic: T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#30
    def compile_extensions(ctx, non_symbol_options:, **_arg2); end

    # Don't record Extension()s created by the DSL! This happens in VariableMapping, for instance.
    # Either the user also inherits I/O tuples and the extension will be recreated,
    # or they really don't want this particular extension to be inherited.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#45
    def compile_recorded_extensions(ctx, non_symbol_options:, **_arg2); end

    # Convert {:extensions} option to {Extension} tuples. The new way of adding extensions is
    #   step ..., Extension() => my_extension
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#19
    def convert_extensions_option_to_tuples(ctx, non_symbol_options:, extensions: T.unsafe(nil), **_arg3); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#11
class Trailblazer::Activity::DSL::Linear::Normalizer::Extensions::Extension < ::Struct
  # Returns the value of attribute generic?
  #
  # @return [Object] the current value of generic?
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#11
  def generic?; end

  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#11
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#11
  def id=(_); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#11
    def [](*_arg0); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#11
    def inspect; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#11
    def keyword_init?; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#11
    def members; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/extensions.rb#11
    def new(*_arg0); end
  end
end

# "generic": built by the DSL from options, options that are inherited, so you might not want to record or inherit generic options
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#11
module Trailblazer::Activity::DSL::Linear::Normalizer::Inherit
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#18
  def Record(options, type:, non_symbol_options: T.unsafe(nil)); end

  # Record
  # Figure out what to remember from the options and store it in {row.data[:recorded_options]}.
  # Note that this is generic logic not tied to variable_mapping, OutputTuples or anything.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#70
  def compile_recorded_options(ctx, non_symbol_options:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#62
  def find_row(sequence, id); end

  # Currently, the {:inherit} option copies over {:extensions} from the original step and merges them with new :extensions.
  #
  # Recall
  # Fetch remembered options and add them to the processed options.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#26
  def recall_recorded_options(ctx, non_symbol_options:, sequence:, id:, inherit: T.unsafe(nil), extensions: T.unsafe(nil), **_arg6); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#18
    def Record(options, type:, non_symbol_options: T.unsafe(nil)); end

    # Record
    # Figure out what to remember from the options and store it in {row.data[:recorded_options]}.
    # Note that this is generic logic not tied to variable_mapping, OutputTuples or anything.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#70
    def compile_recorded_options(ctx, non_symbol_options:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#62
    def find_row(sequence, id); end

    # Currently, the {:inherit} option copies over {:extensions} from the original step and merges them with new :extensions.
    #
    # Recall
    # Fetch remembered options and add them to the processed options.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#26
    def recall_recorded_options(ctx, non_symbol_options:, sequence:, id:, inherit: T.unsafe(nil), extensions: T.unsafe(nil), **_arg6); end
  end
end

# Options you want to have stored and inherited can be
# declared using Record.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
class Trailblazer::Activity::DSL::Linear::Normalizer::Inherit::Record < ::Struct
  # Returns the value of attribute non_symbol_options?
  #
  # @return [Object] the current value of non_symbol_options?
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
  def non_symbol_options?; end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
  def options=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
  def type=(_); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
    def [](*_arg0); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
    def inspect; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
    def keyword_init?; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
    def members; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/inherit.rb#16
    def new(*_arg0); end
  end
end

# Container for all final normalizers of a specific Strategy.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#16
class Trailblazer::Activity::DSL::Linear::Normalizer::Normalizers
  # @return [Normalizers] a new instance of Normalizers
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#17
  def initialize(**options); end

  # Execute the specific normalizer (step, fail, pass) for a particular option set provided
  # by the DSL user. Usually invoked when you call {#step}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer.rb#23
  def call(name, ctx); end
end

# Implements Output(:success) => Track(:success)
# Internals are documented: https://trailblazer.to/2.1/docs/internals.html#internals-wiring-api-output-tuples
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#8
module Trailblazer::Activity::DSL::Linear::Normalizer::OutputTuples
  private

  # Logic related to {Output() => ...}, called "Wiring API".
  # TODO: move to different namespace (feature/dsl)
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#43
  def Output(semantic, is_generic: T.unsafe(nil)); end

  # Implements {inherit: :outputs, strict: false}
  # return connections from {parent} step which are supported by current step
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#98
  def filter_inherited_output_tuples(ctx, outputs:, output_tuples:, inherit: T.unsafe(nil), inherited_recorded_options: T.unsafe(nil), **_arg5); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#53
  def normalize_output_tuples(ctx, non_symbol_options:, **_arg2); end

  # Take all Output(signal, semantic), convert to OutputSemantic and extend {:outputs}.
  # Since only users use this style, we don't have to filter.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#74
  def register_additional_outputs(ctx, output_tuples:, outputs:, **_arg3); end

  # Remember all custom (non-generic) {:output_tuples}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#60
  def remember_custom_output_tuples(ctx, output_tuples:, non_symbol_options:, **_arg3); end

  class << self
    # Logic related to {Output() => ...}, called "Wiring API".
    # TODO: move to different namespace (feature/dsl)
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#43
    def Output(semantic, is_generic: T.unsafe(nil)); end

    # Implements {inherit: :outputs, strict: false}
    # return connections from {parent} step which are supported by current step
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#98
    def filter_inherited_output_tuples(ctx, outputs:, output_tuples:, inherit: T.unsafe(nil), inherited_recorded_options: T.unsafe(nil), **_arg5); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#53
    def normalize_output_tuples(ctx, non_symbol_options:, **_arg2); end

    # Take all Output(signal, semantic), convert to OutputSemantic and extend {:outputs}.
    # Since only users use this style, we don't have to filter.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#74
    def register_additional_outputs(ctx, output_tuples:, outputs:, **_arg3); end

    # Remember all custom (non-generic) {:output_tuples}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#60
    def remember_custom_output_tuples(ctx, output_tuples:, non_symbol_options:, **_arg3); end
  end
end

# Compile connections from tuples.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#120
module Trailblazer::Activity::DSL::Linear::Normalizer::OutputTuples::Connections
  private

  # Returns ADDS for the new terminus.
  #
  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#149
  def add_terminus(end_event, id:, sequence:, normalizers:); end

  # we want this in the end:
  # {output.semantic => search strategy}
  # Process {Output(:semantic) => target} and make them {:connections}.
  # This combines {:connections} and {:outputs}
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#127
  def compile_wirings(ctx, adds:, output_tuples:, outputs:, id:, **_arg5); end

  class << self
    # Returns ADDS for the new terminus.
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#149
    def add_terminus(end_event, id:, sequence:, normalizers:); end

    # we want this in the end:
    # {output.semantic => search strategy}
    # Process {Output(:semantic) => target} and make them {:connections}.
    # This combines {:connections} and {:outputs}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#127
    def compile_wirings(ctx, adds:, output_tuples:, outputs:, id:, **_arg5); end
  end
end

# Connector representing a (to-be-created?) terminus when using End(:semantic).
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#28
class Trailblazer::Activity::DSL::Linear::Normalizer::OutputTuples::End < ::Struct
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#29
  def to_a(ctx); end
end

# Connector when using Id(:validate).
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#12
class Trailblazer::Activity::DSL::Linear::Normalizer::OutputTuples::Id < ::Struct
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#13
  def to_a(*_arg0); end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#47
module Trailblazer::Activity::DSL::Linear::Normalizer::OutputTuples::Output; end

# generic? is always false
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
class Trailblazer::Activity::DSL::Linear::Normalizer::OutputTuples::Output::CustomOutput < ::Struct
  include ::Trailblazer::Activity::DSL::Linear::Normalizer::OutputTuples::Output

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
  def generic?; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
  def semantic; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
  def semantic=(_); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
  def signal; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
  def signal=(_); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
    def [](*_arg0); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
    def inspect; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
    def keyword_init?; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
    def members; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#50
    def new(*_arg0); end
  end
end

# Note that both {Semantic} and {CustomOutput} are {is_a?(Output)}
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#49
class Trailblazer::Activity::DSL::Linear::Normalizer::OutputTuples::Output::Semantic < ::Struct
  include ::Trailblazer::Activity::DSL::Linear::Normalizer::OutputTuples::Output

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#49
  def generic?; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#49
  def semantic; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#49
  def semantic=(_); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#49
    def [](*_arg0); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#49
    def inspect; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#49
    def keyword_init?; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#49
    def members; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#49
    def new(*_arg0); end
  end
end

# Connector when using Track(:success).
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#19
class Trailblazer::Activity::DSL::Linear::Normalizer::OutputTuples::Track < ::Struct
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/output_tuples.rb#20
  def to_a(*_arg0); end
end

# Normalizer pipeline for the {terminus} DSL method.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#7
module Trailblazer::Activity::DSL::Linear::Normalizer::Terminus
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#10
  def Normalizer; end

  # you cannot override using {:semantic}
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#51
  def _normalize_task_for_end_event(ctx, task:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#57
  def _normalize_task_for_symbol(ctx, task:, semantic: T.unsafe(nil), **_arg3); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#71
  def append_end(ctx, task:, non_symbol_options:, append_to: T.unsafe(nil), **_arg4); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#34
  def normalize_id(ctx, semantic:, id: T.unsafe(nil), **_arg3); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#65
  def normalize_magnetic_to(ctx, semantic:, magnetic_to: T.unsafe(nil), **_arg3); end

  # Set {:task} and {:semantic}.
  #
  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#42
  def normalize_task(ctx, task:, **_arg2); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#10
    def Normalizer; end

    # you cannot override using {:semantic}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#51
    def _normalize_task_for_end_event(ctx, task:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#57
    def _normalize_task_for_symbol(ctx, task:, semantic: T.unsafe(nil), **_arg3); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#71
    def append_end(ctx, task:, non_symbol_options:, append_to: T.unsafe(nil), **_arg4); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#34
    def normalize_id(ctx, semantic:, id: T.unsafe(nil), **_arg3); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#65
    def normalize_magnetic_to(ctx, semantic:, magnetic_to: T.unsafe(nil), **_arg3); end

    # Set {:task} and {:semantic}.
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/normalizer/terminus.rb#42
    def normalize_task(ctx, task:, **_arg2); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/patch.rb#4
module Trailblazer::Activity::DSL::Linear::Patch
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/patch.rb#18
    def call(activity, path, customization, patched_activity: T.unsafe(nil)); end

    # Currently, this is called from the Subprocess() helper.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/patch.rb#6
    def customize(activity, options:); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/patch.rb#36
module Trailblazer::Activity::DSL::Linear::Patch::DSL
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/patch.rb#37
  def patch(*path, &block); end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#14
class Trailblazer::Activity::DSL::Linear::PathBranch < ::Struct
  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#14
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#14
  def options=(_); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#14
    def [](*_arg0); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#14
    def inspect; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#14
    def keyword_init?; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#14
    def members; end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/helper.rb#14
    def new(*_arg0); end
  end
end

# A {Sequence} consists of rows, each row represents one step (or task) of an activity
# and its incoming and outgoing connections.
# {Sequence row} consisting of {[magnetic_to, task, connections_searches, data]}.
# A Sequence is compiled into an activity using {Compiler}.
#
# Complies with the Adds interface (#to_a).
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence.rb#10
class Trailblazer::Activity::DSL::Linear::Sequence < ::Array
  class << self
    # Return {Sequence row} consisting of {[magnetic_to, task, connections_searches, data]}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence.rb#23
    def create_row(task:, magnetic_to:, wirings:, **data); end
  end
end

# Run a normalizer for a user DSL input, and then apply the new step using the ADDS interface
# to the sequence.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/builder.rb#8
module Trailblazer::Activity::DSL::Linear::Sequence::Builder
  class << self
    # @return Sequence
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/builder.rb#10
    def call(method, argument, options, **kws, &block); end

    # DISCUSS: used in {Normalizer#add_terminus}, too.
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/builder.rb#25
    def invoke_normalizer_for(type, task, options, normalizers:, normalizer_options:, sequence:, &block); end

    # Run a specific normalizer (e.g. for `#step`), apply the adds to the sequence and return the latter.
    # DISCUSS: where does this method belong? Sequence + Normalizers?
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/builder.rb#17
    def update_sequence_for(type, task, options = T.unsafe(nil), sequence:, **kws, &block); end
  end
end

# Compile a {Schema} by computing {implementations} and {intermediate} from a {Sequence}.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#7
module Trailblazer::Activity::DSL::Linear::Sequence::Compiler
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#22
  def call(sequence, find_stops: T.unsafe(nil), find_start: T.unsafe(nil)); end

  # Execute all search strategies for a row, retrieve outputs and
  # their respective target IDs.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#76
  def find_connections(seq_row, searches, sequence); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#18
  def find_start_task(sequence); end

  # Default strategy to find out what's a stop event is to inspect the TaskRef's {data[:stop_event]}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#11
  def find_termini(sequence); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#22
    def call(sequence, find_stops: T.unsafe(nil), find_start: T.unsafe(nil)); end

    # Execute all search strategies for a row, retrieve outputs and
    # their respective target IDs.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#76
    def find_connections(seq_row, searches, sequence); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#18
    def find_start_task(sequence); end

    # Default strategy to find out what's a stop event is to inspect the TaskRef's {data[:stop_event]}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/compiler.rb#11
    def find_termini(sequence); end
  end
end

# Row interface is part of the ADDs specification.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence.rb#12
class Trailblazer::Activity::DSL::Linear::Sequence::Row < ::Array
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence.rb#17
  def data; end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence.rb#13
  def id; end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#7
module Trailblazer::Activity::DSL::Linear::Sequence::Search
  private

  # Find the seq_row with {id} and connect the current node to it.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#35
  def ById(output, id); end

  # From this task onwards, find the next task that's "magnetic to" {target_color}.
  # Note that we only go forward, no back-references are done here.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#12
  def Forward(output, target_color); end

  # Tries to find a track colored step by doing a Forward-search, first, then wraps around going
  # through all steps from sequence start to self.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#22
  def WrapAround(output, target_color); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#45
  def find_in_range(range, target_color); end

  class << self
    # Find the seq_row with {id} and connect the current node to it.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#35
    def ById(output, id); end

    # From this task onwards, find the next task that's "magnetic to" {target_color}.
    # Note that we only go forward, no back-references are done here.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#12
    def Forward(output, target_color); end

    # Tries to find a track colored step by doing a Forward-search, first, then wraps around going
    # through all steps from sequence start to self.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#22
    def WrapAround(output, target_color); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/sequence/search.rb#45
    def find_in_range(range, target_color); end
  end
end

# {Activity}
#   holds the {@schema}
#   provides DSL step/merge!
#   provides DSL inheritance
#   provides run-time {call}
#   maintains the {state} with {seq} and normalizer options
# This could be a class but we decided to leave it as a module that then gets
# extended into {Path} and friends. This won't trigger the inheritance (because)
# there is nothing to inherit.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#14
class Trailblazer::Activity::DSL::Linear::Strategy
  include ::Trailblazer::Activity::DSL::Linear::Helper::Constants
  extend ::Trailblazer::Activity::DSL::Linear::Helper
  extend ::Trailblazer::Activity::DSL::Linear::Merge::DSL

  class << self
    # Injects {:exec_context} so that {:instance_method}s work.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#103
    def call(args, **circuit_options); end

    # Used only once per strategy class body.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#78
    def compile_strategy!(strategy_dsl, **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#84
    def compile_strategy_for!(sequence:, normalizers:, **normalizer_options); end

    # FIXME: move to State#dup
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#174
    def copy(value, **_arg1); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#23
    def inherited(inheriter); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#19
    def initialize!(state); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#112
    def invoke(*args, **kws); end

    # DISCUSS: this should be the only way to "update" anything on state.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#70
    def recompile!(sequence); end

    # We forward `step` to the Dsl (State) object.
    # Recompiling the activity/sequence is a matter specific to Strategy (Railway etc).
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#33
    def step(*args, &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#37
    def terminus(*args); end

    # Mainly used for introspection.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#92
    def to_h; end

    private

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#49
    def apply_step_on_sequence_builder(type, arg, options = T.unsafe(nil), &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#63
    def recompile_activity(sequence); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#41
    def recompile_activity_for(type, *args, &block); end
  end
end

# class << self
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#117
module Trailblazer::Activity::DSL::Linear::Strategy::DSL
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#126
  def Build(strategy, **options, &block); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#134
  def OptionsForSequenceBuilder(strategy_dsl, termini: T.unsafe(nil), **user_options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#162
  def append_terminus(sequence, task, normalizers:, **options); end

  # Wraps {user_step} into a circuit-interface compatible callable, a.k.a. "task".
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#168
  def build_circuit_task_for_step(user_step); end

  # If no {:termini} were provided by the Strategy user, we use the default
  # {strategy_termini}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#154
  def process_termini(sequence, termini, **options_for_append_terminus); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#120
  def start_sequence(wirings: T.unsafe(nil)); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#126
    def Build(strategy, **options, &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#134
    def OptionsForSequenceBuilder(strategy_dsl, termini: T.unsafe(nil), **user_options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#162
    def append_terminus(sequence, task, normalizers:, **options); end

    # Wraps {user_step} into a circuit-interface compatible callable, a.k.a. "task".
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#168
    def build_circuit_task_for_step(user_step); end

    # If no {:termini} were provided by the Strategy user, we use the default
    # {strategy_termini}.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#154
    def process_termini(sequence, termini, **options_for_append_terminus); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/strategy.rb#120
    def start_sequence(wirings: T.unsafe(nil)); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#14
module Trailblazer::Activity::DSL::Linear::VariableMapping
  private

  # Merge all original ctx variables into the new input_ctx.
  # This happens when no {:input} is provided.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#54
  def default_input_ctx(wrap_ctx, original_args); end

  # The default {:output} filter only returns the "mutable" part of the inner ctx.
  # This means only variables added using {inner_ctx[..]=} are merged on the outside.
  #
  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#259
  def default_output_ctx(wrap_ctx, original_args); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#135
  def deprecation_link; end

  # For the input filter we
  #   1. create a separate {Pipeline} instance {pipe}. Depending on the user's options, this might have up to four steps.
  #   2. The {pipe} is run in a lamdba {input}, the lambda returns the pipe's ctx[:input_ctx].
  #   3. The {input} filter in turn is wrapped into an {Activity::TaskWrap::Input} object via {#merge_instructions_for}.
  #   4. The {TaskWrap::Input} instance is then finally placed into the taskWrap as {"task_wrap.input"}.
  #
  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#125
  def merge_instructions_from_dsl(**options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#234
  def merge_variables(variables, wrap_ctx, original_args, receiver = T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#267
  def merge_with_original(wrap_ctx, original_args); end

  # Finally, create a new input ctx from all the
  # collected input variables.
  # This goes into the step/nested OP.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#243
  def scope(wrap_ctx, original_args); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#31
    def Extension(input, output, input_id: T.unsafe(nil), output_id: T.unsafe(nil)); end

    # Merge all original ctx variables into the new input_ctx.
    # This happens when no {:input} is provided.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#54
    def default_input_ctx(wrap_ctx, original_args); end

    # The default {:output} filter only returns the "mutable" part of the inner ctx.
    # This means only variables added using {inner_ctx[..]=} are merged on the outside.
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#259
    def default_output_ctx(wrap_ctx, original_args); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#135
    def deprecation_link; end

    # Add our normalizer steps to the strategy's normalizer.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#16
    def extend!(strategy, *step_methods); end

    # For the input filter we
    #   1. create a separate {Pipeline} instance {pipe}. Depending on the user's options, this might have up to four steps.
    #   2. The {pipe} is run in a lamdba {input}, the lambda returns the pipe's ctx[:input_ctx].
    #   3. The {input} filter in turn is wrapped into an {Activity::TaskWrap::Input} object via {#merge_instructions_for}.
    #   4. The {TaskWrap::Input} instance is then finally placed into the taskWrap as {"task_wrap.input"}.
    #
    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#125
    def merge_instructions_from_dsl(**options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#234
    def merge_variables(variables, wrap_ctx, original_args, receiver = T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#267
    def merge_with_original(wrap_ctx, original_args); end

    # Finally, create a new input ctx from all the
    # collected input variables.
    # This goes into the step/nested OP.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#243
    def scope(wrap_ctx, original_args); end
  end
end

# Add a hash of variables to aggregate after running a filter (which returns a hash!).
# Note that we only use those for "old-style" callables that produce hashes.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#200
class Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#201
    def set_variable(variables, write_name, wrap_ctx, original_args); end
  end
end

# Merge hash of Out into aggregate.
# TODO: deprecate and remove.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#208
class Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables::Output < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::Output
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#209
    def set_variable(*args); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#223
class Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables::Output::WithOuterContext < ::Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables::Output
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#224
    def call_filter(filter, wrap_ctx, _arg2); end
  end
end

# Pass {inner_ctx, outer_ctx, **inner_ctx}
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#214
class Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables::Output::WithOuterContext_Deprecated < ::Trailblazer::Activity::DSL::Linear::VariableMapping::AddVariables::Output
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#215
    def call_filter(filter, wrap_ctx, _arg2); end
  end
end

# Code invoked through the normalizer, building runtime structures.
# Naming
#   Option: Tuple => user filter
#   Tuple: #<In ...>
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#10
module Trailblazer::Activity::DSL::Linear::VariableMapping::DSL
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#75
  def add_filter_steps(pipeline, rows, prepend_to: T.unsafe(nil), path_prefix: T.unsafe(nil)); end

  # Handle {:input} and {:inject} option, the "old" interface.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#46
  def add_steps_for_input_option(pipeline, input:); end

  # Returns array of step rows ("sequence").
  #
  # @param filters [Array] List of {Filter} objects
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#87
  def add_variables_steps_for_filters(filters, path_prefix:); end

  # almost a Row.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#41
  def default_input_ctx_config; end

  # almost a Row.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#71
  def default_output_ctx_config; end

  # Adds the default_ctx step as per option {:add_default_ctx}
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#27
  def initial_input_pipeline(add_default_ctx: T.unsafe(nil)); end

  # initial pipleline depending on whether or not we got any In() filters.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#20
  def initial_input_pipeline_for(in_filters); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#59
  def initial_output_pipeline(add_default_ctx: T.unsafe(nil)); end

  # Compute pipeline for In() and Inject().
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#14
  def pipe_for_composable_input(in_filters: T.unsafe(nil), initial_input_pipeline: T.unsafe(nil), **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#53
  def pipe_for_composable_output(out_filters: T.unsafe(nil), initial_output_pipeline: T.unsafe(nil), **_arg2); end

  class << self
    # Out
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#220
    def In(variable_name = T.unsafe(nil), add_variables_class: T.unsafe(nil), filter_builder: T.unsafe(nil), add_variables_class_for_callable: T.unsafe(nil)); end

    # Used in the DSL by you.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#239
    def Inject(variable_name = T.unsafe(nil), override: T.unsafe(nil), **_arg2); end

    # Builder for a DSL Output() object.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#225
    def Out(variable_name = T.unsafe(nil), add_variables_class: T.unsafe(nil), with_outer_ctx: T.unsafe(nil), delete: T.unsafe(nil), filter_builder: T.unsafe(nil), read_from_aggregate: T.unsafe(nil), add_variables_class_for_callable: T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#75
    def add_filter_steps(pipeline, rows, prepend_to: T.unsafe(nil), path_prefix: T.unsafe(nil)); end

    # Handle {:input} and {:inject} option, the "old" interface.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#46
    def add_steps_for_input_option(pipeline, input:); end

    # Returns array of step rows ("sequence").
    #
    # @param filters [Array] List of {Filter} objects
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#87
    def add_variables_steps_for_filters(filters, path_prefix:); end

    # almost a Row.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#41
    def default_input_ctx_config; end

    # almost a Row.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#71
    def default_output_ctx_config; end

    # Adds the default_ctx step as per option {:add_default_ctx}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#27
    def initial_input_pipeline(add_default_ctx: T.unsafe(nil)); end

    # initial pipleline depending on whether or not we got any In() filters.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#20
    def initial_input_pipeline_for(in_filters); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#59
    def initial_output_pipeline(add_default_ctx: T.unsafe(nil)); end

    # Compute pipeline for In() and Inject().
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#14
    def pipe_for_composable_input(in_filters: T.unsafe(nil), initial_input_pipeline: T.unsafe(nil), **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#53
    def pipe_for_composable_output(out_filters: T.unsafe(nil), initial_output_pipeline: T.unsafe(nil), **_arg2); end
  end
end

# DISCUSS: generic, again
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#330
module Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Filter
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#331
    def build(add_variables_class:, **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#346
    def build_filters_for_hash(user_filter, **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#337
    def build_for_reading(read_name:, **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#357
    def hash_for(ary); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#361
    def name_for(type, name, specifier = T.unsafe(nil)); end
  end
end

# In, Out and Inject are objects instantiated when using the DSL, for instance {In() => [:model]}.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#130
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::In < ::Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Tuple; end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#131
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::In::FiltersBuilder
  class << self
    # Simply invoke user's filter.
    # Use this for filters without condition and default.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#173
    def build_for_option(user_filter, **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#132
    def call(user_filter, add_variables_class:, add_variables_class_for_callable:, type: T.unsafe(nil), **options); end
  end
end

# This class is supposed to hold configuration options for Inject().
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#250
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Inject < ::Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Tuple; end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#251
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Inject::FiltersBuilder
  class << self
    # Called via {Tuple#call}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#253
    def call(user_filter, add_variables_class:, variable_name:, **options); end

    # call
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#306
    def options_with_condition(user_filter:, write_name:, name_specifier: T.unsafe(nil), **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#316
    def options_with_condition_for_defaulted(user_filter:, **options); end
  end
end

# In
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#187
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Out < ::Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Tuple; end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#188
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Out::FiltersBuilder
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#189
    def call(user_filter, with_outer_ctx:, **options); end
  end
end

# Keeps user's DSL configuration for a particular io-pipe step.
# Implements the interface for the actual I/O code and is DSL code happening in the normalizer.
# The actual I/O code expects {DSL::In} and {DSL::Out} objects to generate the two io-pipes.
#
# If a user needs to inject their own private iop step they can create this data structure with desired values here.
# This is also the reason why a lot of options computation such as {:with_outer_ctx} happens here and not in the IO code.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#100
class Trailblazer::Activity::DSL::Linear::VariableMapping::DSL::Tuple
  # @return [Tuple] a new instance of Tuple
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#101
  def initialize(variable_name, add_variables_class, filters_builder, add_variables_class_for_callable = T.unsafe(nil), insert_args: T.unsafe(nil), **options); end

  # @return [Filter] Filter instance that keeps {name} and {aggregate_step}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#124
  def call(user_filter); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#115
  def to_h; end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/dsl.rb#119
    def filters_from_options(tuples_to_user_filters); end
  end
end

# Steps that are added to the DSL normalizer.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#39
module Trailblazer::Activity::DSL::Linear::VariableMapping::Normalizer
  class << self
    # TODO: remove me once {:input} API is removed.
    # Convert {:input}, {:output} and {:inject} to In() and friends.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#42
    def convert_symbol_options(ctx, non_symbol_options:, output_with_outer_ctx: T.unsafe(nil), **_arg3); end

    # TODO: remove for TRB 2.2.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#102
    def deprecate_input_output_inject_option(input_output_inject_options, *composable_options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#85
    def input_output_dsl(ctx, non_symbol_options:, in_filters: T.unsafe(nil), out_filters: T.unsafe(nil), **options); end

    # Process {In() => [:model], Inject() => [:current_user], Out() => [:model]}
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping.rb#73
    def normalize_input_output_filters(ctx, non_symbol_options:, input_output_inject_options: T.unsafe(nil), **_arg3); end
  end
end

# These objects are created via the DSL, keep all i/o steps in a Pipeline
# and run the latter when being `call`ed.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#11
module Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe; end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#12
class Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Input
  # @return [Input] a new instance of Input
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#13
  def initialize(pipe, id: T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#18
  def call(wrap_ctx, original_args); end
end

# API in VariableMapping::Output:
#   output_ctx = @filter.(returned_ctx, [original_ctx, returned_flow_options], **original_circuit_options)
# Returns {output_ctx} that is used after taskWrap finished.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#35
class Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Output < ::Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Input
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#36
  def call(wrap_ctx, original_args); end
end

# TODO: * ALL FILTERS and conditions expose circuit-step interface.
# Call {user_filter} and set return value as variable on aggregate.
#
# @param name Identifier for the pipeline
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#91
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  # @return [SetVariable] a new instance of SetVariable
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#92
  def initialize(write_name:, filter:, user_filter:, name:, **_arg4); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#100
  def call(wrap_ctx, original_args, filter = T.unsafe(nil)); end

  # TODO: used when adding to pipeline, change to to_h
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#98
  def name; end

  class << self
    # Call a filter with a Circuit-Step interface.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#114
    def call_filter(filter, wrap_ctx, _arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#119
    def set_variable(value, write_name, wrap_ctx, original_args); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#106
    def set_variable_for_filter(filter, write_name, wrap_ctx, original_args); end
  end
end

# Set variable on ctx if {condition} is true.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#125
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::Conditioned < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  # @return [Conditioned] a new instance of Conditioned
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#126
  def initialize(condition:, **options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#132
  def call(wrap_ctx, original_args); end
end

# Set variable on ctx if {condition} is true.
# Otherwise, set default_filter variable on ctx.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#142
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::Default < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  # @return [Default] a new instance of Default
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#143
  def initialize(default_filter:, condition:, **options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#150
  def call(wrap_ctx, original_args); end
end

# Always deletes from {:aggregate}.
#
# @private
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#186
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::Delete < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#187
  def call(wrap_ctx, original_args); end
end

# TODO: we don't have Out(:variable), yet!
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#161
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::Output < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  class << self
    # Call a filter with a Circuit-Step interface.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#163
    def call_filter(filter, wrap_ctx, original_args); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#169
    def call_filter_with_ctx(filter, ctx, wrap_ctx, _arg3); end
  end
end

# Do everything SetVariable does but read from {aggregate}, not from {ctx}.
# TODO: it would be cool to have this also for AddVariables.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#176
class Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable::ReadFromAggregate < ::Trailblazer::Activity::DSL::Linear::VariableMapping::SetVariable
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#177
    def call_filter(filter, wrap_ctx, original_args); end
  end
end

# Filter
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#69
class Trailblazer::Activity::DSL::Linear::VariableMapping::VariableFromCtx
  # @return [VariableFromCtx] a new instance of VariableFromCtx
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#70
  def initialize(variable_name:); end

  # Grab @variable_name from {ctx}.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#75
  def call(_arg0, **_arg1); end
end

# Filter
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#81
class Trailblazer::Activity::DSL::Linear::VariableMapping::VariablePresent < ::Trailblazer::Activity::DSL::Linear::VariableMapping::VariableFromCtx
  # Grab @variable_name from {ctx} if it's there.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/dsl/linear/feature/variable_mapping/runtime.rb#83
  def call(_arg0, **_arg1); end
end

# Implementation of the "FastTrack" layout that is also used for `Operation`.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#4
class Trailblazer::Activity::FastTrack < ::Trailblazer::Activity::DSL::Linear::Strategy
  class << self
    private

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#168
    def fail(*args, &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#171
    def left(*args, &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#173
    def pass(*args, &block); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#9
module Trailblazer::Activity::FastTrack::DSL
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#16
  def Normalizer(prepend_to_default_outputs: T.unsafe(nil), base_normalizer_builder: T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#95
  def add_fail_fast_output(ctx, outputs:, fail_fast: T.unsafe(nil), **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#110
  def add_fast_track_connectors(ctx, fast_track: T.unsafe(nil), **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#101
  def add_fast_track_outputs(ctx, outputs:, fast_track: T.unsafe(nil), **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#89
  def add_pass_fast_output(ctx, outputs:, pass_fast: T.unsafe(nil), **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#127
  def fail_fast_option(ctx, outputs:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#135
  def fail_fast_option_for_fail(ctx, **_arg1); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#140
  def merge_connections_for!(ctx, option_name, semantic, magnetic_to = T.unsafe(nil), non_symbol_options:, **_arg5); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#157
  def options_for_sequence_build(fail_fast_end: T.unsafe(nil), pass_fast_end: T.unsafe(nil), **options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#115
  def pass_fast_option(ctx, outputs:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#122
  def pass_fast_option_for_pass(ctx, **_arg1); end

  # *If* {fast_track: true} (or :pass_fast or :fail_fast), record it using Normalizer::Inherit mechanics.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#76
  def record_options(ctx, non_symbol_options:, **_arg2); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#16
    def Normalizer(prepend_to_default_outputs: T.unsafe(nil), base_normalizer_builder: T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#95
    def add_fail_fast_output(ctx, outputs:, fail_fast: T.unsafe(nil), **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#110
    def add_fast_track_connectors(ctx, fast_track: T.unsafe(nil), **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#101
    def add_fast_track_outputs(ctx, outputs:, fast_track: T.unsafe(nil), **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#89
    def add_pass_fast_output(ctx, outputs:, pass_fast: T.unsafe(nil), **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#127
    def fail_fast_option(ctx, outputs:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#135
    def fail_fast_option_for_fail(ctx, **_arg1); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#140
    def merge_connections_for!(ctx, option_name, semantic, magnetic_to = T.unsafe(nil), non_symbol_options:, **_arg5); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#157
    def options_for_sequence_build(fail_fast_end: T.unsafe(nil), pass_fast_end: T.unsafe(nil), **options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#115
    def pass_fast_option(ctx, outputs:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#122
    def pass_fast_option_for_pass(ctx, **_arg1); end

    # *If* {fast_track: true} (or :pass_fast or :fail_fast), record it using Normalizer::Inherit mechanics.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#76
    def record_options(ctx, non_symbol_options:, **_arg2); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#108
Trailblazer::Activity::FastTrack::DSL::FAIL_FAST_OUTPUT = T.let(T.unsafe(nil), Hash)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#40
module Trailblazer::Activity::FastTrack::DSL::Fail
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#43
  def Normalizer; end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#43
    def Normalizer; end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#10
Trailblazer::Activity::FastTrack::DSL::Linear = Trailblazer::Activity::DSL::Linear

# Normalizer pipelines taking care of processing your DSL options.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#150
Trailblazer::Activity::FastTrack::DSL::Normalizers = T.let(T.unsafe(nil), Trailblazer::Activity::DSL::Linear::Normalizer::Normalizers)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#107
Trailblazer::Activity::FastTrack::DSL::PASS_FAST_OUTPUT = T.let(T.unsafe(nil), Hash)

# The connector logic needs to be run before Railway's connector logic:
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#12
Trailblazer::Activity::FastTrack::DSL::PREPEND_TO = T.let(T.unsafe(nil), String)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#56
module Trailblazer::Activity::FastTrack::DSL::Pass
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#59
  def Normalizer; end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#59
    def Normalizer; end
  end
end

# inherit: true
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#73
Trailblazer::Activity::FastTrack::DSL::RECORD_OPTIONS = T.let(T.unsafe(nil), Array)

# Signals
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#6
class Trailblazer::Activity::FastTrack::FailFast < ::Trailblazer::Activity::Signal; end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/fast_track.rb#7
class Trailblazer::Activity::FastTrack::PassFast < ::Trailblazer::Activity::Signal; end

# {Strategy} that helps building simple linear activities.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#4
class Trailblazer::Activity::Path < ::Trailblazer::Activity::DSL::Linear::Strategy; end

# Functions that help creating a path-specific sequence.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#6
module Trailblazer::Activity::Path::DSL
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#15
  def Normalizer(prepend_to_default_outputs: T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#41
  def add_success_connector(ctx, track_name:, non_symbol_options:, **_arg3); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#37
  def add_success_output(ctx, **_arg1); end

  # TODO: merge with Railway.merge_magnetic_to
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#47
  def normalize_magnetic_to(ctx, track_name:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#67
  def options_for_sequence_build(track_name: T.unsafe(nil), end_task: T.unsafe(nil), end_id: T.unsafe(nil), **_arg3); end

  # @private
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#63
  def start_sequence(track_name:); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#15
    def Normalizer(prepend_to_default_outputs: T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#41
    def add_success_connector(ctx, track_name:, non_symbol_options:, **_arg3); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#37
    def add_success_output(ctx, **_arg1); end

    # TODO: merge with Railway.merge_magnetic_to
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#47
    def normalize_magnetic_to(ctx, track_name:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#67
    def options_for_sequence_build(track_name: T.unsafe(nil), end_task: T.unsafe(nil), end_id: T.unsafe(nil), **_arg3); end

    # @private
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#63
    def start_sequence(track_name:); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#7
Trailblazer::Activity::Path::DSL::Linear = Trailblazer::Activity::DSL::Linear

# This is slow and should be done only once at compile-time,
# These are the normalizers for an {Activity}, to be injected into a State.
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#53
Trailblazer::Activity::Path::DSL::Normalizers = T.let(T.unsafe(nil), Trailblazer::Activity::DSL::Linear::Normalizer::Normalizers)

# Always prepend all "add connectors" steps of all normalizers to normalize_output_tuples.
# This assures that the order is
#   [<default tuples>, <inherited tuples>, <user tuples>]
#
# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#11
Trailblazer::Activity::Path::DSL::PREPEND_TO = T.let(T.unsafe(nil), String)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/path.rb#35
Trailblazer::Activity::Path::DSL::SUCCESS_OUTPUT = T.let(T.unsafe(nil), Hash)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#3
class Trailblazer::Activity::Railway < ::Trailblazer::Activity::DSL::Linear::Strategy
  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#114
    def fail(*args, &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#117
    def left(*args, &block); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#119
    def pass(*args, &block); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#4
module Trailblazer::Activity::Railway::DSL
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#9
  def Normalizer(prepend_to_default_outputs: T.unsafe(nil)); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#90
  def add_failure_connector(ctx, outputs:, non_symbol_options:, failure_connector: T.unsafe(nil), **_arg4); end

  # Add {:failure} output to {:outputs}.
  # This is only called for non-Subprocess steps.
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#86
  def add_failure_output(ctx, outputs:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#104
  def options_for_sequence_build(failure_end: T.unsafe(nil), **options); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#9
    def Normalizer(prepend_to_default_outputs: T.unsafe(nil)); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#90
    def add_failure_connector(ctx, outputs:, non_symbol_options:, failure_connector: T.unsafe(nil), **_arg4); end

    # Add {:failure} output to {:outputs}.
    # This is only called for non-Subprocess steps.
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#86
    def add_failure_output(ctx, outputs:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#104
    def options_for_sequence_build(failure_end: T.unsafe(nil), **options); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#80
Trailblazer::Activity::Railway::DSL::FAILURE_CONNECTOR = T.let(T.unsafe(nil), Hash)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#79
Trailblazer::Activity::Railway::DSL::FAILURE_OUTPUT = T.let(T.unsafe(nil), Hash)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#82
Trailblazer::Activity::Railway::DSL::FAIL_CONNECTOR = T.let(T.unsafe(nil), Hash)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#28
module Trailblazer::Activity::Railway::DSL::Fail
  private

  # Change some parts of the step-{Normalizer} pipeline.
  # We're bound to using a very primitive Pipeline API, remember, we don't have
  # a DSL at this point!
  #
  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#34
  def Normalizer(**options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#56
  def connect_success_to_failure(ctx, non_symbol_options:, **_arg2); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#50
  def merge_magnetic_to(ctx, **_arg1); end

  class << self
    # Change some parts of the step-{Normalizer} pipeline.
    # We're bound to using a very primitive Pipeline API, remember, we don't have
    # a DSL at this point!
    #
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#34
    def Normalizer(**options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#56
    def connect_success_to_failure(ctx, non_symbol_options:, **_arg2); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#50
    def merge_magnetic_to(ctx, **_arg1); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#54
Trailblazer::Activity::Railway::DSL::Fail::SUCCESS_TO_FAILURE_CONNECTOR = T.let(T.unsafe(nil), Hash)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#5
Trailblazer::Activity::Railway::DSL::Linear = Trailblazer::Activity::DSL::Linear

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#97
Trailblazer::Activity::Railway::DSL::Normalizers = T.let(T.unsafe(nil), Trailblazer::Activity::DSL::Linear::Normalizer::Normalizers)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#81
Trailblazer::Activity::Railway::DSL::PASS_CONNECTOR = T.let(T.unsafe(nil), Hash)

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#61
module Trailblazer::Activity::Railway::DSL::Pass
  private

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#64
  def Normalizer(**options); end

  # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#74
  def connect_failure_to_success(ctx, **options); end

  class << self
    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#64
    def Normalizer(**options); end

    # source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#74
    def connect_failure_to_success(ctx, **options); end
  end
end

# source://trailblazer-activity-dsl-linear//lib/trailblazer/activity/railway.rb#72
Trailblazer::Activity::Railway::DSL::Pass::FAILURE_TO_SUCCESS_CONNECTOR = T.let(T.unsafe(nil), Hash)

class Trailblazer::Operation < ::Trailblazer::Activity::FastTrack; end
