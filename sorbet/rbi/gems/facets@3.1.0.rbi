# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `facets` gem.
# Please instead update this file by running `bin/tapioca gem facets`.


# source://facets//lib/core/facets/na.rb#11
::NA = T.let(T.unsafe(nil), ArgumentError)

# class NilClass
#  # Provide platform dependent null path.
#  #
#  # @standard
#  #   require 'facets/pathname'
#  #
#  # @author Daniel Burger
#  def to_path
#    Pathname.null
#  end
# end
#
# source://facets//lib/core/facets/array/before.rb#1
class Array
  include ::Enumerable
  include ::Indexable

  # Returns the value after the given value. The value before the last
  # is the first. Returns nil if the given value is not in the array.
  #
  # Examples
  #
  #   sequence = ['a', 'b', 'c']
  #   sequence.after('a')           #=> 'b'
  #   sequence.after('b')           #=> 'c'
  #   sequence.after('c')           #=> 'a'
  #   sequence.after('d')           #=> nil
  #
  # CREDIT: Tyler Rick
  #
  # source://facets//lib/core/facets/array/before.rb#35
  def after(value); end

  # Calculate the average of an array of numbers
  #
  # Examples
  #
  #   [].average #=> nil
  #   [1, 2, 3].average #=> 2
  #   [3, 12, 57, 85, 15, 89, 33, 7, 22, 54].average #=> 37.7
  #   [1,[2,nil,[3]],nil,4].collapse  #=> [1,2,3,4]
  #
  # source://facets//lib/core/facets/array/average.rb#12
  def average; end

  # Returns the value previous to the given value. The value previous
  # to the first is the last. Returns nil if the given value is not
  # in the array.
  #
  # Examples
  #
  #   sequence = ['a', 'b', 'c']
  #   sequence.before('a')           #=> 'c'
  #   sequence.before('b')           #=> 'a'
  #   sequence.before('c')           #=> 'b'
  #   sequence.before('d')           #=> nil
  #
  # CREDIT: Tyler Rick
  #
  # source://facets//lib/core/facets/array/before.rb#17
  def before(value); end

  # source://facets//lib/core/facets/kernel/blank.rb#62
  def blank?; end

  # Simplify an array by flattening it then compacting it.
  #
  # Examples
  #
  #   [1,[2,nil,[3]],nil,4].collapse  #=> [1,2,3,4]
  #
  # source://facets//lib/core/facets/array/collapse.rb#9
  def collapse; end

  # source://facets//lib/core/facets/array/collapse.rb#13
  def collapse!; end

  # Get a list of all items that have something in common in terms of the
  # supplied block. If no block is given objects are considered to be in
  # common if they return the same value for Object#hash and if obj1 == obj2.
  #
  # This can be useful, for instance, in determining all persons that share
  # their last name with another person.
  #
  #     persons.commonality { |person| person.last_name }
  #
  # The method is similar to #group_by which is a standard Ruby method as of 1.9.
  # To get effectively the same results with #group_by use `select{ |k,v| v.size > 1 }`.
  #
  #     [1, 2, 2, 3, 4, 4].group_by{ |e| e }.select{ |k,v| v.size > 1 }
  #     #=> { 2 => [2, 2], 4 => [4, 4] }
  #
  # Examples
  #
  #   [1, 2, 2, 3, 4, 4].commonality  #=> { 2 => [2, 2], 4 => [4, 4] }
  #
  #   ["foo", "bar", "baz"].commonality { |str| str[0] }
  #   #=> { 'b' => ["bar", "baz"] }
  #
  # Returns [Hash] mapping common attribute to those elements.
  #
  # CREDIT: Florian Gross
  # Deprecated: Alias for #commonality.
  #
  # source://facets//lib/core/facets/array/commonality.rb#46
  def collisions(&block); end

  # Get a list of all items that have something in common in terms of the
  # supplied block. If no block is given objects are considered to be in
  # common if they return the same value for Object#hash and if obj1 == obj2.
  #
  # This can be useful, for instance, in determining all persons that share
  # their last name with another person.
  #
  #     persons.commonality { |person| person.last_name }
  #
  # The method is similar to #group_by which is a standard Ruby method as of 1.9.
  # To get effectively the same results with #group_by use `select{ |k,v| v.size > 1 }`.
  #
  #     [1, 2, 2, 3, 4, 4].group_by{ |e| e }.select{ |k,v| v.size > 1 }
  #     #=> { 2 => [2, 2], 4 => [4, 4] }
  #
  # Examples
  #
  #   [1, 2, 2, 3, 4, 4].commonality  #=> { 2 => [2, 2], 4 => [4, 4] }
  #
  #   ["foo", "bar", "baz"].commonality { |str| str[0] }
  #   #=> { 'b' => ["bar", "baz"] }
  #
  # Returns [Hash] mapping common attribute to those elements.
  #
  # CREDIT: Florian Gross
  #
  # source://facets//lib/core/facets/array/commonality.rb#29
  def commonality(&block); end

  # This is more advanced form of #join. It allows for fine control
  # of separators.
  #
  # NOTE: The old version used to default its separator to ", " and
  # default the terminating separator to " and ". This is no longer
  # the case. You must specifically provide these parameters.
  #
  # If no paramters are given, it acts like #join but will a space
  # separator.
  #
  #   [1,2,3].conjoin
  #   #=> "1 2 3"
  #
  # Use comma+space and 'and' on tail.
  #
  #   [1,2,3].conjoin(', ', ' and ')
  #   #=> "1, 2 and 3"
  #
  # Use comma+space and 'or' on tail using :last option.
  #
  #   [1,2,3].conjoin(', ', :last => ' or ')
  #   #=> "1, 2 or 3"
  #
  # Use semicolon+space and ampersand on tail using index.
  #
  #   [1,2,3].conjoin('; ', -1 => ' & ')
  #   #=> "1; 2 & 3"
  #
  # Can take a block to determine separator.
  #
  #   [1,2,3,4].conjoin{ |i, a, b| i % 2 == 0 ? '.' : '-' }
  #   #=> "1.2-3.4"
  #
  # This makes very esoteric transformation possible.
  #
  #   [1,1,2,2].conjoin{ |i, a, b| a == b ? '=' : ' != ' }
  #   #=> "1=1 != 2=2"
  #
  #   [1,2,3,4].conjoin{ |i, x, y| "<#{i} #{x} #{y}>" }
  #   #=> "1<0 1 2>2<1 2 3>3<2 3 4>4"
  #
  # There are also spacing options. Providing the :space option
  # pads the separators.
  #
  #   [1,2,3].conjoin(',', '&', :space=>2)
  #   #=> "1  ,  2  &  3"
  #
  # And the :spacer option can set an alternate spacing string.
  #
  #   [1,2,3].conjoin('|', '>', :space=>2, :spacer=>'-')
  #   #=> "1--|--2-->--3"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/array/conjoin.rb#57
  def conjoin(*args, &block); end

  # Alias for #include?.
  #
  # source://facets//lib/core/facets/array/contains.rb#4
  def contains?(_arg0); end

  # Inverse of #delete_if.
  #
  #   [1,2,3].delete_unless{ |x| x < 2 }
  #   #=> [1]
  #
  # CREDIT: Daniel Schierbeck
  #
  # source://facets//lib/core/facets/array/delete_unless.rb#10
  def delete_unless(&block); end

  # Delete multiple values from array.
  #
  #   a = [1,2,3,4]
  #   a.delete_values(1,2)   #=> [1,2]
  #   a                      #=> [3,4]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/array/delete_values.rb#11
  def delete_values(*values); end

  # Delete multiple values from array given
  # indexes or index range.
  #
  #   a = [1,2,3,4]
  #   a.delete_values_at(1,2)   #=> [2,3]
  #   a                         #=> [1,4]
  #   a = [1,2,3,4]
  #   a.delete_values_at(0..2)  #=> [1,2,3]
  #   a                         #=> [4]
  #
  # NOTE: It would be nice to see #delete_at incorporate this
  # funcitonaility.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/array/delete_values.rb#32
  def delete_values_at(*selectors); end

  # Divide on matching pattern.
  #
  #   ['a1','b1','a2','b2'].divide(/^a/)
  #   #=> [['a1','b1'],['a2','b2']]
  #
  #   ['a1','b1','a2','b2'].divide(/^b/)
  #   #=> [['a1',['b1','a2'],[]'b2']]
  #
  #   ['a1','b1','a2','b2'].divide(/^c/)
  #   #=> [['a1','b1','a2','b2']]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/array/divide.rb#16
  def divide(pattern); end

  # Return list of duplicate elements.
  #
  # min - The minimum number of duplication necessary for inclusion. [Integer]
  #
  # Examples:
  #
  #   [1,1,2,3].duplicates #=> [1]
  #
  #   [1,1,2,3,2,4,5,4,2].duplicates(3) #=> [2]
  #
  # CREDIT: Rebort Dober (current implementation)
  # CREDIT: Thibaut Barrère
  #
  # source://facets//lib/core/facets/array/duplicates.rb#16
  def duplicates(min = T.unsafe(nil)); end

  # Iterate over index and value. The intention of this
  # method is to provide polymorphism with Hash.
  #
  # source://facets//lib/core/facets/array/each_pair.rb#6
  def each_pair; end

  # Alias for #each. The intention of this method
  # is to provide polymorphism with Hash.
  #
  # source://facets//lib/core/facets/array/each_value.rb#4
  def each_value; end

  # Shannon's entropy for an array - returns the average
  # bits per symbol required to encode the array.
  # Lower values mean less "entropy" - i.e. less unique
  # information in the array.
  #
  #   e = %w{ a b c d e e e }.entropy
  #
  #   ("%.3f" % e)  #=> "2.128"
  #
  # CREDIT: Derek
  #
  # source://facets//lib/core/facets/array/entropy.rb#16
  def entropy; end

  # Extracts options from a set of arguments. Removes and returns the last
  # element in the array if it's a hash, otherwise returns a blank hash.
  #
  #   def options(*args)
  #     args.extract_options!
  #   end
  #
  #   options(1, 2)           # => {}
  #   options(1, 2, :a => :b) # => {:a=>:b}
  #
  # source://facets//lib/core/facets/array/extract_options.rb#23
  def extract_options!; end

  # Alias for shift, which removes and returns
  # the first element in an array.
  #
  #   a = ["a","y","z"]
  #   a.first!      #=> "a"
  #   a             #=> ["y","z"]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/array/indexable.rb#17
  def first!(*_arg0); end

  # Returns the maximum possible Shannon entropy of the array
  # with given size assuming that it is an "order-0" source
  # (each element is selected independently of the next).
  #
  # CREDIT: Derek
  #
  # source://facets//lib/core/facets/array/entropy.rb#32
  def ideal_entropy; end

  # Alias for pop, which removes and returns
  # the last element in an array.
  #
  #   a = [1,2,3]
  #   a.last!       #=> 3
  #   a             #=> [1,2]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/array/indexable.rb#28
  def last!(*_arg0); end

  # Alias for <tt>|</tt>.
  #
  #   [1,2].merge([2,3])  #=> [1,2,3]
  #
  # source://facets//lib/core/facets/array/merge.rb#19
  def merge(_arg0); end

  # In place #merge.
  #
  #   a = [1,2]
  #   a.merge! [2,3]
  #   a #=> [1,2,3]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/array/merge.rb#11
  def merge!(other); end

  # In Statistics. mode is the value that occurs most frequently
  # in a given set of data. This method returns an array in case
  # there is a tie.
  #
  #   [:a, :b, :c, :b, :d].mode  #=> [:b]
  #   [:a, :b, :c, :b, :a].mode  #=> [:a, :b]
  #
  # Returns an Array of most common elements.
  #
  # @author Robert Klemme
  #
  # source://facets//lib/core/facets/array/mode.rb#14
  def mode; end

  # Returns a list of non-unique elements.
  #
  # Examples
  #
  #   [1,1,2,2,3,4,5].nonuniq  #=> [1,2]
  #
  # CREDIT: Martin DeMello
  #
  # source://facets//lib/core/facets/array/nonuniq.rb#11
  def nonuniq; end

  # Same as `#nonuniq` but acts in place.
  #
  # source://facets//lib/core/facets/array/nonuniq.rb#23
  def nonuniq!; end

  # Not empty?
  #
  #   [].not_empty?     #=> false
  #   [1,2].not_empty?  #=> true
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/array/not_empty.rb#8
  def not_empty?; end

  # source://facets//lib/core/facets/object/object_state.rb#47
  def object_state(data = T.unsafe(nil)); end

  # Create a hash of each uniq element of the array
  # and how many time each appears.
  #
  # Examples
  #
  #   [:a,:a,:b,:c,:c,:c].occurrence
  #   #=> { :a => 2, :b => 1, :c => 3 }
  #
  #   [2,2,3,4,4,4].occurrence{|i| i % 2}
  #   #=> { 0 => 5, 1 => 1 }
  #
  # source://facets//lib/core/facets/array/occurrence.rb#14
  def occurrence; end

  # Returns the _only_ element in the array.  Raises an IndexError if
  # the array's size is not 1.
  #
  #   [5].only      # => 5
  #
  #   expect IndexError do
  #     [1,2,3].only
  #   end
  #
  #   expect IndexError do
  #     [].only
  #   end
  #
  # CREDIT: Gavin Sinclair, Noah Gibbs
  #
  # source://facets//lib/core/facets/array/only.rb#18
  def only; end

  # Does this Array have only one element?
  #
  # TODO: While clearly this goes along with the regular #only method,
  # the name doesn't seem quite right. Perhaps rename to #lonely.
  #
  # CREDIT: Lavir the Whiolet
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/array/only.rb#32
  def only?; end

  # Pad an array with a given <tt>value</tt> up to a given <tt>length</tt>.
  #
  #   [0,1,2].pad(6,"a")  #=> [0,1,2,"a","a","a"]
  #
  # If <tt>length</tt> is a negative number padding will be added
  # to the beginning of the array.
  #
  #   [0,1,2].pad(-6,"a")  #=> ["a","a","a",0,1,2]
  #
  # CREDIT: Richard Laugesen
  #
  # source://facets//lib/core/facets/array/pad.rb#14
  def pad(len, val = T.unsafe(nil)); end

  # Like #pad but changes the array in place.
  #
  #    a = [0,1,2]
  #    a.pad!(6,"x")
  #    a  #=> [0,1,2,"x","x","x"]
  #
  # CREDIT: Richard Laugesen
  #
  # source://facets//lib/core/facets/array/pad.rb#31
  def pad!(len, val = T.unsafe(nil)); end

  # Peek at the top of the stack (the end of the array).
  #
  #   a = [1, 2, 3]
  #   a.peek          #=> 3
  #   a               #=> [1, 2, 3]
  #
  # Or provide an index to inspect the array from back to front.
  #
  # source://facets//lib/core/facets/array/pull.rb#14
  def peek(i = T.unsafe(nil)); end

  # Put an object on the bottom of the stack (front of the array).
  #
  #   a = [2, 3]
  #   a.poke(1)
  #   a               #=> [1, 2, 3]
  #
  # Or supply an index and #poke works like #insert.
  #
  # source://facets//lib/core/facets/array/pull.rb#26
  def poke(x, i = T.unsafe(nil)); end

  # Generates a hash mapping each unique element in the array to the
  # relative frequency, i.e. the probability, of it appearance.
  #
  #   [:a, :b, :c, :c].probability  #=> {:a=> 0.25, :b=>0.25, :c=>0.5}
  #
  # CREDIT: Brian Schröder
  #
  # source://facets//lib/core/facets/array/probability.rb#10
  def probability; end

  # Alias for shift which removes an object off first slot of an array.
  # This is the opposite of pop.
  #
  # source://facets//lib/core/facets/array/pull.rb#5
  def pull(*_arg0); end

  # Apply a block to array, and recursively apply that block
  # to each sub-array or +types+.
  #
  #   arr = ["a", ["b", "c", nil], nil]
  #   arr.recurse{ |a| a.compact! }
  #   #=> ["a", ["b", "c"]]
  #
  # @yield [a]
  #
  # source://facets//lib/core/facets/array/recurse.rb#10
  def recurse(*types, &block); end

  # In place form of #recurse.
  #
  # source://facets//lib/core/facets/array/recurse.rb#25
  def recurse!(&block); end

  # Apply a method to array, and recursively apply that method
  # to each sub-array or given +types+.
  #
  # By default the sub-types are passed through unaffected. Passing
  # a block to #recursively can be used to change this.
  #
  # types - List of class types to recurse. [Array<Class>]
  # block - Optional filter procedure to apply on each recursion.
  #
  # Examples
  #
  #   arr = ["a", ["b", "c"]]
  #   arr.recursively.map{ |v| v.to_sym }
  #   #=> [:a, [:b, :c]]
  #
  #   arr = ["a", ["b", "c"]]
  #   arr.recursively{ |a| a.reverse }.map{ |v| v.to_sym }
  #   #=> [:a, [:c, :b]]
  #
  # Returns [Recursor].
  #
  # source://facets//lib/core/facets/array/recursively.rb#27
  def recursively(*types, &block); end

  # Non-destructive form of `Array#delete_values`. Unlike `delete_values`
  # this method returns a new array.
  #
  # values - List of array elements to reject.
  #
  # Examples
  #
  #     [1,2,3,4,5].reject_values(2,4)  # => [1,3,5]
  #
  # Returns [Array]
  #
  # CREDIT: Sean Mackesey
  #
  # source://facets//lib/core/facets/array/reject_values.rb#16
  def reject_values(*values); end

  # Splice acts as a combination of #slice! and #store.
  # If two arguments are given it calls #store.
  # If a single argument is given it calls slice!.
  #
  # Examples
  #
  #   a = [1,2,3]
  #   a.splice(1)    #=> 2
  #   a              #=> [1,3]
  #
  #   a = [1,2,3]
  #   a.splice(1,4)  #=> 4
  #   a              #=> [1,4,3]
  #
  # Returns [Array].
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/array/splice.rb#23
  def splice(*args); end

  # Split on matching pattern. Unlike #divide this does not include matching
  # elements.
  #
  # Examples
  #
  #   ['a1','a2','b1','a3','b2','a4'].split(/^b/)
  #   #=> [['a1','a2'],['a3'],['a4']]
  #
  # Returns list of split-up arrays. [Array<Array>]
  #
  # source://facets//lib/core/facets/array/split.rb#13
  def split(pattern); end

  # Destructive version of Enumerable#squeeze.
  #
  #   a = [1,2,2,3,3,2,1]
  #   a.squeeze!
  #   a #=> [1,2,3,2,1]
  #
  #   a = [1,2,2,3,3,2,1]
  #   a.squeeze!(*[3])
  #   a #=> [1,2,2,3,2,1]
  #
  # Returns the receiver. [Array]
  #
  # CREDIT: T. Yamada
  #
  # source://facets//lib/core/facets/array/squeeze.rb#19
  def squeeze!(*limited_to); end

  # Store a value at a given index. Store is an alias for #[]=.
  #
  # Example:
  #
  #   a = []
  #   a.store(1, "A")
  #   a[1] #=> "A"
  #
  # Returns the stored object.
  #
  # source://facets//lib/core/facets/array/store.rb#13
  def store(*_arg0); end

  # Fetch values from a start index thru an end index.
  #
  #   [1,2,3,4,5].thru(2)  #=> [1,2,3]
  #   [1,2,3,4,5].thru(4)  #=> [1,2,3,4,5]
  #
  #   [1,2,3,4,5].thru(0,2)  #=> [1,2,3]
  #   [1,2,3,4,5].thru(2,4)  #=> [3,4,5]
  #
  # source://facets//lib/core/facets/array/from.rb#21
  def thru(from, to = T.unsafe(nil)); end

  # Boolean conversion for not empty?
  #
  # source://facets//lib/core/facets/boolean.rb#110
  def to_b; end

  # Construct a new array created by traversing the array and its
  # sub-arrays, executing the given block on the elements.
  #
  # Examples
  #
  #   h = ["A", "B", ["X", "Y"]]
  #   g = h.traverse{ |e| e.downcase }
  #   g  #=> ["a", "b", ["x", "y"]]
  #
  # This is the same as <code>recursive.map</code> and will
  # likely be deprecated in the future because of it.
  #
  # Returns new array. [Array]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/array/traverse.rb#19
  def traverse(&block); end

  # Like #recursive_map, but will change the array in place.
  #
  # Examples:
  #
  #   h = ["A", "B", ["X", "Y"]]
  #   h.traverse!{ |e| e.downcase }
  #   h  #=> ["a", "b", ["x", "y"]]
  #
  # Returns self. [Array]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/array/traverse.rb#45
  def traverse!(&block); end

  # Like #uniq, but determines uniqueness based on a given block.
  # As can be seen in the following examples, order is significant.
  #
  # Examples
  #
  #   a = (-5..5).to_a
  #   a.uniq_by!{ |i| i*i }
  #   a #=> [-5, -4, -3, -2, -1, 0]
  #
  #   a = (-5..5).to_a.reverse
  #   a.uniq_by!{ |i| i*i }
  #   a #=> [5, 4, 3, 2, 1, 0]
  #
  # Returns [Array] of unique elements.
  #
  # source://facets//lib/core/facets/array/uniq_by.rb#18
  def uniq_by!; end

  # Enumerates permutation of Array.
  # Unlike Array#permutation, there are no duplicates in generated permutations.
  # Instead, elements must be comparable.
  #
  #   [1,1,2,2,3].unique_permutation(2).to_a
  #   #=> [[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2]]
  #   # Note: [1,1,2,2,3].permutation(2).to_a
  #   #=> [[1, 1], [1, 2], [1, 2], [1, 3], [1, 1], [1, 2], [1, 2], [1, 3], [2, 1], [2, 1], [2, 2], [2, 3], [2, 1], [2, 1], [2, 2], [2, 3], [3, 1], [3, 1], [3, 2], [3, 2]]
  #
  # CREDIT: T. Yamada
  #
  # @yield [a[0,n]]
  #
  # source://facets//lib/core/facets/array/unique_permutation.rb#13
  def unique_permutation(n = T.unsafe(nil)); end
end

# Support class for Kernel#as.
#
# TODO: Deprecate this and use Functor (HigherOrderMessage) instead ?
#
# source://facets//lib/core/facets/kernel/as.rb#85
class As
  # @return [As] a new instance of As
  #
  # source://facets//lib/core/facets/kernel/as.rb#105
  def initialize(subject, ancestor); end

  private

  # source://facets//lib/core/facets/kernel/as.rb#103
  def Bit(n); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def abort(*_args, **_kwargs, &_block); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def acts_like?(duck); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def as(ancestor, &blk); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def as_json(options = T.unsafe(nil)); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def blank?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def bool?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def bool_chain(&block); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def call_stack(level = T.unsafe(nil)); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def callstack(level = T.unsafe(nil)); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def cascade(&block); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def class; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def class_eval(*args, &block); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def class_exists?(class_name); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def clone(freeze: T.unsafe(nil)); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def deep_dup; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def define_singleton_method(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def display(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def dup; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def duplicable?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def enum_for(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def eql?(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def equal?(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def exit(*_args, **_kwargs, &_block); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def extend(*mod, &blk); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def false?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def false_?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def freeze; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def friendly_id?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def frozen?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def gem(dep, *reqs); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def hash; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def html_safe?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def in?(another_object); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def inspect; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def instance_eval(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def instance_exec(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def instance_of?(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def instance_values; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def instance_variable_defined?(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def instance_variable_get(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def instance_variable_names; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def instance_variable_set(_arg0, _arg1); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def instance_variables; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def is_a?(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def is_an?(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def is_not_a?(compare); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def is_not_an?(compare); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def is_one_of?(*klasses); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def itself; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def kind_of?(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def method(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def method_chain(ret_val = T.unsafe(nil), &block); end

  # source://facets//lib/core/facets/kernel/as.rb#112
  def method_missing(sym, *args, &blk); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def methods(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def nil?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def nil_chain(ret_val = T.unsafe(nil), &block); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def not_nil?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def numeric?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def object_id; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def presence; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def presence_in(another_object); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def present?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def pretty_inspect; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def pretty_print(q); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def pretty_print_cycle(q); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def pretty_print_inspect; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def pretty_print_instance_variables; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def private_methods(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def protected_methods(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def public_method(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def public_methods(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def public_send(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def remove_instance_variable(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def require_dependency(filename); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def respond_to?(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def same_as(compare); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def same_as?(compare); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def send(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def send_as(ancestor, sym, *args, &blk); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def silently(*streams); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def singleton_class; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def singleton_method(_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def singleton_methods(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def tap; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def then; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def to_b; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def to_bool; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def to_enum(*_arg0); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def to_json(options = T.unsafe(nil)); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def to_param; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def to_query(key); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def to_s; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def to_yaml(options = T.unsafe(nil)); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def true?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def true_?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def try(*args, **_arg1, &block); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def try!(*args, **_arg1, &block); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def unfriendly_id?; end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def with(**attributes); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def with_options(options, &block); end

  # source://facets//lib/core/facets/kernel/as.rb#103
  def yield_self; end

  class << self
    # source://facets//lib/core/facets/kernel/as.rb#90
    def new(subject, ancestor); end

    private

    # source://facets//lib/core/facets/kernel/as.rb#88
    def _new(*_arg0); end

    # source://facets//lib/core/facets/kernel/as.rb#94
    def cache; end
  end
end

# source://facets//lib/core/facets/kernel/callstack.rb#47
class Binding
  # Returns the value of some variable.
  #
  #   a = 2
  #   binding["a"]  #=> 2
  #
  # source://facets//lib/core/facets/binding/op_get.rb#8
  def [](x); end

  # Set the value of a local variable.
  #
  #   binding["a"] = 4
  #   a  #=> 4
  #
  # @deprecated No longer wortks in Ruby 1.9+.
  # @see Binding#with for an alternative.
  #
  # source://facets//lib/core/facets/binding/op_get.rb#20
  def []=(l, v); end

  # Return the directory of the file in which the binding was created.
  #
  # source://facets//lib/core/facets/binding/caller.rb#25
  def __DIR__; end

  # Returns file name in which the binding was created.
  #
  # source://facets//lib/core/facets/binding/caller.rb#19
  def __FILE__; end

  # Return the line number on which the binding was created.
  #
  # source://facets//lib/core/facets/binding/caller.rb#13
  def __LINE__; end

  # Retreive the current running method.
  #
  # source://facets//lib/core/facets/binding/caller.rb#37
  def __callee__; end

  # Retreive the current running method.
  #
  # source://facets//lib/core/facets/binding/caller.rb#31
  def __method__; end

  # Returns the call stack, in array format.
  #
  # source://facets//lib/core/facets/kernel/callstack.rb#54
  def call_stack(level = T.unsafe(nil)); end

  # Returns the call stack, same format as Kernel#caller()
  #
  # source://facets//lib/core/facets/binding/caller.rb#7
  def caller(skip = T.unsafe(nil)); end

  # Returns the call stack, in array format.
  #
  # source://facets//lib/core/facets/kernel/callstack.rb#50
  def callstack(level = T.unsafe(nil)); end

  # Returns the nature of something within the context of the binding.
  # Returns nil if that thing is not defined.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/binding/defined.rb#5
  def defined?(x); end

  # Returns self of the binding's context.
  #
  # source://facets//lib/core/facets/binding/self.rb#8
  def self; end

  # Returns a new binding with local varaibles set.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/binding/with.rb#7
  def with(_local_variables, &_yields); end
end

# source://facets//lib/core/facets/class/subclasses.rb#1
class Class < ::Module
  # List all descedents of this class.
  #
  #   class A ; end
  #   class B < A; end
  #   class C < A; end
  #   A.descendants  #=> [B,C]
  #
  # You may also limit the generational distance the subclass may be from
  # the parent class.
  #
  #   class X ; end
  #   class Y < X; end
  #   class Z < Y; end
  #   X.descendants    #=> [Y,Z]
  #   X.descendants(1) #=> [Y]
  #
  # NOTE: This is a intensive operation. Do not expect it to be very fast.
  #
  # @author Roger Pack
  #
  # source://facets//lib/core/facets/class/descendants.rb#24
  def descendants; end

  # Translate a class name to a suitable method name.
  #
  #   module ::Example
  #     class MethodizeExample
  #     end
  #   end
  #
  #   Example::MethodizeExample.methodize  #=> "example__methodize_example"
  #
  # source://facets//lib/core/facets/class/methodize.rb#14
  def methodize; end

  # Converts a class name to a unix path.
  #
  #   module ::Example
  #     class PathizeExample
  #     end
  #   end
  #
  #   Example::PathizeExample.pathize  #=> "example/pathize_example"
  #
  # source://facets//lib/core/facets/class/pathize.rb#14
  def pathize; end

  # Returns an array with the direct children of +self+.
  #
  #   Integer.subclasses # => [Fixnum, Bignum]
  #
  # source://facets//lib/core/facets/class/subclasses.rb#17
  def subclasses; end

  # Convert instatiation of a class into a Proc.
  #
  #   class Person
  #     def initialize(name)
  #       @name = name
  #     end
  #
  #     def inspect
  #       @name.to_str
  #     end
  #   end
  #
  #   persons = %w(john bob jane hans).map(&Person)
  #
  #   persons.map{ |p| p.inspect }  #=> ['john', 'bob', 'jane', 'hans']
  #
  # CREDIT: Daniel Schierbeck
  #
  # source://facets//lib/core/facets/class/to_proc.rb#20
  def to_proc; end
end

# source://facets//lib/core/facets/comparable/cap.rb#1
module Comparable
  # Returns the lower of self or x.
  #
  #   4.at_least(5)  #=> 5
  #   6.at_least(5)  #=> 6
  #
  # CREDIT: Florian Gross
  #
  # source://facets//lib/core/facets/comparable/cap.rb#10
  def at_least(lower); end

  # Returns the greater of self or x.
  #
  #   4.at_most(5)  #=> 4
  #   6.at_most(5)  #=> 5
  #
  # CREDIT: Florian Gross
  #
  # source://facets//lib/core/facets/comparable/cap.rb#21
  def at_most(upper); end

  # Returns self if above the given lower bound, or
  # within the given lower and upper bounds,
  # otherwise returns the the bound of which the
  # value falls outside.
  #
  #   4.clip(3)    #=> 4
  #   4.clip(5)    #=> 5
  #   4.clip(2,7)  #=> 4
  #   9.clip(2,7)  #=> 7
  #   1.clip(2,7)  #=> 2
  #
  # CREDIT Florian Gross, Trans
  # Returns self if above the given lower bound, or
  # within the given lower and upper bounds,
  # otherwise returns the the bound of which the
  # value falls outside.
  #
  #   4.bound(3)    #=> 4
  #   4.bound(5)    #=> 5
  #   4.bound(2,7)  #=> 4
  #   9.bound(2,7)  #=> 7
  #   1.bound(2,7)  #=> 2
  #
  # CREDIT: Florian Gross
  #
  # source://facets//lib/core/facets/comparable/clip.rb#36
  def bound(lower, upper = T.unsafe(nil)); end

  # Returns the greater of self or x.
  #
  #   4.at_most(5)  #=> 4
  #   6.at_most(5)  #=> 5
  #
  # CREDIT: Florian Gross
  # Returns the greater of self or x.
  #
  #   4.cap(5)  #=> 4
  #   6.cap(5)  #=> 5
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/comparable/cap.rb#32
  def cap(upper); end

  # Returns self if above the given lower bound, or
  # within the given lower and upper bounds,
  # otherwise returns the the bound of which the
  # value falls outside.
  #
  #   4.clip(3)    #=> 4
  #   4.clip(5)    #=> 5
  #   4.clip(2,7)  #=> 4
  #   9.clip(2,7)  #=> 7
  #   1.clip(2,7)  #=> 2
  #
  # CREDIT Florian Gross, Trans
  #
  # source://facets//lib/core/facets/comparable/clip.rb#16
  def clip(lower, upper = T.unsafe(nil)); end

  # Alternate name for comparison operator #<=>.
  #
  #   3.cmp(1)   #=>  1
  #   3.cmp(3)   #=>  0
  #   3.cmp(10)  #=> -1
  #
  # This fundamental compare method is used to keep
  # comparison compatible with <tt>#succ</tt>.
  #
  # CREDIT: Peter Vanbroekhoven
  #
  # source://facets//lib/core/facets/comparable/cmp.rb#14
  def cmp(o); end

  class << self
    # Automatically generate comparitive definitions based on
    # attribute fields.
    #
    #   include Comparable[:a, :b]
    #
    # is equivalent to including a module containing:
    #
    #   def <=>(other)
    #     cmp = self.a <=> other.a; return cmp unless cmp == 0
    #     cmp = self.b <=> other.b; return cmp unless cmp == 0
    #     0
    #   end
    #
    # source://facets//lib/core/facets/comparable/op_get.rb#16
    def [](*accessors); end
  end
end

# Classes which include Denumerable will get versions of map,
# select, and so on, which return a Denumerator, so that they
# work horizontally without creating intermediate arrays.
#
# @author Brian Candler
# @author Trans
#
# source://facets//lib/core/facets/denumerable.rb#11
module Denumerable
  # source://facets//lib/core/facets/denumerable.rb#21
  def collect; end

  # source://facets//lib/core/facets/denumerable.rb#31
  def find_all; end

  # source://facets//lib/core/facets/denumerable.rb#14
  def map; end

  # source://facets//lib/core/facets/denumerable.rb#34
  def reject; end

  # source://facets//lib/core/facets/denumerable.rb#24
  def select; end

  # Skip the first n items in the list
  #
  # source://facets//lib/core/facets/denumerable.rb#55
  def skip(n); end

  # Limit to the first n items in the list
  #
  # source://facets//lib/core/facets/denumerable.rb#43
  def take(n); end
end

# = Denumerator
#
# A class like Enumerator, but which has 'lazy' versions of map, select etc.
#
# source://facets//lib/core/facets/denumerable.rb#74
class Denumerator < ::Enumerator
  include ::Denumerable
end

# source://facets//lib/core/facets/dir/ascend.rb#1
class Dir
  include ::Enumerable

  # Like #each, except the "." and ".." special files are ignored.
  # You can use +ignore+ to override '.' and '..' and ignore
  # other entries via a exact match or regular expression.
  #
  # CREDIT: Tyler Rick
  #
  # source://facets//lib/core/facets/dir/each_child.rb#8
  def each_child(*ignore); end

  class << self
    # Ascend a directory path.
    #
    #   a = []
    #
    #   Dir.ascend("/var/log") do |path|
    #     a << path
    #   end
    #
    #   a  #=> ['/var/log', '/var', '/']
    #
    # CREDIT: Daniel Berger, Jeffrey Schwab
    #
    # TODO: Make it work with windows too
    #       use FileTest.root?
    #
    # source://facets//lib/core/facets/dir/ascend.rb#20
    def ascend(dir, inclusive = T.unsafe(nil), &blk); end

    # Descend a directory path.
    #
    #   d = []
    #
    #   Dir.descend("/var/log") do |path|
    #     d << path
    #   end
    #
    #   d  #=> ['/', '/var', '/var/log']
    #
    # CREDIT: Daniel Berger, Jeffrey Schwab
    #
    # source://facets//lib/core/facets/dir/ascend.rb#46
    def descend(path); end

    # Same as Dir#recurse.
    #
    # source://facets//lib/core/facets/dir/recurse.rb#30
    def ls_r(path = T.unsafe(nil), &block); end

    # Like +glob+ but can take multiple patterns.
    #
    #   Dir.multiglob('tmp/*.rb', 'tmp/*.py')
    #
    # Rather then constants for options multiglob accepts a trailing options
    # hash of symbol keys...
    #
    #   :noescape    File::FNM_NOESCAPE
    #   :casefold    File::FNM_CASEFOLD
    #   :pathname    File::FNM_PATHNAME
    #   :dotmatch    File::FNM_DOTMATCH
    #   :strict      File::FNM_PATHNAME && File::FNM_DOTMATCH
    #
    # It also has an option for recurse...
    #
    #   :recurse     Recurively include contents of directories.
    #
    # For example
    #
    #   Dir.multiglob('tmp/*', :recurse => true)
    #
    # would have the same result as
    #
    #   Dir.multiglob('tmp/**/*')
    #
    # source://facets//lib/core/facets/dir/multiglob.rb#28
    def multiglob(*patterns); end

    # The same as +multiglob+, but recusively includes directories.
    #
    #   Dir.multiglob_r('tmp')
    #
    # is equivalent to
    #
    #   Dir.multiglob('tmp', :recurse=>true)
    #
    # The effect of which is
    #
    #   Dir.multiglob('tmp', 'tmp/**/**')
    #
    # source://facets//lib/core/facets/dir/multiglob.rb#66
    def multiglob_r(*patterns); end

    # Is a path parental to another?
    #
    #   Dir.parent?('parent', 'parent/child')  #=> true
    #
    # TODO: Needs improvement.
    #
    # TODO: Instance version?
    #
    # @return [Boolean]
    #
    # source://facets//lib/core/facets/dir/parent.rb#11
    def parent?(parent_path, child_path); end

    # Recursively scan a directory and pass each file to the given block.
    #
    #   Dir.recurse('.') do |path|
    #     # ...
    #   end
    #
    # CREDIT: George Moschovitis
    #
    # TODO: If fully compatible, reimplement as alias of Find.find,
    # or just copy and paste Find.find code here if it looks more robust.
    #
    # source://facets//lib/core/facets/dir/recurse.rb#14
    def recurse(path = T.unsafe(nil), &block); end
  end
end

# source://facets//lib/core/facets/enumerable/recursively.rb#1
module Enumerable
  extend ::ActiveSupport::EnumerableCoreExt::Constants

  # Accumulate a set of a set. For example, in an ORM design
  # where `Group has_many User` we might have something
  # equivalent to the following.
  #
  #     Group = Struct.new(:users)
  #     User  = Struct.new(:name, :friends)
  #
  #     user1 = User.new('John', [])
  #     user2 = User.new('Jane', ['Jill'])
  #     user3 = User.new('Joe' , ['Jack', 'Jim'])
  #
  #     group1 = Group.new([user1, user2])
  #     group2 = Group.new([user2, user3])
  #
  #     groups = [group1, group2]
  #
  # Now we can *accumulate* the users of all groups.
  #
  #     groups.accumulate.users  #=> [user1, user2, user3]
  #
  # You may pass an argument to perform chains, e.g. the following
  # returns the names of users from all groups.
  #
  #     groups.accumulate(2).users.name  #=> ['John','Jane','Joe']
  #
  # Or we can gather all the friends of all users in groups.
  #
  #     groups.accumulate(2).users.friends  #=> ['Jill','Jack','Jim']
  #
  # This is more convenient then the equivalent.
  #
  #     groups.accumulate.users.accumulate.friends  #=> ['Jill','Jack','Jim']
  #
  # CREDIT: George Moshchovitis, Daniel Emirikol, Robert Dober
  #
  # source://facets//lib/core/facets/enumerable/accumulate.rb#42
  def accumulate(iterations = T.unsafe(nil)); end

  # Same as #accumulate, but does not apply #uniq to final result.
  #
  #     groups.accumulate_all(2).users.friends  #=> ['Jill', 'Jill','Jack','Jim']
  #
  # source://facets//lib/core/facets/enumerable/accumulate.rb#56
  def accumulate_all(iterations = T.unsafe(nil)); end

  # Clusters together adjacent elements into a list of sub-arrays.
  #
  #     [2,2,2,3,3,4,2,2,1].cluster{ |x| x }
  #     => [[2, 2, 2], [3, 3], [4], [2, 2], [1]]
  #
  #     ["dog", "duck", "cat", "dude"].cluster{ |x| x[0] }
  #     => [["dog", "duck"], ["cat"], ["dude"]]
  #
  # @author Oleg K
  #
  # source://facets//lib/core/facets/enumerable/cluster.rb#13
  def cluster; end

  # Similar to #group_by but returns an array of the groups.
  # Returned elements are sorted by block.
  #
  #    %w{this is a test}.organize_by {|x| x[0]}
  #    #=> [ ['a'], ['is'], ['this', 'test'] ]
  #
  # CREDIT: Erik Veenstra
  # DEPRECATED: Name changed to avoid confusion with #cluster.
  #
  # source://facets//lib/core/facets/enumerable/organize_by.rb#16
  def cluster_by(&b); end

  # Same as #collect but with an iteration counter.
  #
  #   a = [1,2,3].collect_with_index { |e,i| e*i }
  #   a  #=> [0,2,6]
  #
  # CREDIT: Gavin Sinclair
  # Alias for map_with_index.
  #
  # source://facets//lib/core/facets/enumerable/map_with_index.rb#20
  def collect_with_index; end

  # A more versitle #compact method. It can be used to
  # collect and filter items out in one single step.
  #
  #   c = [1,2,3].compact_map do |n|
  #     n < 2 ? nil : n
  #   end
  #
  #   c  #=> [2,3]
  #
  # CREDIT: Trans
  #
  # DEPRECATE: This method should probably be removed b/c #purge
  # does almost the same thing and enum.map{}.compact works too.
  #
  # source://facets//lib/core/facets/enumerable/compact_map.rb#33
  def compact_collect(&block); end

  # A more versitle #compact method. It can be used to
  # collect and filter items out in one single step.
  #
  #   c = [1,2,3].compact_map do |n|
  #     n < 2 ? nil : n
  #   end
  #
  #   c  #=> [2,3]
  #
  # CREDIT: Trans
  #
  # DEPRECATE: This method should probably be removed b/c #purge
  # does almost the same thing and enum.map{}.compact works too.
  #
  # source://facets//lib/core/facets/enumerable/compact_map.rb#17
  def compact_map(&block); end

  # Without a block: wrap the Enumerable object in such a way that map,
  # select and similar operations are performed "horizontally" across a
  # series of blocks, instead of building an array of results at each step.
  # This reduces memory usage, allows partial results to be provided
  # early, and permits working with infinite series.
  #
  #   a = (1..1_000_000_000).defer.select{ |i| i % 2 == 0 }.
  #                                map{ |i| i + 100 }.
  #                                take(10).to_a
  #
  # With a block: the block acts as an arbitrary filter on the data. Unlike
  # map, it can choose to drop elements from the result, and/or add
  # additional ones. The first object passed to the block is the receiver
  # of the output.
  #
  #   (1..1_000_000_000).
  #     defer { |out,i| out << i if i % 2 == 0 }.  # like select
  #     defer { |out,i| out << i + 100 }.          # like map
  #     take(10).to_a
  #
  # Use a method like to_a or to_h at the end of the chain when you want an
  # Array or Hash built with the results, or each{...} if you just want
  # to output each result and discard it.
  #
  # source://facets//lib/core/facets/enumerable/defer.rb#29
  def defer(&blk); end

  # Iterate through slices. If slice +steps+ is not
  # given, the arity of the block is used.
  #
  #   x = []
  #   [1,2,3,4].each_by{ |a,b| x << [a,b] }
  #   x  #=> [ [1,2], [3,4] ]
  #
  #   x = []
  #   [1,2,3,4,5,6].each_by(3){ |a| x << a }
  #   x  #=> [ [1,2,3], [4,5,6] ]
  #
  # This is just like each_slice, except that it will check
  # the arity of the block. If each_slice ever suppots this
  # this method can be deprecated.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/enumerable/each_by.rb#22
  def each_by(steps = T.unsafe(nil), &block); end

  # Returns an elementwise Functor designed to make R-like
  # elementwise operations possible. This is very much like
  # the #every method, but it treats array argument specially.
  #
  #   ([1,2].ewise + 3)          #=> [4,5]
  #
  # Vector to vector
  #
  #   ([1,2].ewise + [4,5])      #=> [5,7]
  #
  # Special thanks to Martin DeMello for helping to develop this.
  # Long-term for #ewise.
  #
  #   a = [1,2]
  #   (a.elementwise + 3)          #=> [4,5]
  #   (a.elementwise + [4,5])      #=> [5,7]
  #
  # source://facets//lib/core/facets/enumerable/ewise.rb#58
  def elementwise(count = T.unsafe(nil)); end

  # Returns an elemental object. This allows
  # you to map a method on to every element.
  #
  #   r = [1,2,3].every + 3
  #   r  #=> [4,5,6]
  #
  # source://facets//lib/core/facets/enumerable/every.rb#11
  def every; end

  # In place version of #every.
  #
  # @raise [NoMethodError]
  #
  # source://facets//lib/core/facets/enumerable/every.rb#17
  def every!; end

  # Returns an elementwise Functor designed to make R-like
  # elementwise operations possible. This is very much like
  # the #every method, but it treats array argument specially.
  #
  #   ([1,2].ewise + 3)          #=> [4,5]
  #
  # Vector to vector
  #
  #   ([1,2].ewise + [4,5])      #=> [5,7]
  #
  # Special thanks to Martin DeMello for helping to develop this.
  #
  # source://facets//lib/core/facets/enumerable/ewise.rb#19
  def ewise(count = T.unsafe(nil)); end

  # Expand all elements of an Enumerable object.
  #
  #   [0, 2..3, 5..7].expand  #=> [0,[2, 3],[5,6,7]]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/enumerable/expand.rb#8
  def expand; end

  # The block acts as an arbitrary filter on the data. Unlike map,
  # it can choose to drop elements from the result and/or add
  # additional elements. The first object passed to the block is
  # the receiver of the output.
  #
  #   x = (1..10000)
  #   x = x.filter{ |out,i| out << i if i % 2 == 0 }   # like select
  #   x = x.filter{ |out,i| out << i + 100 }           # like map
  #   x = x.take(3)
  #
  #   x  #=> [102, 104, 106]
  #
  # This is very similar to #each_with_object, but #filter handles
  # argument better by reversing their order and using the splat
  # operator. (This was also once known as #injecting.)
  #
  # CREDIT: David Black, Louis J Scoras
  #
  # source://facets//lib/core/facets/enumerable/filter.rb#21
  def filter(output = T.unsafe(nil)); end

  # Yield each element to the block and return the result
  # of the block when that result evaluates as true,
  # terminating early like #detect and #find.
  #
  #   obj1 = Object.new
  #   obj2 = Object.new
  #
  #   def obj1.foo?; false; end
  #   def obj2.foo?; true ; end
  #
  #   def obj1.foo ; "foo1"; end
  #   def obj2.foo ; "foo2"; end
  #
  #   [obj1, obj2].find_yield{ |obj| obj.foo if obj.foo? }  #=> "foo2"
  #
  # Another example.
  #
  #   [1,2,3,4,5].find_yield{ |i| j = i+1; j if j % 4 == 0 }  #=> 4
  #
  # If the block is never true, return the object given in the first parameter,
  # or nil if none specified.
  #
  #   [1,2,3].find_yield{ |_| false }    #=> nil
  #   [false].find_yield(1){ |_| false } #=> 1
  #
  # source://facets//lib/core/facets/enumerable/find_yield.rb#28
  def find_yield(fallback = T.unsafe(nil)); end

  # Generates a hash mapping each unique symbol in the array
  # to the absolute frequency it appears.
  #
  #   [:a,:a,:b,:c,:c,:c].frequency  #=> {:a=>2,:b=>1,:c=>3}
  #
  # CREDIT: Brian Schröder
  #
  # --
  # NOTE: So why not use #inject here? e.g. ...
  #
  #   inject(Hash.new(0)){|p,v| p[v]+=1; p}
  #
  # Because it is a fair bit slower than the traditional definition.
  # ++
  #
  # source://facets//lib/core/facets/enumerable/frequency.rb#18
  def frequency; end

  # Like `#map`/`#collect`, but generates a Hash. The block is expected
  # to return two values: the key and the value for the new hash.
  #
  #   numbers  = (1..3)
  #   squares  = numbers.graph{ |n| [n, n*n] }   # { 1=>1, 2=>4, 3=>9 }
  #   sq_roots = numbers.graph{ |n| [n*n, n] }   # { 1=>1, 4=>2, 9=>3 }
  #
  # CREDIT: Andrew Dudzik (adudzik), Trans
  #
  # source://facets//lib/core/facets/enumerable/graph.rb#12
  def graph(&yld); end

  # The same as #include? but tested using #=== instead of #==.
  #
  #   [1, 2, "a"].incase?(2)       #=> true
  #   [1, 2, "a"].incase?(String)  #=> true
  #   [1, 2, "a"].incase?(3)       #=> false
  #
  # Why the name `incase`? Because the method uses case-equality.
  # Along with the alliteration for "in case" and the similarity
  # with "include?", it seemed like the perfect fit.
  #
  # @author Lavir the Whiolet
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/enumerable/incase.rb#15
  def incase?(what); end

  # Convert enumerable into a Hash, iterating over each member
  # where the provided block must return the key to by used
  # to map to the value.
  #
  # Examples:
  #
  #   [:a,:b,:c].key_by{ |v| v.to_s }
  #   #=> {'a'=>:a, 'b'=>:b, 'c'=>:c}
  #
  # TODO: How should this method behave with a Hash?
  #
  # Returns: Hash
  #
  # source://facets//lib/core/facets/enumerable/key_by.rb#16
  def key_by; end

  # Like #group_by, but maps the second value returned from the block.
  #
  #   a = [1,2,3,4,5]
  #   a.map_by{ |e| [e % 2, e + 1] }
  #   #=> { 0=>[3,5], 1=>[2,4,6] }
  #
  # Works well with a hash too.
  #
  #   h = {"A"=>1, "B"=>1, "C"=>1, "D"=>2, "E"=>2}
  #   h.map_by{ |k,v| [v, k.downcase] }
  #   #=> {1=>["a", "b", "c"], 2=>["d", "e"]}
  #
  # If a second value is not returned, #map_by acts like #group_by.
  #
  #   h = {"A"=>1, "B"=>1, "C"=>1, "D"=>2, "E"=>2}
  #   h.map_by{ |k,v| v }
  #   #=> {1=>[["A",1], ["B",1], ["C",1]], 2=>[["D",2], ["E",2]]}
  #
  # source://facets//lib/core/facets/enumerable/map_by.rb#21
  def map_by; end

  # Yield each element to the block and return the result
  # of the block when that result evaluates as true,
  # terminating early like #detect and #find.
  #
  #   obj1 = Object.new
  #   obj2 = Object.new
  #
  #   def obj1.foo?; false; end
  #   def obj2.foo?; true ; end
  #
  #   def obj1.foo ; "foo1"; end
  #   def obj2.foo ; "foo2"; end
  #
  #   [obj1, obj2].find_yield{ |obj| obj.foo if obj.foo? }  #=> "foo2"
  #
  # Another example.
  #
  #   [1,2,3,4,5].find_yield{ |i| j = i+1; j if j % 4 == 0 }  #=> 4
  #
  # If the block is never true, return the object given in the first parameter,
  # or nil if none specified.
  #
  #   [1,2,3].find_yield{ |_| false }    #=> nil
  #   [false].find_yield(1){ |_| false } #=> 1
  # Alias for #find_yield.
  #
  # DEPRECATE: This has been renamed to #find_yield.
  #
  # source://facets//lib/core/facets/enumerable/find_yield.rb#39
  def map_detect(fallback = T.unsafe(nil)); end

  # Send a message to each element and collect the result.
  #
  #   [1,2,3].map_send(:+, 3)  #=> [4,5,6]
  #
  # CREDIT: Sean O'Halpin
  #
  # source://facets//lib/core/facets/enumerable/map_send.rb#9
  def map_send(meth, *args, &block); end

  # Combines #zip and #map in a single efficient operation.
  #
  #   h = {}
  #   [1,2,3].map_with [:x,:y,:z] do |n,k|
  #     h[k] = n
  #   end
  #   h  #=> {:x=>1, :y=>2, :z=>3}
  #
  # @author Michael Kohl
  # @return [Hash]
  #
  # source://facets//lib/core/facets/enumerable/map_with.rb#14
  def map_with(*arrays, &block); end

  # Same as #collect but with an iteration counter.
  #
  #   a = [1,2,3].collect_with_index { |e,i| e*i }
  #   a  #=> [0,2,6]
  #
  # CREDIT: Gavin Sinclair
  #
  # source://facets//lib/core/facets/enumerable/map_with_index.rb#10
  def map_with_index; end

  # Like `#map`/`#collect`, but generates a Hash. The block is expected
  # to return two values: the key and the value for the new hash.
  #
  #   numbers  = (1..3)
  #   squares  = numbers.mash{ |n| [n, n*n] }   # { 1=>1, 2=>4, 3=>9 }
  #   sq_roots = numbers.mash{ |n| [n*n, n] }   # { 1=>1, 4=>2, 9=>3 }
  #
  # CREDIT: Andrew Dudzik (adudzik), Trans
  #
  # source://facets//lib/core/facets/enumerable/mash.rb#12
  def mash(&yld); end

  # Divide an array into groups by modulo of the index.
  #
  #   [2,4,6,8].modulate(2)  #=> [[2,6],[4,8]]
  #
  # CREDIT: Trans
  #
  # NOTE: Would the better name for this be 'collate'?
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/enumerable/modulate.rb#11
  def modulate(modulo); end

  # Returns an array of elements for the elements that occur n times.
  # Or according to the results of a given block.
  #
  #     a = [1,1,2,3,3,4,5,5]
  #
  #     a.occur(1).sort               #=> [2,4]
  #     a.occur(2).sort               #=> [1,3,5]
  #     a.occur(3).sort               #=> []
  #
  #     a.occur(1..1).sort            #=> [2,4]
  #     a.occur(2..3).sort            #=> [1,3,5]
  #
  #     a.occur { |n| n == 1 }.sort   #=> [2,4]
  #     a.occur { |n| n > 1 }.sort    #=> [1,3,5]
  #
  # source://facets//lib/core/facets/enumerable/occur.rb#18
  def occur(n = T.unsafe(nil)); end

  # Returns the _only_ element in the enumerable. Raises an IndexError if
  # the enumreable has more then one element.
  #
  #   [5].only      # => 5
  #
  #   expect IndexError do
  #     [1,2,3].only
  #   end
  #
  #   expect IndexError do
  #     [].only
  #   end
  #
  # CREDIT: Lavir the Whiolet, Gavin Sinclair, Noah Gibbs
  #
  # source://facets//lib/core/facets/enumerable/only.rb#18
  def only; end

  # Does this Enumerable have the only element?
  #
  # It differs from Enumerable#one? in that it does not check the items
  # themselves. It checks the quantity only.
  #
  # CREDIT: Lavir the Whiolet
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/enumerable/only.rb#45
  def only?; end

  # Similar to #group_by but returns an array of the groups.
  # Returned elements are sorted by block.
  #
  #    %w{this is a test}.organize_by {|x| x[0]}
  #    #=> [ ['a'], ['is'], ['this', 'test'] ]
  #
  # CREDIT: Erik Veenstra
  #
  # source://facets//lib/core/facets/enumerable/organize_by.rb#11
  def organize_by(&b); end

  # Like `each_slice(2)` but ensures the last
  # element has a pair if odd sized.
  #
  #   [:a,1,:b,2,:c,3].pair.to_a  #=> [[:a,1],[:b,2],[:c,3]]
  #
  # source://facets//lib/core/facets/enumerable/pair.rb#8
  def pair(missing = T.unsafe(nil)); end

  # Per element meta-functor.
  #
  #     ([1,2,3].per(:map) + 3)     #=> [4,5,6]
  #     ([1,2,3].per(:select) > 1)  #=> [2,3]
  #
  # Using fluid notation.
  #
  #     ([1,2,3].per.map + 3)       #=> [4,5,6]
  #     ([1,2,3].per.select > 1)    #=> [2,3]
  #
  # source://facets//lib/core/facets/enumerable/per.rb#21
  def per(enum_method = T.unsafe(nil), *enum_args); end

  # A versitle compaction method. Like #map but used
  # to filter out multiple items in a single step.
  #
  # Without +trash+ arguments +nil+ is assumed.
  #
  #   [1, nil, 2].purge  #=> [1,2]
  #
  # If +trash+ arguments are given, each argument is
  # compared for a match using #==.
  #
  #   (1..6).purge(3,4)  #=> [1,2,5,6]
  #
  # If a block is given, the yield is used in the
  # matching condition instead of the element itsef.
  #
  #   (1..6).purge(0){ |n| n % 2 }  #=> [1,3,5]
  #
  # NOTE: This could just as well be an override of the
  # core #compact method, but to avoid potential issues
  # associated with overriding core methods we use the
  # alternate name #purge.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/enumerable/purge.rb#27
  def purge(*trash, &block); end

  # Returns a recursive functor, that allows enumerable methods to iterate
  # through enumerable sub-elements. By default it only recurses over
  # elements of the same type.
  #
  # source://facets//lib/core/facets/enumerable/recursively.rb#7
  def recursively(*types, &block); end

  # Squeeze out the same elements. This behaves like C++ unique(),
  # removing equivalent elements that are concomitant to each other.
  # To get a similar result with Array#uniq, the array would have to
  # be sorted first.
  #
  # Calculation order is O(n).
  #
  # Examples
  #
  #   [1,2,2,3,3,2,1].squeeze #=> [1,2,3,2,1]
  #   [1,2,2,3,3,2,1].sort.squeeze #=> [1,2,3]
  #   [1,2,2,3,3,2,1].squeeze(*[3]) #=> [1,2,2,3,2,1]
  #
  # Returns [Array].
  #
  # CREDIT: T. Yamada
  #
  # source://facets//lib/core/facets/enumerable/squeeze.rb#20
  def squeeze(*limited_to); end

  # Uses #+ to sum the enumerated elements.
  #
  #     [1,2,3].sum      #=> 6
  #     [3,3,3].sum      #=> 9
  #
  # Note that Facets' sum method is completely generic -- it can work
  # on any objects that respond to #+.
  #
  #     [[1],[2],[3]].sum   #=> [1,2,3]
  #
  # For this reason it is usually a good idea to provide a default
  # value. Consider the difference between the two expressions below.
  #
  #     [].sum           #=> nil
  #     [].sum(0)        #=> 0
  #
  # This default value also acts as an initial value.
  #
  #     [].sum(5)        #=> 5
  #     [1,2,3].sum(10)  #=> 16
  #
  # A block can also be passed to coax the elements before summation.
  #
  #     [1.1,2.2,3.3].sum(10.4, &:to_i)  #=> 16.4
  #
  # Notice the initial value is not effected by the block.
  #
  # @author Dawid Marcin Grzesiak
  #
  # source://facets//lib/core/facets/enumerable/sum.rb#32
  def sum(*identity, &block); end

  # Like #uniq, but determines uniqueness based on a given block.
  #
  #   (-5..5).to_a.uniq_by {|i| i*i }
  #   #=> [-5, -4, -3, -2, -1, 0]
  #
  # source://facets//lib/core/facets/enumerable/uniq_by.rb#8
  def uniq_by; end

  # Create a hash whose keys are the enumerable's elements, with specified
  # values.
  #
  # If no block is given, the given parameter (default true) is used for
  # all values, e.g.:
  #
  #     [1,2,3].value_by{ true }     #=> {1=>true, 2=>true, 3=>true}
  #     [1,2,3].value_by{ "a" }      #=> {1=>"a", 2=>"a", 3=>"a"}
  #
  # If a block is given, each key's value is the result of running the
  # block for that key, e.g.:
  #
  #     [1,2,3].value_by{ |n| "a"*n }  #=> {1=>"a", 2=>"aa", 3=>"aaa"}
  #
  # @author Ronen Barzel
  #
  # source://facets//lib/core/facets/enumerable/value_by.rb#18
  def value_by; end

  # Recursively iterate over all Enumerable elements, or
  # subset given :type=>[type1, type2, ...].
  #
  #   [1, 2, 8..9].visit{ |x| x.succ }
  #   # => [2, 3, [9, 10]]
  #
  # source://facets//lib/core/facets/enumerable/visit.rb#9
  def visit(opts = T.unsafe(nil), &block); end

  # Combines #zip and #map in a single efficient operation.
  #
  #   h = {}
  #   [1,2,3].map_with [:x,:y,:z] do |n,k|
  #     h[k] = n
  #   end
  #   h  #=> {:x=>1, :y=>2, :z=>3}
  #
  # @author Michael Kohl
  # @return [Hash]
  #
  # source://facets//lib/core/facets/enumerable/map_with.rb#19
  def zip_map(*arrays, &block); end
end

# Recursor is a specialized Functor for recurively iterating over Enumerables.
#
# TODO: Return Enumerator if no +yld+ block is given.
#
# TODO: Add limiting +depth+ option to Enumerable#recursively?
#
# source://facets//lib/core/facets/enumerable/recursively.rb#17
class Enumerable::Recursor
  # @return [Recursor] a new instance of Recursor
  #
  # source://facets//lib/core/facets/enumerable/recursively.rb#20
  def initialize(enum, *types, &block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#26
  def method_missing(op, &yld); end

  private

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def !; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def !=(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def !~(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def <=>(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def ==(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def ===(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def abort(*_args, **_kwargs, &_block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def acts_like?(duck); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def as_json(options = T.unsafe(nil)); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def blank?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def bool?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def bool_chain(&block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def cascade(&block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def class; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def class_eval(*args, &block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def class_exists?(class_name); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def clone(freeze: T.unsafe(nil)); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def deep_dup; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def define_singleton_method(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def display(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def dup; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def duplicable?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def enum_for(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def eql?(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def equal?(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def exit(*_args, **_kwargs, &_block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def extend(*mod, &blk); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def false?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def false_?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def freeze; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def friendly_id?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def frozen?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def gem(dep, *reqs); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def hash; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def html_safe?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def in?(another_object); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def inspect; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def instance_eval(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def instance_exec(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def instance_of?(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def instance_values; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def instance_variable_defined?(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def instance_variable_get(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def instance_variable_names; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def instance_variable_set(_arg0, _arg1); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def instance_variables; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def is_a?(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def is_an?(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def is_not_a?(compare); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def is_not_an?(compare); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def is_one_of?(*klasses); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def itself; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def kind_of?(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def method(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def method_chain(ret_val = T.unsafe(nil), &block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def methods(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def nil?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def nil_chain(ret_val = T.unsafe(nil), &block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def not_nil?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def numeric?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def presence; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def presence_in(another_object); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def present?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def pretty_inspect; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def pretty_print(q); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def pretty_print_cycle(q); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def pretty_print_inspect; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def pretty_print_instance_variables; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def private_methods(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def protected_methods(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def public_method(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def public_methods(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def public_send(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def remove_instance_variable(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def require_dependency(filename); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def respond_to?(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def same_as(compare); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def same_as?(compare); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def send(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def silently(*streams); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def singleton_class; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def singleton_method(_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def singleton_methods(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def tap; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def then; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def to_enum(*_arg0); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def to_json(options = T.unsafe(nil)); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def to_param; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def to_query(key); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def to_s; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def to_yaml(options = T.unsafe(nil)); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def true?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def true_?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def try(*args, **_arg1, &block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def try!(*args, **_arg1, &block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def unfriendly_id?; end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def with(**attributes); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def with_options(options, &block); end

  # source://facets//lib/core/facets/enumerable/recursively.rb#18
  def yield_self; end
end

# source://facets//lib/core/facets/enumerator/fx.rb#3
class Enumerator
  include ::Enumerable

  # source://facets//lib/core/facets/enumerator/fx.rb#8
  def fx; end
end

class Enumerator::ArithmeticSequence < ::Enumerator
  def ==(_arg0); end
  def ===(_arg0); end
  def begin; end
  def each; end
  def end; end
  def eql?(_arg0); end
  def exclude_end?; end
  def first(*_arg0); end
  def hash; end
  def inspect; end
  def last(*_arg0); end
  def size; end
  def step; end
end

class Enumerator::Generator
  include ::Enumerable
end

class Enumerator::Producer
  def each; end
end

class Enumerator::Product < ::Enumerator
  def initialize(*_arg0); end

  def each; end
  def inspect; end
  def rewind; end
  def size; end

  private

  def initialize_copy(_arg0); end
end

# source://facets//lib/core/facets/exception/detail.rb#1
class Exception
  # Pretty string output of exception/error object useful for helpful
  # debug messages.
  #
  # @author George Moschovitis
  #
  # source://facets//lib/core/facets/exception/detail.rb#8
  def detail; end

  class << self
    # Does a block raise an a given +exception+.
    #
    # @return [Boolean]
    #
    # source://facets//lib/core/facets/exception/raised.rb#5
    def raised?; end

    # Supress errors while executing a block, with execptions.
    #
    # CREDIT: David Heinemeier Hansson, Thomas Sawyer
    #
    # source://facets//lib/core/facets/exception/suppress.rb#7
    def suppress(*exception_classes); end
  end
end

# source://facets//lib/core/facets/version.rb#1
module Facets
  class << self
    # source://facets//lib/core/facets/version.rb#11
    def const_missing(name); end

    # source://facets//lib/core/facets/version.rb#3
    def index; end
  end
end

# deprecate
#
# source://facets//lib/core/facets/version.rb#17
Facets::VERSION = T.let(T.unsafe(nil), String)

# source://facets//lib/core/facets/boolean.rb#44
class FalseClass
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/blank.rb#50
  def blank?; end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#45
  def clone?; end

  # Since FalseClass is immutable it cannot be duplicated.
  # For this reason #try_dup returns +self+.
  #
  #   false.dup!  #=> false
  #
  # source://facets//lib/core/facets/object/dup.rb#43
  def dup!; end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#44
  def dup?; end

  # source://facets//lib/core/facets/boolean.rb#45
  def to_bool; end
end

# source://facets//lib/core/facets/file/append.rb#1
class File < ::IO
  class << self
    # Append to a file.
    #
    # CREDIT: George Moschovitis
    #
    # source://facets//lib/core/facets/file/append.rb#7
    def append(file, str); end

    # Given an array of path strings, find the longest common prefix path.
    #
    # @author Aaron Gibralter
    #
    # source://facets//lib/core/facets/file/common_path.rb#6
    def common_path(*paths); end

    # Creates a new file, or overwrites an existing file,
    # and writes a string into it. Can also take a block
    # just like File#open, which is yielded _after_ the
    # string is writ.
    #
    #   str = 'The content for the file'
    #   File.create('myfile.txt', str)
    #
    # CREDIT: George Moschovitis
    #
    # source://facets//lib/core/facets/file/create.rb#13
    def create(path, str = T.unsafe(nil), &blk); end

    # Takes a file name string and returns or changes its extension.
    #
    # Without a new extension argument, returns the extension of the
    # file name. In this respect #ext is like #extname, but unlike
    # #extname it does not include the dot prefix.
    #
    # With a new extension argument, changes the exension of the file
    # name to the new extension and returns it.
    #
    # Examples
    #
    #   File.ext('file.rb')          # => 'rb'
    #   File.ext('file.rb', 'txt')   # => 'file.txt'
    #   File.ext('file.rb', '.txt')  # => 'file.txt'
    #   File.ext('file.rb', '')      # => 'file'
    #
    # This method can be used with String#file for more object-oriented notation:
    #
    #   'file.rb'.file.ext('txt')    # => 'file.txt'
    #
    # CREDIT: Lavir the Whiolet
    #
    # source://facets//lib/core/facets/file/ext.rb#25
    def ext(filename, new_ext = T.unsafe(nil)); end

    # Platform dependent null device.
    #
    # CREDIT: Daniel Burger
    #
    # source://facets//lib/core/facets/file/null.rb#7
    def null; end

    # Read in a file as binary data.
    #
    # Assuming we had a binary file 'binary.dat'.
    #
    #   File.read_binary('binary.dat')
    #
    # CREDIT: George Moschovitis
    #
    # source://facets//lib/core/facets/file/read_binary.rb#11
    def read_binary(fname); end

    # Reads in a file, removes blank lines and removes lines starting
    # with '#' and then returns an array of all the remaining lines.
    #
    # Thr remark indicator can be overridden via the +:omit:+ option, which
    # can be a regualar expression or a string that is match against the
    # start of a line.
    #
    # CREDIT: Trans
    #
    # source://facets//lib/core/facets/file/read_list.rb#12
    def read_list(filepath, options = T.unsafe(nil)); end

    # Opens a file as a string and writes back the string to the file at
    # the end of the block.
    #
    # Returns the number of written bytes or +nil+ if the file wasn't
    # modified.
    #
    # Note that the file will even be written back in case the block
    # raises an exception.
    #
    # Mode can either be "b" or "+" and specifies to open the file in
    # binary mode (no mapping of the plattform's newlines to "\n" is
    # done) or to append to it.
    #
    # Assuming we had a file 'message.txt' and had a binary file 'binary.dat'.
    #
    #   # Reverse contents of "message.txt"
    #   File.rewrite("message.txt") { |str| str.reverse }
    #
    #   # Replace "foo" by "bar" in "binary.dat".
    #   File.rewrite("binary.dat", "b") { |str| str.gsub("foo", "bar") }
    #
    # IMPORTANT: The old version of this method required in place modification
    # of the file string. The new version will write whatever the block
    # returns instead!!!
    #
    # CREDIT: George Moschovitis
    #
    # source://facets//lib/core/facets/file/rewrite.rb#30
    def rewrite(name, mode = T.unsafe(nil)); end

    # In place version of #rewrite. This version of method requires that the
    # string be modified in place within the block.
    #
    #   # Reverse contents of "message"
    #   File.rewrite("message.txt") { |str| str.reverse! }
    #
    #   # Replace "foo" by "bar" in "binary"
    #   File.rewrite("binary.dat", "b") { |str| str.gsub!("foo", "bar") }
    #
    # source://facets//lib/core/facets/file/rewrite.rb#64
    def rewrite!(name, mode = T.unsafe(nil)); end

    # Returns only the first portion of the directory of
    # a file path name.
    #
    #   File.rootname('lib/jump.rb')  #=> 'lib'
    #   File.rootname('/jump.rb')     #=> '/'
    #   File.rootname('jump.rb')      #=> '.'
    #
    # CREDIT: Trans
    #
    # source://facets//lib/core/facets/file/rootname.rb#12
    def rootname(path); end

    # Cleans up a filename to ensure it will work on a filesystem.
    #
    #   File.sanitize("yo+baby!")   #=> 'yo+baby_'
    #   File.sanitize(".what&up")  #=> '.what_up'
    #
    # CREDIT: George Moschovitis
    #
    # source://facets//lib/core/facets/file/sanitize.rb#10
    def sanitize(filename); end

    # Splits a file path into an array of individual path components.
    # This differs from <tt>File.split</tt>, which divides the path into
    # only two parts, directory path and basename.
    #
    #   File.split_all("a/b/c")  #=> ['a', 'b', 'c']
    #
    # CREDIT: Trans
    #
    # source://facets//lib/core/facets/file/split_all.rb#11
    def split_all(path); end

    # Return the head of path from the rest of the path.
    #
    #   File.split_root('etc/xdg/gtk')  #=> ['etc', 'xdg/gtk']
    #
    # source://facets//lib/core/facets/file/split_root.rb#7
    def split_root(path); end

    # Writes the given array of data to the given path and closes the file.
    # This is done in binary mode, complementing <tt>IO.readlines</tt> in
    # standard Ruby.
    #
    # Note that +readlines+ (the standard Ruby method) returns an array of lines
    # <em>with newlines intact</em>, whereas +writelines+ uses +puts+, and so
    # appends newlines if necessary.  In this small way, +readlines+ and
    # +writelines+ are not exact opposites.
    #
    #   data = ['The content', ['for the file']]
    #   File.writelines('writelines.txt', data)
    #
    # Returns number of lines written.
    #
    # CREDIT: Noah Gibbs, Gavin Sinclair
    #
    # source://facets//lib/core/facets/file/writelines.rb#19
    def writelines(path, data); end
  end
end

# source://facets//lib/core/facets/filetest/separator_pattern.rb#1
module FileTest
  private

  # Predicate method for testing whether a path is absolute.
  # It returns +true+ if the pathname begins with a slash.
  #
  # source://facets//lib/core/facets/filetest/relative.rb#9
  def absolute?(path); end

  # List File.split, but preserves the file separators.
  #
  #   FileTest.chop_basename('/usr/lib') #=> ['/usr/', 'lib']
  #   FileTest.chop_basename('/') #=> nil
  #
  # Returns Array of `[pre-basename, basename]` or `nil`.
  #
  # This method is here simply to support the #relative? and #absolute? methods.
  #
  # source://facets//lib/core/facets/filetest/relative.rb#29
  def chop_basename(path); end

  # Does the +parent+ contain the +child+?
  #
  # source://facets//lib/core/facets/filetest/contains.rb#6
  def contains?(child, parent = T.unsafe(nil)); end

  # The opposite of #absolute?
  #
  # source://facets//lib/core/facets/filetest/relative.rb#14
  def relative?(path); end

  # Is the specified directory the root directory?
  #
  # CREDIT: Jeffrey Schwab
  #
  # source://facets//lib/core/facets/filetest/root.rb#9
  def root?(dir = T.unsafe(nil)); end

  # Is a path considered reasonably "safe"?
  #
  # Do not mistake this for a perfect solution!
  # Please help improve if you know how!
  #
  # Returns [Boolean]
  #
  # source://facets//lib/core/facets/filetest/safe.rb#14
  def safe?(path); end

  class << self
    # Predicate method for testing whether a path is absolute.
    # It returns +true+ if the pathname begins with a slash.
    #
    # @return [Boolean]
    #
    # source://facets//lib/core/facets/filetest/relative.rb#9
    def absolute?(path); end

    # List File.split, but preserves the file separators.
    #
    #   FileTest.chop_basename('/usr/lib') #=> ['/usr/', 'lib']
    #   FileTest.chop_basename('/') #=> nil
    #
    # Returns Array of `[pre-basename, basename]` or `nil`.
    #
    # This method is here simply to support the #relative? and #absolute? methods.
    #
    # source://facets//lib/core/facets/filetest/relative.rb#29
    def chop_basename(path); end

    # Does the +parent+ contain the +child+?
    #
    # @return [Boolean]
    #
    # source://facets//lib/core/facets/filetest/contains.rb#6
    def contains?(child, parent = T.unsafe(nil)); end

    # The opposite of #absolute?
    #
    # @return [Boolean]
    #
    # source://facets//lib/core/facets/filetest/relative.rb#14
    def relative?(path); end

    # Is the specified directory the root directory?
    #
    # CREDIT: Jeffrey Schwab
    #
    # @return [Boolean]
    #
    # source://facets//lib/core/facets/filetest/root.rb#9
    def root?(dir = T.unsafe(nil)); end

    # Is a path considered reasonably "safe"?
    #
    # Do not mistake this for a perfect solution!
    # Please help improve if you know how!
    #
    # Returns [Boolean]
    #
    # @return [Boolean]
    #
    # source://facets//lib/core/facets/filetest/safe.rb#14
    def safe?(path); end
  end
end

# source://facets//lib/core/facets/filetest/separator_pattern.rb#4
FileTest::SEPARATOR_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://facets//lib/core/facets/numeric/round_to.rb#15
class Float < ::Numeric
  # Rounds to the nearest _n_th degree.
  #
  #   4.555.round_to(1)     #=> 5.0
  #   4.555.round_to(0.1)   #=> 4.6
  #   4.555.round_to(0.01)  #=> 4.56
  #   4.555.round_to(0)     #=> 4.555
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/numeric/round_to.rb#26
  def round_to(n); end
end

# Functor is Ruby's implementation of a Higher-Order-Message. Essentally,
# a Functor can vary its behavior accorrding to the operation applied to it.
#
# Example
#
#   f = Functor.new { |op, x| x.send(op, x) }
#   (f + 1)  #=> 2
#   (f + 2)  #=> 4
#   (f + 3)  #=> 6
#   (f * 1)  #=> 1
#   (f * 2)  #=> 4
#   (f * 3)  #=> 9
#
# source://facets//lib/core/facets/functor.rb#14
class Functor
  # @return [Functor] a new instance of Functor
  #
  # source://facets//lib/core/facets/functor.rb#66
  def initialize(&function); end

  # source://facets//lib/core/facets/functor.rb#40
  def __class__; end

  # source://facets//lib/core/facets/functor.rb#71
  def to_proc; end

  private

  # Any action against the Functor is processesd by the function.
  #
  # source://facets//lib/core/facets/functor.rb#88
  def method_missing(op, *args, &blk); end

  class << self
    # Functors can be somewhat inefficient if a new Functor
    # is frequently recreated for the same use. So this cache
    # can be used to speed things up.
    #
    # The +key+ will always be an array, wich makes it easier
    # to cache Functor for multiple factors.
    #
    # source://facets//lib/core/facets/functor.rb#23
    def cache(*key, &function); end
  end
end

# source://facets//lib/core/facets/functor.rb#32
Functor::EXCEPTIONS = T.let(T.unsafe(nil), Array)

# source://facets//lib/core/facets/array/extract_options.rb#1
class Hash
  include ::Enumerable

  # Hash intersection. Two hashes intersect
  # when their pairs are equal.
  #
  #   ({:a=>1,:b=>2} & {:a=>1,:c=>3})  #=> {:a=>1}
  #
  # A hash can also be intersected with an array
  # to intersect keys only.
  #
  #   ({:a=>1,:b=>2} & [:a,:c])  #=> {:a=>1}
  #
  # The later form is similar to #pairs_at. The differ only
  # in that #pairs_at will return a nil value for a key
  # not in the hash, but #& will not.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/op_and.rb#19
  def &(other); end

  # Like merge operator '+' but merges in reverse order.
  #
  #   h1 = {:a=>1}
  #   h2 = {:a=>2, :b=>3}
  #
  #   (h1 + h2) #=> { :a=>2, :b=>3 }
  #   (h1 * h2)  #=> { :a=>1, :b=>3 }
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/op_mul.rb#13
  def *(other); end

  # Operator for #merge.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/op_add.rb#7
  def +(other); end

  # Operator for removing hash pairs. If another hash is given
  # the pairs are only removed if both key and value are equal.
  # If an array is given then matching keys are removed.
  #
  # CREDIT: Trans
  # CREDIT: Xavier Shay (bug fix)
  #
  # source://facets//lib/core/facets/hash/op_sub.rb#10
  def -(other); end

  # Can be used like update, or passed
  # as two-element [key,value] array.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/op_push.rb#8
  def <<(other); end

  # Modifies the receiving Hash so that the value previously referred to by
  # _oldkey_ is also referenced by _newkey_; _oldkey_ is retained in the Hash.
  # If _oldkey_ does not exist as a key in the Hash, no change is effected.
  #
  # Returns a reference to the Hash.
  #
  #   foo = { :name=>'Gavin', 'wife'=>:Lisa }
  #   foo.alias!('name',:name)     #=> { :name=>'Gavin', 'name'=>'Gavin', 'wife'=>:Lisa }
  #
  #   foo = { :name=>'Gavin', 'wife'=>:Lisa }
  #   foo.alias!('spouse','wife')  #=> { :name=>'Gavin', 'wife'=>:Lisa, 'spouse'=>:Lisa }
  #
  #   foo = { :name=>'Gavin', 'wife'=>:Lisa }
  #   foo.alias!('bar','foo')      #=> { :name=>'Gavin', 'wife'=>:Lisa }
  #
  # Note that if the _oldkey_ is reassigned, the reference will no longer exist,
  # and the _newkey_ will remain as it was.
  #
  # CREDIT: Gavin Sinclair
  #
  # TODO: Rename to #aliaskey or something else.
  #
  # source://facets//lib/core/facets/hash/alias.rb#25
  def alias!(newkey, oldkey); end

  # Turn a hash into a method arguments.
  #
  #   h = { :list => [1,2], :base => "HI" }
  #
  # Without an argument field.
  #
  #   h.argumentize #=> [ { :list => [1,2], :base => "HI" } ]
  #
  # With an argument field.
  #
  #   h.argumentize(:list)   #=> [ 1, 2, { :base => "HI" } ]
  #   h.argumentize(:base)   #=> [ "HI", { :list => [1,2] } ]
  #
  # source://facets//lib/core/facets/hash/argumentize.rb#16
  def argumentize(args_field = T.unsafe(nil)); end

  # Alias for fetch for greater polymorphism with Array.
  #
  # source://facets//lib/core/facets/hash/at.rb#5
  def at(_arg0); end

  # source://facets//lib/core/facets/kernel/blank.rb#66
  def blank?; end

  # Merge the values of this hash with those from another, setting all values
  # to be arrays representing the values from both hashes.
  #
  #   { :a=>1, :b=>2 }.collate(:a=>3, :b=>4, :c=>5)
  #   #=> { :a=>[1,3], :b=>[2,4], :c=>[5] }
  #
  # As of v3.0, this method no longer automatically flattens
  # the array values. To acheive the same effect add a flat map.
  #
  #   h = { :a=>[1,3], :b=>[2,4], :c=>[5] }.collate(:a=>6, :b=>7, :c=>8)
  #   h.each_value{ |v| v.flatten! }
  #   #=> { :a=>[1,3,6], :b=>[2,4,7], :c=>[5,8] }
  #
  # @author Trans         (rewrite)
  # @author Tilo Sloboda  (bug fixes)
  # @author Gavin Kistner (original)
  #
  # source://facets//lib/core/facets/hash/collate.rb#20
  def collate(*others); end

  # The same as #collate, but modifies the receiver in place.
  #
  # source://facets//lib/core/facets/hash/collate.rb#43
  def collate!(other_hash); end

  # Like Enumerable#count, but can count hash values.
  #
  #   {:A=>1, :B=>1}.count(1)  #=> 2
  #
  # source://facets//lib/core/facets/hash/count.rb#7
  def count(*value); end

  # Any array values with one or no elements will be set to the element
  # or nil.
  #
  #   h = { :a=>[1], :b=>[1,2], :c=>3, :d=>[] }
  #   h.dearray_singular_values  #=> { :a=>1, :b=>[1,2], :c=>3, :d=>nil }
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/dearray_values.rb#32
  def dearray_singular_values; end

  # Any array values will be replaced with the first element of the array.
  # Arrays with no elements will be set to nil.
  #
  #   h = { :a=>[1], :b=>[1,2], :c=>3, :d=>[] }
  #   h.dearray_values  #=> { :a=>1, :b=>1, :c=>3, :d=>nil }
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/dearray_values.rb#11
  def dearray_values(index = T.unsafe(nil)); end

  # Same as Hash#merge but recursively merges sub-hashes.
  #
  # source://facets//lib/core/facets/hash/deep_merge.rb#5
  def deep_merge(other); end

  # Same as Hash#merge! but recursively merges sub-hashes.
  #
  # source://facets//lib/core/facets/hash/deep_merge.rb#20
  def deep_merge!(other); end

  # Polymorphic with Array#delete_at.
  #
  # source://facets//lib/core/facets/hash/delete_at.rb#4
  def delete_at(_arg0); end

  # Inverse of #delete_if.
  #
  #   h = { :a => 1, :b => 2, :c => 3 }
  #   r = h.delete_unless{|k,v| v == 1}
  #   r  #=> { :a => 1 }
  #   h  #=> { :a => 1 }
  #
  # CREDIT: Daniel Schierbeck
  #
  # source://facets//lib/core/facets/hash/delete_unless.rb#12
  def delete_unless; end

  # Minor modification to Ruby's Hash#delete method
  # allowing it to take multiple keys.
  #
  #   hsh = { :a => 1, :b => 2 }
  #   hsh.delete_values(1)
  #   hsh  #=> { :b => 2 }
  #
  # Returns a list of keys of the deleted entries.
  #
  # CREDIT: Daniel Schierbeck
  #
  # source://facets//lib/core/facets/hash/delete_values.rb#14
  def delete_values(*values); end

  # Minor modification to Ruby's Hash#delete method
  # allowing it to take multiple keys.
  #
  #    hsh = {:a=>1, :b=>2, :c=>3}
  #
  #    a, b, c = hsh.delete_values_at(:a, :b, :c)
  #
  #    [a, b, c]  #=> [1, 2, 3]
  #    hsh        #=> {}
  #
  # CREDIT: Daniel Schierbeck
  #
  # source://facets//lib/core/facets/hash/delete_values.rb#37
  def delete_values_at(*keys, &yld); end

  # Difference comparison of two hashes.
  #
  #   h1 = {:a=>1,:b=>2}
  #   h2 = {:a=>1,:b=>3}
  #
  #   h1.diff(h2)  #=> {:b=>2}
  #   h2.diff(h1)  #=> {:b=>3}
  #
  # source://facets//lib/core/facets/hash/diff.rb#11
  def diff(hash); end

  # Each with key is like each_pair but reverses the order
  # the parameters to [value,key] instead of [key,value].
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/each_with_key.rb#8
  def each_with_key(&yld); end

  # Returns a new hash less the given keys.
  #
  # source://facets//lib/core/facets/hash/except.rb#4
  def except(*less_keys); end

  # Replaces hash with new hash less the given keys.
  #
  #   h = {:a=>1, :b=>2, :c=>3}
  #   h.except!(:a)  #=> {:b=>2,:c=>3}
  #   h              #=> {:b=>2,:c=>3}
  #
  # Returns the hash.
  #
  # source://facets//lib/core/facets/hash/except.rb#17
  def except!(*rejected); end

  # By default, only instances of Hash itself are extractable.
  # Subclasses of Hash may implement this method and return
  # true to declare themselves as extractable. If a Hash
  # is extractable, Array#extract_options! pops it from
  # the Array when it is the last element of the Array.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/array/extract_options.rb#7
  def extractable_options?; end

  # Similar to Hash#fetch but supports nested lookup and is `nil` safe.
  #
  #     {}.fetch_nested('anything','at','all')  #=> nil
  #
  #     h = {'hello'=>{'world'=>42}}
  #     h.fetch_nested(*['hello','world'])  #=> 42
  #
  # CREDIT: T. Yamada and Sean Mackesey
  #
  # source://facets//lib/core/facets/hash/fetch_nested.rb#12
  def fetch_nested(*keys); end

  # In place version of #graph.
  #
  # NOTE: Hash#graph! is only useful for Hash.
  # It is not generally applicable to Enumerable.
  #
  # source://facets//lib/core/facets/hash/graph.rb#10
  def graph!(&yld); end

  # Returns true or false whether the hash
  # contains the given keys.
  #
  #   h = { :a => 1, :b => 2 }
  #   h.has_keys?( :a )   #=> true
  #   h.has_keys?( :c )   #=> false
  #
  # CREDIT: Trans
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/hash/keys.rb#17
  def has_keys?(*check_keys); end

  # Returns true if the hash contains
  # _only_ the given keys, otherwise false.
  #
  #   h = { :a => 1, :b => 2 }
  #   h.has_only_keys?( :a, :b )   #=> true
  #   h.has_only_keys?( :a )       #=> false
  #
  # CREDIT: Trans
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/hash/keys.rb#33
  def has_only_keys?(*check_keys); end

  # As with #store but only if the key isn't
  # already in the hash.
  #
  # TODO: Would #store? be a better name?
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/insert.rb#10
  def insert(name, value); end

  # Create a "true" inverse hash by storing mutliple values in Arrays.
  #
  #   h = {"a"=>3, "b"=>3, "c"=>3, "d"=>2, "e"=>9, "f"=>3, "g"=>9}
  #
  #   h.invert           #=> {2=>"d", 3=>"f", 9=>"g"}
  #   h.inverse          #=> {2=>"d", 3=>["f", "c", "b", "a"], 9=>["g", "e"]}
  #   h.inverse.inverse  #=> {"a"=>3, "b"=>3, "c"=>3, "d"=>2, "e"=>9, "f"=>3, "g"=>9}
  #
  # Of course the inverse of the inverse should be the same.
  #
  #   (h.inverse.inverse == h)  #=> true
  #
  # CREDIT: Tilo Sloboda
  #
  # source://facets//lib/core/facets/hash/inverse.rb#17
  def inverse; end

  # Like Array#join but specialized to Hash.
  #
  # NOTE: Without Ruby 1.9 this would be difficult to rely on becuase
  # hashes did not have a strict order.
  #
  # CREDIT: Mauricio Fernandez
  #
  # source://facets//lib/core/facets/hash/join.rb#10
  def join(pair_divider = T.unsafe(nil), elem_divider = T.unsafe(nil)); end

  # Returns true or false whether the hash
  # contains the given keys.
  #
  #   h = { :a => 1, :b => 2 }
  #   h.has_keys?( :a )   #=> true
  #   h.has_keys?( :c )   #=> false
  #
  # CREDIT: Trans
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/hash/keys.rb#12
  def keys?(*check_keys); end

  # In place version of #graph.
  #
  # NOTE: Hash#graph! is only useful for Hash.
  # It is not generally applicable to Enumerable.
  # Alias for #graph! as an alliteration for "map hash".
  #
  # source://facets//lib/core/facets/hash/graph.rb#15
  def mash!(&yld); end

  # source://facets//lib/core/facets/object/object_state.rb#61
  def object_state(data = T.unsafe(nil)); end

  # Returns true if the hash contains
  # _only_ the given keys, otherwise false.
  #
  #   h = { :a => 1, :b => 2 }
  #   h.has_only_keys?( :a, :b )   #=> true
  #   h.has_only_keys?( :a )       #=> false
  #
  # CREDIT: Trans
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/hash/keys.rb#28
  def only_keys?(*check_keys); end

  # Apply a block to hash, and recursively apply that block
  # to each sub-hash or +types+.
  #
  #   h = {:a=>1, :b=>{:b1=>1, :b2=>2}}
  #   g = h.recurse{|h| h.inject({}){|h,(k,v)| h[k.to_s] = v; h} }
  #   g  #=> {"a"=>1, "b"=>{"b1"=>1, "b2"=>2}}
  #
  # @yield [h]
  #
  # source://facets//lib/core/facets/hash/recurse.rb#10
  def recurse(*types, &block); end

  # In place form of #recurse.
  #
  # source://facets//lib/core/facets/hash/recurse.rb#25
  def recurse!(&block); end

  # Apply a block to a hash, and recursively apply that block
  # to each sub-hash:
  #
  #     h = {:a=>1, :b=>{:x=>1, :y=>2}}
  #     h.recursively.map{ |k,v| [k.to_s, v] }
  #     #=> [["a", 1], ["b", [["y", 2], ["x", 1]]]]
  #
  # The recursive iteration can be treated separately from the non-recursive
  # iteration by passing a block to the #recursive method:
  #
  #     h = {:a=>1, :b=>{:x=>1, :y=>2}}
  #     h.recursively{ |k,v| [k.to_s, v] }.map{ |k,v| [k.to_s, v.to_s] }
  #     #=> [["a", "1"], ["b", [["y", "2"], ["x", "1"]]]]
  #
  # source://facets//lib/core/facets/hash/recursively.rb#20
  def recursively(*types, &block); end

  # Rekey a hash:
  #
  #   rekey()
  #   rekey(from_key => to_key, ...)
  #   rekey{|from_key| to_key}
  #   rekey{|from_key, value| to_key}
  #
  # If a key map is given, then the first key is changed to the second key.
  #
  #   foo = { :a=>1, :b=>2 }
  #   foo.rekey(:a=>'a')       #=> { 'a'=>1, :b=>2 }
  #   foo.rekey(:b=>:x)        #=> { :a =>1, :x=>2 }
  #   foo.rekey('foo'=>'bar')  #=> { :a =>1, :b=>2 }
  #
  # If a block is given, converts all keys in the Hash accroding to the
  # given block procedure.
  #
  #   foo = { :name=>'Gavin', :wife=>:Lisa }
  #   foo.rekey{ |k| k.to_s }  #=>  { "name"=>"Gavin", "wife"=>:Lisa }
  #   foo                      #=>  { :name =>"Gavin", :wife=>:Lisa }
  #
  # If no key map or block is given, then all keys are converted
  # to Symbols.
  #
  # Raises an ArgumentError if both a +key_map+ and a block are given.
  # If both are needed just call #rekey twice.
  #
  # TODO: If `nil` is returned by block should the key be set to `nil` or the orignal key?
  #
  # CREDIT: Trans, Gavin Kistner
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/hash/rekey.rb#34
  def rekey(key_map = T.unsafe(nil), &block); end

  # Synonym for Hash#rekey, but modifies the receiver in place (and returns it).
  #
  #   foo = { :name=>'Gavin', :wife=>:Lisa }
  #   foo.rekey!{ |k| k.to_s }  #=>  { "name"=>"Gavin", "wife"=>:Lisa }
  #   foo                       #=>  { "name"=>"Gavin", "wife"=>:Lisa }
  #
  # CREDIT: Trans, Gavin Kistner
  #
  # source://facets//lib/core/facets/hash/rekey.rb#77
  def rekey!(key_map = T.unsafe(nil), &block); end

  # Replaces hash with new hash less the given keys.
  # This returns the hash of keys removed.
  #
  #   h = {:a=>1, :b=>2, :c=>3}
  #   h.except!(:a)  #=> {:a=>1}
  #   h              #=> {:b=>2,:c=>3}
  #
  # Returns a Hash of the removed pairs.
  #
  # source://facets//lib/core/facets/hash/except.rb#30
  def remove!(*rejected); end

  # Same as #update_each, but deletes the key element first.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/replace_each.rb#7
  def replace_each; end

  # Allows for reverse merging where its the keys in the
  # calling hash that wins over those in the <tt>other_hash</tt>.
  # This is particularly useful for initializing an incoming
  # option hash with default values:
  #
  #   def setup(options = {})
  #     options.reverse_merge! :size => 25, :velocity => 10
  #   end
  #
  # The default :size and :velocity is only set if the +options+
  # passed in doesn't already have those keys set.
  #
  # source://facets//lib/core/facets/hash/reverse_merge.rb#15
  def reverse_merge(other); end

  # Inplace form of #reverse_merge.
  #
  # source://facets//lib/core/facets/hash/reverse_merge.rb#21
  def reverse_merge!(other); end

  # Inplace form of #reverse_merge.
  # Obvious alias for reverse_merge!
  #
  # source://facets//lib/core/facets/hash/reverse_merge.rb#27
  def reverse_update(other); end

  # Returns a new hash with only the given keys.
  #
  #   h = {:a=>1, :b=>2, :c=>3}
  #   h.slice(:a, :c)  #=> {:a=>1, :c=>3}
  #   h.slice(:a, :d)  #=> {:a=>1}
  #
  # source://facets//lib/core/facets/hash/slice.rb#9
  def slice(*keep_keys); end

  # Replaces hash with a new hash having only the given keys.
  # This return the hash of keys removed.
  #
  #   h = {:a=>1, :b=>2}
  #   h.slice!(:a)  #=> {:b=>2}
  #   h             #=> {:a=>1}
  #
  # Returns a Hash of the removed pairs.
  #
  # source://facets//lib/core/facets/hash/slice.rb#31
  def slice!(*keep_keys); end

  # Return a new hash with all keys converted to strings. Converts all keys
  # in the Hash to Strings, returning a new Hash. With a +select+ block,
  # limits conversion to only a certain selection of keys.
  #
  #   foo = { :name=>'Gavin', :wife=>:Lisa }
  #   foo.stringify_keys    #=>  { "name"=>"Gavin", "wife"=>:Lisa }
  #   foo                   #=>  { :name =>"Gavin", :wife=>:Lisa }
  #
  # This method is considered archaic. Use #rekey instead.
  #
  # source://facets//lib/core/facets/hash/symbolize_keys.rb#61
  def stringify_keys(&select); end

  # Destructively convert all keys to strings. This is the same as
  # Hash#stringify_keys, but modifies the receiver in place and
  # returns it. With a +select+ block, limits conversion to only
  # certain keys.
  #
  #   foo = { :name=>'Gavin', :wife=>:Lisa }
  #   foo.stringify_keys!    #=>  { "name"=>"Gavin", "wife"=>:Lisa }
  #   foo                    #=>  { "name"=>"Gavin", "wife"=>:Lisa }
  #
  # This method is considered archaic. Use #rekey instead.
  #
  # source://facets//lib/core/facets/hash/symbolize_keys.rb#76
  def stringify_keys!(&select); end

  # Take a subset of the hash, based on keys given or a block
  # that evaluates to true for each hash key.
  #
  #   {'a'=>1, 'b'=>2}.subset('a')            #=> {'a'=>1}
  #   {'a'=>1, 'b'=>2}.subset{|k| k == 'a'}   #=> {'a'=>1}
  #
  # CREDIT: Alexey Petrushin
  #
  # source://facets//lib/core/facets/hash/subset.rb#10
  def subset(*keys, &block); end

  # Swap the values of a pair of keys in place.
  #
  #   {:a=>1,:b=>2}.swap!(:a,:b)  #=> {:a=>2,:b=>1}
  #
  # CREDIT: Gavin Sinclair
  #
  # source://facets//lib/core/facets/hash/swap.rb#9
  def swap!(key1, key2); end

  # Return a new hash with all keys converted to symbols. With a +select+ block,
  # limits conversion to only a certain selection of keys.
  #
  #   foo = { :name=>'Gavin', 'wife'=>:Lisa }
  #   foo.symbolize_keys    #=>  { :name=>"Gavin", :wife=>:Lisa }
  #   foo                   #=>  { :name =>"Gavin", "wife"=>:Lisa }
  #
  # If the key does not respond to #to_sym, then #to_s will be used first.
  #
  # For a more versatile method, see #rekey instead.
  #
  # source://facets//lib/core/facets/hash/symbolize_keys.rb#18
  def symbolize_keys(&select); end

  # Destructively convert all keys to symbols. This is the same as
  # Hash#symbolize_keys, but modifies the receiver in place and returns it.
  # With a +select+ block, limits conversion to only selected keys.
  #
  #   foo = { 'name'=>'Gavin', 'wife'=>:Lisa }
  #   foo.symbolize_keys!    #=>  { :name=>"Gavin", :wife=>:Lisa }
  #   foo                    #=>  { :name=>"Gavin", :wife=>:Lisa }
  #
  # If the key does not respond to #to_sym, then #to_s will be used first.
  #
  # For a more versatile method, see #rekey instead.
  #
  # source://facets//lib/core/facets/hash/symbolize_keys.rb#34
  def symbolize_keys!(&select); end

  # Boolean conversion for not empty?
  #
  # source://facets//lib/core/facets/boolean.rb#117
  def to_b; end

  # Convert a hash into a module.
  #
  #   {:a=>1, :b=>2}.to_mod
  #
  # Can take a block accepting key, value pairs which will be
  # evaluated in the context of the module.
  #
  #   h = {:a=>1, :b=>2}
  #   m = h.to_mod{ |k,v| module_function k }
  #   m.a #=> 1
  #   m.b #=> 2
  #
  # CREDIT: Jay Fields
  # --
  # TODO: Consider #to_obj?
  # ++
  #
  # source://facets//lib/core/facets/hash/to_mod.rb#20
  def to_mod(&block); end

  # Constructs a Proc object from a hash such that the parameter
  # of the Proc is assigned the hash keys as attributes.
  #
  #   c = Class.new do
  #     attr_accessor :a
  #   end
  #
  #   h = {:a => 1}
  #   o = c.new
  #   h.to_proc.call(o)
  #   o.a  #=> 1
  #
  # If +response+ is set to +true+, then assignment will only occur
  # if receiver responds_to? the writer method.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/to_proc.rb#20
  def to_proc(response = T.unsafe(nil)); end

  # A method to convert a Hash into a Struct.
  #
  #   h = {:name=>"Dan","age"=>33,"rank"=>"SrA","grade"=>"E4"}
  #   s = h.to_struct("Foo")
  #
  # TODO: Is this robust enough considerd hashes aren't ordered?
  #
  # CREDIT: Daniel Berger
  #
  # source://facets//lib/core/facets/hash/to_struct.rb#12
  def to_struct(struct_name); end

  # Returns a new hash created by traversing the hash and its subhashes,
  # executing the given block on the key and value. The block should
  # return a 2-element array of the form +[key, value]+.
  #
  #   h = {"A"=>"A", "B"=>"B", "C"=>{"X"=>"X"}}
  #
  #   g = h.traverse{ |k,v| [k.downcase, v] }
  #
  #   g  #=> {"a"=>"A", "b"=>"B", "c"=>{"x"=>"X"}}
  #
  # NOTE: Hash#traverse is the same as `recursive.graph` and
  # might be deprecated in the future (if it ever works!)
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/traverse.rb#18
  def traverse(&block); end

  # In place version of traverse, which traverses the hash and its
  # subhashes, executing the given block on the key and value.
  #
  #   h = { "A"=>"A", "B"=>"B" }
  #
  #   h.traverse!{ |k,v| [k.downcase, v] }
  #
  #   h  #=> { "a"=>"A", "b"=>"B" }
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/traverse.rb#42
  def traverse!(&block); end

  # Iterates through each pair and updates the hash
  # in place. This is formally equivalent to #mash!
  # But does not use #mash to accomplish the task.
  # Hence #update_each is probably a touch faster.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/update_each.rb#10
  def update_each; end

  # Iterate over hash updating just the keys.
  #
  #   h = {:a=>1, :b=>2}
  #   h.update_keys{ |k| "#{k}!" }
  #   h  #=> { "a!"=>1, "b!"=>2 }
  #
  # @author Trans
  # @author Evgeniy Dolzhenko (bug fix)
  #
  # source://facets//lib/core/facets/hash/update_keys.rb#12
  def update_keys; end

  # Iterate over hash updating just the values.
  #
  #   h = {:a=>1, :b=>2}
  #   h.update_values{ |v| v + 1 }
  #   h  #=> { :a=>2, :b=>3 }
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/update_values.rb#11
  def update_values; end

  # Weave is a very unique hash operator. It is designed
  # to merge to complex hashes in according to sensible,
  # regular pattern. The effect is akin to inheritance.
  #
  # Two hashes are weaved together to produce a new hash.
  # The two hashes need to be compatible according to the
  # following rules for each node: ...
  #
  #   hash,   hash    => hash (recursive +)
  #   hash,   array   => error
  #   hash,   value   => error
  #   array,  hash    => error
  #   array,  array   => array + array
  #   array,  value   => array << value
  #   value,  hash    => error
  #   value,  array   => array.unshift(valueB)
  #   value1, value2  => value2
  #
  # Here is a basic example:
  #
  #   h1 = { :a => 1, :b => [ 1 ], :c => { :x => 1 } }
  #   h2 = { :a => 2, :b => [ 2 ], :c => { :x => 2 } }
  #
  #   h1.weave(h2)
  #   #=> {:b=>[1, 2], :c=>{:x=>2}, :a=>2}
  #
  # Weave follows the most expected pattern of unifying two complex
  # hashes. It is especially useful for implementing overridable
  # configuration schemes.
  #
  # CREDIT: Thomas Sawyer
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/hash/weave.rb#35
  def weave(h); end

  # Operator for #reverse_merge.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/hash/op_or.rb#7
  def |(other); end

  class << self
    # Hash which auto initializes it's children.
    #
    #   h = Hash.autonew
    #   h['s1']['p1'] = 4
    #   h['s1']['p2'] = 5
    #   h['s1']['p3'] = 2
    #   h['s1']['p4'] = 3
    #
    #   h #=> {"s1"=>{"p1"=>4, "p4"=>3, "p3"=>2, "p2"=>5}}
    #
    #   h['s1'].keys.sort
    #   #=> ["p1", "p2", "p3", "p4"]
    #
    # CREDIT: Trans, Jan Molic
    #
    # source://facets//lib/core/facets/hash/autonew.rb#18
    def autonew(*args); end

    # Instantiate a new hash with a default
    # value determined by the block.
    #
    # Hash.new_with{ [] }
    #
    # CREDIT: Pit Capitan
    #
    # source://facets//lib/core/facets/hash/new_with.rb#10
    def new_with; end

    # Creates a new hash from two separate arrays, a +keys+ array and
    # a +values+ array.
    #
    #   Hash.zip(["a","b","c"], [1,2,3])
    #   # => { "a"=>1, "b"=>2, "c"=>3 }
    #
    # CREDIT: Trans, Ara T. Howard
    #
    # source://facets//lib/core/facets/hash/zip.rb#11
    def zip(keys, values); end
  end
end

# source://facets//lib/core/facets/hash/recursively.rb#24
class Hash::Recursor < ::Enumerable::Recursor
  # source://facets//lib/core/facets/hash/recursively.rb#25
  def method_missing(op, &yld); end
end

# Indexable is a mixin that provides index based methods,
# working solely with four methods: #index, #slice, #splice
# and #size.
#
# These methods work in harmony. Where #index returns a
# position of a given element, #slice returns elements
# for given positions. #splice is like #slice but replaces
# the given position with new values. This method is not
# part of ruby core, but it generally just an alias for #[]=,
# just as #slice is an alias of #[]. #size of course simply
# returns the total length of the indexable object.
#
# NOTE: To test the following methods Indexable needs to be
# included into Array and array must have #splice defined.
#
#   require 'facets/array/splice'
#
#   class ::Array
#     include Indexable
#   end
#
# CREDIT: Thomas Sawyer
#
# source://facets//lib/core/facets/indexable.rb#24
module Indexable
  # Returns an array of the first element up to,
  # but not including, the last element.
  #
  #   [1,2,3].body  #=> [1,2]
  #
  # --
  # Better name for this? (bulk, perhaps?)
  # ++
  #
  # source://facets//lib/core/facets/indexable.rb#61
  def body; end

  # A shorting of "ends at", returns the
  # last index of the indexable object.
  # Returns nil if there are no elements.
  #
  #   [1,2,3,4,5].ends  #=> 4
  #
  # This nearly equivalent to +size - 1+.
  #
  # source://facets//lib/core/facets/indexable.rb#210
  def ends; end

  # Returns first _n_ elements.
  #
  #   %w{H e l l o}.first(3)  #=> %w{H e l}
  #
  # source://facets//lib/core/facets/indexable.rb#148
  def first(n = T.unsafe(nil)); end

  # Remove and return the first element.
  #
  #   a = [1,2,3]
  #   a.first!      #=> 1
  #   a             #=> [2,3]
  #
  # source://facets//lib/core/facets/indexable.rb#188
  def first!; end

  # Change the first element.
  #
  #   a = ["a","y","z"]
  #   a.first = "x"
  #   a           #=> ["x","y","z"]
  #
  # source://facets//lib/core/facets/indexable.rb#168
  def first=(x); end

  # Like #last, returning the last element
  # in an array.
  #
  #   [1,2,3].foot  #=> [3]
  #
  # source://facets//lib/core/facets/indexable.rb#48
  def foot; end

  # Returns last _n_ elements.
  #
  #   %w{W o r l d}.from(3)  #=> %w{l d}
  #
  # source://facets//lib/core/facets/indexable.rb#130
  def from(i); end

  # Like #first but returns the first element
  # in a new array.
  #
  #   [1,2,3].head  #=> [1]
  #
  # source://facets//lib/core/facets/indexable.rb#31
  def head; end

  # Returns the index of the first element equal to the
  # given object or satisfying the block condition.
  #
  #   [1,2,3,4].index{ |e| e == 3 }  #=> 2
  #   [1,2,3,4].index{ |e| e > 3 }   #=> 3
  #
  # source://facets//lib/core/facets/indexable.rb#235
  def index(obj = T.unsafe(nil), &block); end

  # Returns the index of the first element equal to the
  # given object or satisfying the block condition.
  #
  #   [1,2,3,4].index{ |e| e == 3 }  #=> 2
  #   [1,2,3,4].index{ |e| e > 3 }   #=> 3
  # to be deprecated
  #
  # source://facets//lib/core/facets/indexable.rb#249
  def index_of(obj = T.unsafe(nil), &block); end

  # Returns last _n_ elements.
  #
  #   %w{H e l l o}.last(3)  #=> %w{l l o}
  #
  # source://facets//lib/core/facets/indexable.rb#156
  def last(n = T.unsafe(nil)); end

  # Remove and return the last element.
  #
  #   a = [1,2,3]
  #   a.last!       #=> 3
  #   a             #=> [1,2]
  #
  # source://facets//lib/core/facets/indexable.rb#198
  def last!; end

  # Change the last element.
  #
  #   a = [1,2,5]
  #   a.last = 3
  #   a           #=> [1,2,3]
  #
  # source://facets//lib/core/facets/indexable.rb#178
  def last=(x); end

  # Returns the middle element of an array, or the element offset
  # from middle if the parameter is given. Even-sized arrays,
  # not having an exact middle, return the middle-right element.
  #
  #   [1,2,3,4,5].mid        #=> 3
  #   [1,2,3,4,5,6].mid      #=> 4
  #   [1,2,3,4,5,6].mid(-1)  #=> 3
  #   [1,2,3,4,5,6].mid(-2)  #=> 2
  #   [1,2,3,4,5,6].mid(1)   #=> 5
  #
  # In other words, If there are an even number of elements the
  # higher-indexed of the two center elements is indexed as
  # origin (0).
  #
  # source://facets//lib/core/facets/indexable.rb#79
  def mid(offset = T.unsafe(nil)); end

  # Returns an Array of the middle element(s) of an array.
  # Even-sized arrays, not having an exact middle, return
  # a two-element array of the two middle elements.
  #
  #   [1,2,3,4,5].middle        #=> [3]
  #   [1,2,3,4,5,6].middle      #=> [3,4]
  #
  # A +birth+ can be give to widen the middle on either side.
  #
  #   [1,2,3,4,5].middle(1)   #=> [2,3,4]
  #   [1,2,3,4,5,6].middle(1)   #=> [2,3,4,5]
  #
  # In contrast to #mid which utilizes an offset.
  #
  # source://facets//lib/core/facets/indexable.rb#97
  def middle(birth = T.unsafe(nil)); end

  # Returns the positive ordinal index given
  # a cardinal position, 1 to n or -n to -1.
  #
  #   [1,2,3,4,5].pos(1)   #=> 0
  #   [1,2,3,4,5].pos(-1)  #=> 4
  #
  # source://facets//lib/core/facets/indexable.rb#221
  def pos(i); end

  # Returns the index range between two elements. If no elements are
  # given, returns the range from first to last.
  #
  #   ['a','b','c','d'].range            #=> (0..3)
  #   ['a','b','c','d'].range('b','d')   #=> (1..3)
  #
  # source://facets//lib/core/facets/indexable.rb#259
  def range(a = T.unsafe(nil), z = T.unsafe(nil)); end

  # Returns an array from second element to last element.
  #
  #   [1,2,3].tail  #=> [2,3]
  #
  # source://facets//lib/core/facets/indexable.rb#39
  def tail; end

  # Fetch values from a start index through an end index.
  #
  #   [1,2,3,4,5].thru(0,2)  #=> [1,2,3]
  #   [1,2,3,4,5].thru(2,4)  #=> [3,4,5]
  #
  #   [1,2,3,4,5].thru(2)  #=> [1,2,3]
  #   [1,2,3,4,5].thru(4)  #=> [1,2,3,4,5]
  #
  # source://facets//lib/core/facets/indexable.rb#114
  def thru(from, to = T.unsafe(nil)); end
end

# source://facets//lib/core/facets/integer/bitmask.rb#1
class Integer < ::Numeric
  # Set a bit.
  #
  #   0.bit(4)  #=> 16
  #
  # Using a negative figure will clear a bit.
  #
  #   10.bit(-4)      #=> 2
  #
  # This is more easily seen using binary.
  #
  #   0b0100.bit(-3)  #=> 0
  #
  # CREDIT: Thomas Sawyer, George Moschovitis
  #
  # source://facets//lib/core/facets/integer/bitmask.rb#17
  def bit(bit); end

  # Is a bit set?
  #
  #   8.bit?(3)  #=> true
  #   8.bit?(2)  #=> false
  #
  # CREDIT: Thomas Sawyer, George Moschovitis
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/integer/bitmask.rb#43
  def bit?(bit); end

  # Clear bit.
  #
  # CREDIT: George Moschovitis
  #
  # source://facets//lib/core/facets/integer/bitmask.rb#31
  def bit_clear(bit); end

  # Apply a bitmask.
  #
  #   1.bitmask(6) #=> 7
  #
  # Using a inverted bitmask clears bits.
  #
  #   7.bitmask(~2) #=> 5
  #   5.bitmask(~2) #=> 5
  #
  # CREDIT: George Moschovitis
  #
  # source://facets//lib/core/facets/integer/bitmask.rb#59
  def bitmask(mask); end

  # Is bitmask set?
  #
  #   7.bitmask?(7) #=> true
  #   7.bitmask?(5) #=> true
  #   8.bitmask?(3) #=> false
  #
  # CREDIT: George Moschovitis
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/integer/bitmask.rb#75
  def bitmask?(mask); end

  # Calculate the factorial of an integer.
  #
  #   2.factorial  #=> 2
  #   3.factorial  #=> 6
  #   4.factorial  #=> 24
  #
  # CREDIT: Malte Milatz
  #
  # source://facets//lib/core/facets/integer/factorial.rb#18
  def fac; end

  # Calculate the factorial of an integer.
  #
  #   2.factorial  #=> 2
  #   3.factorial  #=> 6
  #   4.factorial  #=> 24
  #
  # CREDIT: Malte Milatz
  #
  # source://facets//lib/core/facets/integer/factorial.rb#11
  def factorial; end

  # Is +self+ a multiple of a given number?
  #
  #   7.multiple?(2)  #=> false
  #   8.multiple?(2)  #=> true
  #
  # CREDIT: Trans
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/integer/multiple.rb#10
  def multiple?(number); end

  # Like #times but returns a collection of the yield results.
  #
  #   a = 3.of { |i| "#{i+1}" }
  #   a #=> [ "1", "2", "3" ]
  #
  # source://facets//lib/core/facets/integer/of.rb#9
  def of(&block); end

  # source://facets//lib/core/facets/integer/ordinal.rb#3
  def ordinal; end

  # Rails term.
  #
  # source://facets//lib/core/facets/integer/ordinal.rb#21
  def ordinalize; end

  # Like #times but returns a collection of the yield results.
  #
  #   a = 3.of { |i| "#{i+1}" }
  #   a #=> [ "1", "2", "3" ]
  # Time warn aliases for #of.
  #
  # source://facets//lib/core/facets/integer/of.rb#14
  def times_collect(&block); end

  # Like #times but returns a collection of the yield results.
  #
  #   a = 3.of { |i| "#{i+1}" }
  #   a #=> [ "1", "2", "3" ]
  #
  # source://facets//lib/core/facets/integer/of.rb#15
  def times_map(&block); end
end

# source://facets//lib/core/facets/kernel/callstack.rb#1
module Kernel
  # Create a single bit bitmask.
  #
  #   Bit(0)  #=> 1
  #   Bit(1)  #=> 2
  #   Bit(2)  #=> 4
  #
  # This is equivalent to n-shift: "1 << n".
  #
  # CREDIT: Thomas Sawyer, George Moschovitis
  #
  # source://facets//lib/core/facets/integer/bitmask.rb#94
  def Bit(n); end

  # Similar to __FILE__, __DIR__ provides the directory
  # path to the current executing script.
  #
  # DEPRECATED: As of Ruby 2.0, which will have #__dir__ method.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/__dir__.rb#10
  def __DIR__(*paths); end

  # Defines core method __class__ as an alias of class.
  # This allows you to use #class as your own method, without
  # loosing the ability to determine the object's class.
  #
  # source://facets//lib/core/facets/kernel/__class__.rb#7
  def __class__; end

  # Shadow method for instance_variable_get.
  #
  # source://facets//lib/core/facets/kernel/__get__.rb#4
  def __get__(ivar); end

  # Shadow method for instance_variable_set.
  #
  # source://facets//lib/core/facets/kernel/__get__.rb#10
  def __set__(ivar, val); end

  # Returns a As-functor that allows one to call any
  # ancestor's method directly of the given object.
  #
  #   class AsExample1
  #     def x ; 1 ; end
  #   end
  #
  #   class AsExample2 < AsExample1
  #     def x ; 2 ; end
  #   end
  #
  #   class AsExample3 < AsExample2
  #     def x ; as(AsExample1).x ; end
  #   end
  #
  #   AsExample1.new.x  #=> 1
  #
  # source://facets//lib/core/facets/kernel/as.rb#22
  def as(ancestor, &blk); end

  # Assign via writer using arguments, hash or associative array.
  #
  # Using name-value arguments:
  #
  #   object = Object.new
  #
  #   object.assign(:a, 1)
  #   object.assign(:b, 2)
  #
  # Using a hash:
  #
  #   object.assign(:a => 1, :b => 2)
  #
  # Use an associative array:
  #
  #   object.assign([[:a, 1], [:b, 2]])
  #
  # These are all equivalent to:
  #
  #   object.a = 1 if object.respond_to?(:a=)
  #   object.b = 2 if object.respond_to?(:b=)
  #
  # Using an associative array instead of a hash guarantees order of assignment
  # for older versions of Ruby (< 1.8.7).
  #
  # TODO: Should this be called #set instead? Consider Module#set in this
  # question, and also #set_from as the alias of #assign_from.
  #
  # source://facets//lib/core/facets/kernel/assign.rb#33
  def assign(data = T.unsafe(nil), value = T.unsafe(nil)); end

  # Set attribute writers using like readers from another object.
  #
  #   class AssignExample
  #     attr_accessor :a, :b
  #     def initialize(a, b)
  #        @a, @b = a, b
  #     end
  #   end
  #
  #   obj1 = AssignExample.new(1,2)
  #   obj2 = AssignExample.new(3,4)
  #
  #   obj2.assign_from(obj1, :a, :b)
  #
  #   obj2.a  #=> 1
  #   obj2.b  #=> 2
  #
  # TODO: Should this be called #set_from ?
  #
  # source://facets//lib/core/facets/kernel/assign.rb#65
  def assign_from(obj, *fields); end

  # Create singleton attr_accessors.
  #
  #   obj = Object.new
  #
  #   obj.attr_singleton_accessor :x, :y
  #
  #   obj.x = 3
  #   obj.y = 4
  #   obj.x      #=> 3
  #   obj.y      #=> 4
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/attr_singleton.rb#51
  def attr_singleton_accessor(*args); end

  # Creates singleton attr_readers.
  #
  #   obj = Object.new
  #
  #   obj.attr_singleton_reader :x, :y
  #
  #   attr_singleton_reader :x, :y
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/attr_singleton.rb#13
  def attr_singleton_reader(*args); end

  # Create singleton attr_writers.
  #
  #   obj = Object.new
  #
  #   obj.attr_singleton_writer :x, :y
  #
  #   obj.x = 3
  #   obj.y = 4
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/attr_singleton.rb#31
  def attr_singleton_writer(*args); end

  # An object is blank if it's nil, empty, or a whitespace string.
  # For example, "", "   ", nil, [], and {} are blank.
  #
  # This simplifies...
  #
  #   if !address.nil? && !address.empty?
  #
  # to...
  #
  #   if !address.blank?
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/blank.rb#13
  def blank?; end

  # Returns true is an object is class TrueClass
  # or FalseClass, otherwise false.
  #
  #   true.bool?   #=> true
  #   false.bool?  #=> true
  #   nil.bool?    #=> false
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/boolean.rb#33
  def bool?; end

  # Parse a caller string and break it into its components,
  # returning an array composed of:
  #
  # * file (String)
  # * lineno (Integer)
  # * method (Symbol)
  #
  # For example, from irb
  #
  #     callstack(1)
  #
  # _produces_ ...
  #
  #     [["(irb)", 2, :irb_binding],
  #       ["/usr/lib/ruby/1.8/irb/workspace.rb", 52, :irb_binding],
  #       ["/usr/lib/ruby/1.8/irb/workspace.rb", 52, nil]]
  #
  # Note: If the user decides to redefine caller() to output data
  # in a different format, _prior_ to requiring this, then the
  # results will be indeterminate.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/callstack.rb#42
  def call_stack(level = T.unsafe(nil)); end

  # Parse a caller string and break it into its components,
  # returning an array composed of:
  #
  # * file (String)
  # * lineno (Integer)
  # * method (Symbol)
  #
  # For example, from irb
  #
  #     callstack(1)
  #
  # _produces_ ...
  #
  #     [["(irb)", 2, :irb_binding],
  #       ["/usr/lib/ruby/1.8/irb/workspace.rb", 52, :irb_binding],
  #       ["/usr/lib/ruby/1.8/irb/workspace.rb", 52, nil]]
  #
  # Note: If the user decides to redefine caller() to output data
  # in a different format, _prior_ to requiring this, then the
  # results will be indeterminate.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/callstack.rb#29
  def callstack(level = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/case.rb#3
  def case?(*matchers); end

  # Repeat loop until it yeilds false or nil.
  #
  #   a = [3, 2, 1]
  #   b = []
  #
  #   complete do
  #     x = a.pop
  #     b << x
  #     x
  #   end
  #
  #   b  #=> [1, 2, 3, nil]
  #
  # Be "aware" when using this method, it easy to accidently
  # induce infinite loops.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/complete.rb#21
  def complete; end

  # This is similar to +Module#const_get+ but is accessible at all levels,
  # and, unlike +const_get+, can handle module hierarchy.
  #
  #   constant("Fixnum")                  # => Fixnum
  #   constant(:Fixnum)                   # => Fixnum
  #
  #   constant("Process::Sys")            # => Process::Sys
  #   constant("Regexp::MULTILINE")       # => 4
  #
  # TODO: As of Ruby 2.0, #constant can be deprecated, or aliased to #get_const.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/constant.rb#16
  def constant(const); end

  # Like #p but gives file and line number...
  #
  #   d("hi")
  #
  # produces ...
  #
  #   "hi" (/home/dave/projects/foo.rb, 38)
  #
  # source://facets//lib/core/facets/kernel/d.rb#11
  def d(*x); end

  # Deep clone an object by deep cloning every instance
  # variable as well.
  #
  # Returns [Object]
  #
  # source://facets//lib/core/facets/kernel/deep_clone.rb#8
  def deep_clone(cache = T.unsafe(nil)); end

  # Anything that can be marshaled can be copied in totality.
  #
  #   "ABC".deep_copy  #=> "ABC"
  #
  # NOTE: Not sure why we wouldn't just call this #copy, but
  # the term +deep_copy+ seems to be the common practive.
  #
  # source://facets//lib/core/facets/kernel/deep_copy.rb#9
  def deep_copy; end

  # Forces the result of a promise to be computed (if necessary) and returns
  # the bare result object.  Once evaluated, the result of the promise will
  # be cached.  Nested promises will be evaluated together, until the first
  # non-promise result.
  #
  # If called on a value that is not a promise, it will simply return it.
  #
  # source://facets//lib/core/facets/lazy.rb#218
  def demand(promise); end

  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/disable_warnings.rb#6
  def disable_warnings; end

  # source://facets//lib/core/facets/kernel/meta.rb#30
  def eigen; end

  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/disable_warnings.rb#19
  def enable_warnings; end

  # Broad equality. Checks to see if the object +x+ is in any
  # way equal to the reciever, starting with the identity
  # #equal?, then #eql?, then #==, and ending with #===.
  #
  #   1.like?(1.0)               #=> true
  #   "string".like?("string")   #=> true
  #   String.like?("string")     #=> true
  #
  # @deprecated
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/like.rb#16
  def equate?(x); end

  # Yield self -or- return self.
  #
  #   "a".ergo.upcase #=> "A"
  #   nil.ergo.foobar #=> nil
  #
  #   "a".ergo{ |o| o.upcase } #=> "A"
  #   nil.ergo{ |o| o.foobar } #=> nil
  #
  # This is like #tap, but #tap yields self and returns self,
  # where as #ergo yields self but returns the result.
  #
  # CREDIT: Daniel DeLorme
  #
  # source://facets//lib/core/facets/kernel/ergo.rb#18
  def ergo(&b); end

  # source://facets//lib/core/facets/kernel/extend.rb#22
  def extend(*mod, &blk); end

  # Don't say it!
  #
  # source://facets//lib/core/facets/kernel/extension.rb#7
  def extension; end

  # Returns true is an object is class FalseClass,
  # otherwise false.
  #
  #   true.false?   #=> false
  #   false.false?  #=> true
  #   nil.false?    #=> false
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/true.rb#21
  def false?; end

  # Schedules a computation to be run asynchronously in a background thread
  # and returns a promise for its result.  An attempt to demand the result of
  # the promise will block until the computation finishes.
  #
  # As with Kernel.promise, this passes the block a promise for its own result.
  # Use wisely.
  #
  # source://facets//lib/core/facets/lazy.rb#233
  def future(&computation); end

  # source://facets//lib/core/facets/kernel/identical.rb#2
  def identical?(_arg0); end

  # Is self included in other?
  #
  #   5.in?(0..10)       #=> true
  #   5.in?([0,1,2,3])   #=> false
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/in.rb#8
  def in?(other); end

  # Set instance variables using a hash.
  #
  #     instance_assign('@a'=>1, '@b'=>2)
  #     @a   #=> 1
  #     @b   #=> 2
  #
  # NOTE: Conceptually a better alternative to this method is `instance.update`
  #       from the `instance` gem. However, practically this method is probably
  #       the better choice until such time that Ruby supports anonymous delegators.
  #
  # source://facets//lib/core/facets/kernel/instance_assign.rb#13
  def instance_assign(hash); end

  # Easy access to an object qua class, otherwise known
  # as the object's metaclass or singleton class. This
  # implemnetation alwasy returns the class, even if a
  # block is provided to eval against it...
  #
  #     It is what it is.
  #     But I think I like this one best.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/instance_class.rb#20
  def instance_class(&block); end

  # Like `instance_assign`, but only assigns an instance variable if
  # it does not already exist.
  #
  #     @a = 9
  #     instance_extract('@a'=>1, '@b'=>2)
  #     @a   #=> 9
  #     @b   #=> 2
  #
  # CREDIT: T. Yamada
  #
  # source://facets//lib/core/facets/kernel/instance_extract.rb#13
  def instance_extract(hash); end

  # Replace state of object with the state of another object of the
  # same class (or superclass).
  #
  #     class ReplaceExample
  #       attr_reader :a, :b
  #       def initialize(a,b)
  #         @a, @b = a, b
  #       end
  #     end
  #
  #     obj1 = ReplaceExample.new(1,2)
  #     obj1.a  #=> 1
  #     obj1.b  #=> 2
  #
  #     obj2 = ReplaceExample.new(3,4)
  #     obj2.a  #=> 3
  #     obj2.b  #=> 4
  #
  #     obj1.instance_replace(obj2)
  #     obj1.a  #=> 3
  #     obj1.b  #=> 4
  #
  # This is very similar to `instance.assign`, but it is limited
  # by the class of object, in the same manner as Array#replace.
  #
  # NOTE: Conceptually a better alternative is `instance.replace` provided
  #       by the `instance` gem. However, practically this method is probably
  #       the better choice until such time that Ruby support anonymous delegators.
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/kernel/instance_replace.rb#32
  def instance_replace(source); end

  # Private send.
  #
  # source://facets//lib/core/facets/kernel/instance_send.rb#4
  def instance_send(*_arg0); end

  # Broad equality. Checks to see if the object +x+ is in any
  # way equal to the reciever, starting with the identity
  # #equal?, then #eql?, then #==, and ending with #===.
  #
  #   1.like?(1.0)               #=> true
  #   "string".like?("string")   #=> true
  #   String.like?("string")     #=> true
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/like.rb#11
  def like?(x); end

  # Same as #require_all, but for #load.
  #
  # source://facets//lib/core/facets/kernel/require_all.rb#28
  def load_all(pattern, safe = T.unsafe(nil)); end

  # Load file from same dir as calling script.
  #
  #   load_relative 'myscript'
  #
  # CREDIT: Paul Brannan, Pragmatic Programmers
  #
  # source://facets//lib/core/facets/kernel/load_relative.rb#11
  def load_relative(relative_feature, safe = T.unsafe(nil)); end

  # Random generator that returns true or false.
  # Can also take a block that has a 50/50 chance
  # to being executed...
  #
  #   maybe  #=> true
  #   maybe  #=> false
  #
  # source://facets//lib/core/facets/kernel/maybe.rb#10
  def maybe(chance = T.unsafe(nil), &block); end

  # Call methods on the eigenclass (i.e. the singleton_class).
  #
  #     name = "Tom"
  #     name.eigen.define_method(:turkey){ self + " Turkey" }
  #     name.turkey #=> "Tom Turkey"
  #
  # One of the nice things you can do with #eigen is define class attributes
  # without having to open a `class << self` block.
  #
  #     c = Class.new do
  #       meta.attr_accessor :a
  #     end
  #     c.a = 1
  #     c.a #=> 1
  #
  # source://facets//lib/core/facets/kernel/meta.rb#22
  def meta; end

  # Alias a method defined in the metaclass (ie. singleton class).
  #
  #   class MetaExample
  #     def self.y?; "y?" ; end
  #   end
  #
  #   MetaExample.meta_alias "ynot?", "y?"
  #
  #   MetaExample.ynot?  #=> "y?"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/meta_alias.rb#17
  def meta_alias(*args); end

  # Easy access to an object's "special" class, otherwise known as it's
  # singleton class, eigenclass, adhoc class or object-qua-class.
  #
  # source://facets//lib/core/facets/kernel/meta_class.rb#6
  def meta_class(&block); end

  # Add method to a meta-class --i.e. a singleton method.
  #
  #   class X; end
  #   X.meta_def(:x){"x"}
  #   X.x  #=> "x"
  #
  # CREDIT: WhyTheLuckyStiff
  #
  # source://facets//lib/core/facets/kernel/meta_def.rb#13
  def meta_def(name, &block); end

  # Evaluate code in a metaclass. This is equivalent to:
  #
  #   meta_class.instance_eval(...)
  #
  # CREDIT: WhyTheLuckyStiff
  #
  # source://facets//lib/core/facets/kernel/meta_eval.rb#11
  def meta_eval(str = T.unsafe(nil), *file_and_line, &blk); end

  # Easy access to an object's "special" class, otherwise known as it's
  # singleton class, eigenclass, adhoc class or object-qua-class.
  # The non-underscored form of #meta_class if faily common.
  #
  # source://facets//lib/core/facets/kernel/meta_class.rb#15
  def metaclass(&block); end

  # Easy access to method as object, and they retain state.
  #
  #   def hello
  #     puts "Hello World!"
  #   end
  #
  #   m1 = method!(:hello)
  #
  #   def m1.annotate
  #     "simple example"
  #   end
  #
  #   m2 = method!(:hello)
  #   m2.annotate  #=> "simple example"
  #
  # source://facets//lib/core/facets/kernel/method.rb#20
  def method!(s); end

  # Ask a question expecting a no answer.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/yes.rb#16
  def no?(question); end

  # Inversion functor.
  #
  #   true.not.nil?  #=> true
  #
  # source://facets//lib/core/facets/kernel/not.rb#17
  def not; end

  # Same as using NOT operator '!'.
  #
  #  true.nil?.not? == !true.nil?
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/not.rb#9
  def not?; end

  # The opposite of #nil?.
  #
  #   "hello".not_nil?     # -> true
  #   nil.not_nil?         # -> false
  #
  # CREDIT: Gavin Sinclair
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/not_nil.rb#10
  def not_nil?; end

  # Defines object_classas an alias of class.
  # This is an alternative to __class__, akin to
  # #object_id.
  #
  # source://facets//lib/core/facets/kernel/object_class.rb#7
  def object_class; end

  # Returns the object id as a string in hexideciaml,
  # which is how Ruby reports them with inspect...
  #
  #   "ABC".object_hexid  #=> "0x402d359c"
  #
  # source://facets//lib/core/facets/kernel/object_hexid.rb#24
  def object_hexid; end

  # source://facets//lib/core/facets/kernel/object_send.rb#18
  def object_send(*_arg0); end

  # Alternate to standard #p method that outputs
  # Kernel#inspect to stdout, but also passes through
  # the orginal argument(s) ...
  #
  #   x = 1
  #   r = 4 + p(1)
  #   p r
  #
  # produces ...
  #
  #   1
  #   5
  #
  # TODO: DEPRECATE as of 1.9, _if_ it will do this.
  #
  # source://facets//lib/core/facets/kernel/p.rb#18
  def p(*x); end

  # Returns object if it's #present? otherwise returns nil.
  # object.presence is equivalent to object.present? ? object : nil.
  #
  # This is handy for any representation of objects where blank is the same
  # as not present at all.  For example, this simplifies a common check for
  # HTTP POST/query parameters...
  #
  #   state   = params[:state]   if params[:state].present?
  #   country = params[:country] if params[:country].present?
  #   region  = state || country || 'US'
  #
  # becomes...
  #
  #   region = params[:state].presence || params[:country].presence || 'US'
  #
  # source://facets//lib/core/facets/kernel/blank.rb#38
  def presence; end

  # An object is present if it's not blank.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/blank.rb#19
  def present?; end

  # The promise() function is used together with demand() to implement
  # lazy evaluation.  It returns a promise to evaluate the provided
  # block at a future time.  Evaluation can be demanded and the block's
  # result obtained via the demand() function.
  #
  # Implicit evaluation is also supported: the first message sent to it will
  # demand evaluation, after which that message and any subsequent messages
  # will be forwarded to the result object.
  #
  # As an aid to circular programming, the block will be passed a promise
  # for its own result when it is evaluated.  Be careful not to force
  # that promise during the computation, lest the computation diverge.
  #
  # source://facets//lib/core/facets/lazy.rb#207
  def promise(&computation); end

  # Easy access to an object qua class, otherwise known as the object's
  # singleton class. #qua_class can also take a block.
  #
  #   string = "Hello World"
  #
  #   string.qua_class do
  #     def important
  #        self + "!"
  #     end
  #   end
  #
  #   string.important  #=> "Hello World!"
  #
  # Yes, another one.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/kernel/qua_class.rb#20
  def qua_class(&block); end

  # Easy access to an object qua class, otherwise known as the object's
  # singleton class. #qua_class can also take a block.
  #
  #   string = "Hello World"
  #
  #   string.qua_class do
  #     def important
  #        self + "!"
  #     end
  #   end
  #
  #   string.important  #=> "Hello World!"
  #
  # Yes, another one.
  #
  # CREDIT: Trans
  # The +qua_class+ method can also be written +quaclass+.
  #
  # source://facets//lib/core/facets/kernel/qua_class.rb#29
  def quaclass(&block); end

  # Require a pattern of files relatvie to the current file.
  # This makes is easy to require an entire directory, for instance:
  #
  #   require_all 'core_ext/*'
  #
  # NOTE: This method used to allow glob-based requires from the $LOAD_PATH,
  # but this was deprecated in favor of relative requiring only, as it is
  # consider the typical usecase, and globbing from the $LOAD_PATH is a
  # bit dangerous. Better options exist for globbing the $LOAD_PATH such as
  # the +plugins+ gem.
  #
  # source://facets//lib/core/facets/kernel/require_all.rb#14
  def require_all(pattern); end

  # Like #respond_to? but returns the result of the call
  # if it does indeed respond.
  #
  #   class RespondExample
  #     def f; "f"; end
  #   end
  #
  #   x = RespondExample.new
  #   x.respond(:f)  #=> "f"
  #   x.respond(:g)  #=> nil
  #
  # This method was known as #try until Rails defined #try
  # to be something more akin to #ergo.
  #
  # CREDIT: Chris Wanstrath
  #
  # source://facets//lib/core/facets/kernel/respond.rb#23
  def respond(sym = T.unsafe(nil), *args, &blk); end

  # A Ruby-ized realization of the K combinator.
  #
  #   book_class = Struct.new(:title, :author)
  #
  #   book = returning book_class.new do |book|
  #     book.title = "Imperium"
  #     book.author = "Ulick Varange"
  #   end
  #
  #   book.class  #=> book_class
  #
  # Technically, #returning probably should force the return of
  # the stated object irregardless of any return statements that
  # might appear within it's block. This might differentiate
  # #returning from #with, however it also would require
  # implementation in Ruby itself.
  #
  # CREDIT: Mikael Brockman
  #
  # @yield [obj]
  #
  # source://facets//lib/core/facets/kernel/returning.rb#22
  def returning(obj = T.unsafe(nil)); end

  # Call parent class/module methods once bound to self.
  #
  # TODO: Does this have the proper scope for #send?
  #
  # source://facets//lib/core/facets/kernel/as.rb#37
  def send_as(ancestor, sym, *args, &blk); end

  # Silence a stream and/or warnings...
  #
  #   silence(:stdout) do
  #     puts "won't see me"
  #   end
  #
  # Supported +streams+ are +stderr+, +stdout+, +verbose+, +debug+,
  # and +warnings+, which is the same as +verbose+. You can also
  # use the actual streams, STDERR and STDOUT.
  #
  # source://facets//lib/core/facets/kernel/silence.rb#12
  def silence(*streams); end

  # Equivalent to `silence_stream(STDERR)`.
  #
  # source://facets//lib/core/facets/kernel/silence.rb#63
  def silence_stderr; end

  # Equivalent to `silence_stream(STDOUT)`.
  #
  # source://facets//lib/core/facets/kernel/silence.rb#68
  def silence_stdout; end

  # Silences any stream for the duration of the block...
  #
  #   silence_stream(STDOUT) do
  #     puts 'This will never be seen'
  #   end
  #
  #   puts 'But this will'
  #
  # CREDIT: David Heinemeier Hansson
  #
  # source://facets//lib/core/facets/kernel/silence.rb#49
  def silence_stream(*streams); end

  # CREDIT: Trans
  # DEPRECATE: Use #disable_warnings instead.
  #
  # source://facets//lib/core/facets/kernel/disable_warnings.rb#14
  def silence_warnings; end

  # Just like silence_stream, but will default to
  # STDOUT, STDERR if no streams are given.
  #
  # source://facets//lib/core/facets/kernel/silence.rb#34
  def silently(*streams); end

  # Returns method of a parent class bound to self.
  #
  # source://facets//lib/core/facets/kernel/super_method.rb#4
  def super_method(klass, meth); end

  # The tap K-Combinator. This yields self -and- returns self.
  #
  #   'foo.yml'.tap{ |f| YAML.load(f) }  #=> 'foo.yml'
  #
  # Unlike Ruby's definition, this rendition can be used as a higher
  # order message. This form allows a single call before returning
  # the receiver.
  #
  #   YAML.tap.load_file('foo.yml').load_file('bar.yml')
  #
  # IMPORTANT: This is one of few core overrides in Facets.
  #
  # source://facets//lib/core/facets/kernel/tap.rb#17
  def tap; end

  # Temporarily set variables while yielding a block, then return the
  # variables to their original settings when complete.
  #
  #   temporarily('$VERBOSE'=>false) do
  #     $VERBOSE.assert == false
  #   end
  #
  # source://facets//lib/core/facets/kernel/temporarily.rb#10
  def temporarily(settings); end

  # Boolean conversion for not being nil or false.
  # Other classes may redefine this to suite the
  # particular need.
  #
  #   "yes".to_b   #=> true
  #   "abc".to_b   #=> false
  #
  #   true.to_b    #=> true
  #   false.to_b   #=> false
  #   nil.to_b     #=> false
  #
  # CREDIT: Ara T. Howard, Trans
  #
  # source://facets//lib/core/facets/boolean.rb#17
  def to_b; end

  # All objects except false and nil are "true".
  #
  # source://facets//lib/core/facets/boolean.rb#22
  def to_bool; end

  # Returns true is an object is class TrueClass,
  # otherwise false.
  #
  #   true.true?   #=> true
  #   false.true?  #=> false
  #   nil.true?    #=> false
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/true.rb#10
  def true?; end

  # Invokes the method identified by the symbol +method+, passing it any
  # arguments  and/or the block specified, just like the regular Ruby
  # <tt>Object#send</tt> does.
  #
  # *Unlike* that method however, a +NoMethodError+ exception will *not*
  # be raised and +nil+ will be returned instead, if the receiving object
  # is a +nil+ object or NilClass.
  #
  # For example, without try
  #
  #   @example = Struct.new(:name).new("bob")
  #
  #   @example && @example.name
  #
  # or:
  #
  #   @example ? @example.name : nil
  #
  # But with try
  #
  #   @example.try(:name)  #=> "bob"
  #
  # or
  #
  #   @example.try.name    #=> "bob"
  #
  # It also accepts arguments and a block, for the method it is trying:
  #
  #   @people.try(:collect){ |p| p.name }
  #
  # source://facets//lib/core/facets/kernel/try.rb#35
  def try(method = T.unsafe(nil), *args, &block); end

  # Tests to see if something has value. An object
  # is considered to have value if it is not nil?
  # and if it responds to #empty?, is not empty.
  #
  #   nil.val?     #=> false
  #   [].val?      #=> false
  #   10.val?      #=> true
  #   [nil].val?   #=> true
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/val.rb#12
  def val?; end

  # Like returning but exectues the block
  # via instance_eval.
  #
  #   def foo
  #     with values = [] do
  #       self << 'bar'
  #       self << 'baz'
  #     end
  #   end
  #
  #   foo # => ['bar', 'baz']
  #
  # source://facets//lib/core/facets/kernel/with.rb#15
  def with(obj = T.unsafe(nil), &block); end

  # Returns an Array of methods ending in '='.
  #
  #   class WritersExample
  #     attr_reader :a, :b
  #     attr_accessor :x, :y
  #     private
  #     def q=(q); @q=q; end
  #   end
  #
  #   w = WritersExample.new
  #
  #   syms = w.writers      # [:x=, :y=]
  #
  #   syms.include?(:x=)    #=> true
  #   syms.include?(:y=)    #=> true
  #
  # If the +chomp+ option is true, then the trailing '=' will be removed.
  #
  #   syms = w.writers(:chomp=>true)
  #
  #   syms.include?(:x)     #=> true
  #   syms.include?(:y)     #=> true
  #
  # By default #writers only includes public methods. To see private or
  # protected methods use the +:access+ option.
  #
  #   w.writers(:access=>:private)  #=> [:q=]
  #
  # Or multiple access options,
  #
  #   syms = w.writers(:access=>[:public,:private])    # [:q=,:x=,:y=]
  #
  #   syms.include?(:q=)    #=> true
  #   syms.include?(:x=)    #=> true
  #   syms.include?(:y=)    #=> true
  #
  # You can simply supply `:all` to get all method regardless accessibility.
  #
  # Also, by default this method excludes all writers defined in Object
  # or Kernel. To include these set +ancestors+ to Object or Kernel.
  #
  #   w.writers(Object)
  #
  # TODO: Create Module#instance_writers.
  #
  # source://facets//lib/core/facets/kernel/writers.rb#48
  def writers(*ancestors_and_options); end

  # Ask a question expecting a yes answer.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/yes.rb#6
  def yes?(question); end

  private

  # Very simple convenience method to get user input
  # via the console. A prompt will be sent to $stdout,
  # if given, and the input taken from $stdin...
  #
  #   ask "Are you happy? [Yn]"
  #
  # On the command line one would see...
  #
  #   Are you happy? [Yn]
  #
  # Responding...
  #
  #   Are you happy? [Yn] Y <ENTER>
  #
  # The ask method would return "Y".
  #
  # source://facets//lib/core/facets/kernel/ask.rb#21
  def ask(prompt = T.unsafe(nil)); end

  # A shorthand pronoun for binding().
  #
  #   a = 3
  #   eval("a", here)  #=> 3
  #
  # source://facets//lib/core/facets/kernel/here.rb#8
  def here; end

  # source://facets//lib/core/facets/kernel/not.rb#32
  def not_send(op, *a, &b); end

  # source://facets//lib/core/facets/kernel/callstack.rb#4
  def pp_call_stack(*_arg0); end

  # source://facets//lib/core/facets/kernel/callstack.rb#3
  def pp_callstack(*_arg0); end

  class << self
    # Very simple convenience method to get user input
    # via the console. A prompt will be sent to $stdout,
    # if given, and the input taken from $stdin...
    #
    #   ask "Are you happy? [Yn]"
    #
    # On the command line one would see...
    #
    #   Are you happy? [Yn]
    #
    # Responding...
    #
    #   Are you happy? [Yn] Y <ENTER>
    #
    # The ask method would return "Y".
    #
    # source://facets//lib/core/facets/kernel/ask.rb#21
    def ask(prompt = T.unsafe(nil)); end
  end
end

# source://facets//lib/core/facets/kernel/object_hexid.rb#3
Kernel::ARCH_SIZE = T.let(T.unsafe(nil), Integer)

# source://facets//lib/core/facets/kernel/object_hexid.rb#13
Kernel::HEXID_TEMPLATE = T.let(T.unsafe(nil), String)

# Everything you need for Lazy evaluation in Ruby.
#
# @author MenTaLguY
#
# source://facets//lib/core/facets/lazy.rb#25
module Lazy; end

# Raised when a demanded computation diverges (e.g. if it tries to directly
# use its own result)
#
# source://facets//lib/core/facets/lazy.rb#30
class Lazy::DivergenceError < ::Exception
  # @return [DivergenceError] a new instance of DivergenceError
  #
  # source://facets//lib/core/facets/lazy.rb#31
  def initialize(message = T.unsafe(nil)); end
end

# = Future
#
# Future class subclasses PromiseSafe.
#
# source://facets//lib/core/facets/lazy.rb#168
class Lazy::Future < ::Lazy::PromiseSafe
  # @return [Future] a new instance of Future
  #
  # source://facets//lib/core/facets/lazy.rb#169
  def initialize(&computation); end
end

# Wraps an exception raised by a lazy computation.
#
# The reason we wrap such exceptions in LazyException is that they need to
# be distinguishable from similar exceptions which might normally be raised
# by whatever strict code we happen to be in at the time.
#
# source://facets//lib/core/facets/lazy.rb#43
class Lazy::LazyException < ::Lazy::DivergenceError
  # @return [LazyException] a new instance of LazyException
  #
  # source://facets//lib/core/facets/lazy.rb#46
  def initialize(reason); end

  # the original exception
  #
  # source://facets//lib/core/facets/lazy.rb#44
  def reason; end
end

# source://facets//lib/core/facets/lazy.rb#63
class Lazy::Promise
  # @return [Promise] a new instance of Promise
  #
  # source://facets//lib/core/facets/lazy.rb#68
  def initialize(&computation); end

  # source://facets//lib/core/facets/lazy.rb#65
  def __class__; end

  # source://facets//lib/core/facets/lazy.rb#83
  def __result__; end

  # source://facets//lib/core/facets/lazy.rb#71
  def __synchronize__; end

  # source://facets//lib/core/facets/lazy.rb#107
  def inspect; end

  # source://facets//lib/core/facets/lazy.rb#124
  def method_missing(*args, &block); end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/lazy.rb#117
  def respond_to?(message); end
end

# Create this once here, rather than creating a proc object for every evaluation.
#
# source://facets//lib/core/facets/lazy.rb#76
Lazy::Promise::DIVERGES = T.let(T.unsafe(nil), Proc)

# = PromiseSafe
#
# Thread safe version of Promise class.
#
# source://facets//lib/core/facets/lazy.rb#133
class Lazy::PromiseSafe < ::Lazy::Promise
  # source://facets//lib/core/facets/lazy.rb#134
  def __synchronize__; end
end

# source://facets//lib/core/facets/matchdata/match.rb#1
class MatchData
  # Return the primary match string. This is equivalent to +md[0]+.
  #
  #   md = /123/.match "123456"
  #   md.match  #=> "123"
  #
  # CREDIT: Martin DeMello
  #
  # source://facets//lib/core/facets/matchdata/match.rb#10
  def match(index = T.unsafe(nil)); end

  # Returns [ pre_match, matchtree, post_match ]. (see matchtree)
  #
  #   md = /(bb)(cc(dd))(ee)/.match "XXaabbccddeeffXX"
  #   md.to_a      #=> ["bbccddee", "bb", "ccdd", "dd", "ee"]
  #   md.matchset  #=> ["XXaa", [["bb"], ["cc", ["dd"]], ["ee"]], "ffXX"]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/matchdata/matchset.rb#11
  def matchset; end

  # An alternate to #to_a which returns the matches in
  # order corresponding with the regular expression.
  #
  #   md = /(bb)(cc(dd))(ee)/.match "XXaabbccddeeffXX"
  #   md.to_a       #=> ["bbccddee", "bb", "ccdd", "dd", "ee"]
  #   md.matchtree  #=> [["bb"], ["cc", ["dd"]], ["ee"]]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/matchdata/matchset.rb#24
  def matchtree(index = T.unsafe(nil)); end
end

# source://facets//lib/core/facets/method/composition.rb#1
class Method
  # Method composition.
  #
  # @author Mike Burns
  #
  # source://facets//lib/core/facets/method/composition.rb#80
  def *(g); end

  # Method repetition.
  #
  # @author Mike Burns
  #
  # source://facets//lib/core/facets/method/composition.rb#87
  def ^(n); end
end

# Method Composition class acts a proxy for composed methods.
#
# @author Mike Burns
#
# source://facets//lib/core/facets/method/composition.rb#11
class Method::Composition
  # @return [Composition] a new instance of Composition
  #
  # source://facets//lib/core/facets/method/composition.rb#14
  def initialize(*f); end

  # source://facets//lib/core/facets/method/composition.rb#25
  def *(h); end

  # source://facets//lib/core/facets/method/composition.rb#71
  def [](*x); end

  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/method/composition.rb#31
  def ^(n); end

  # source://facets//lib/core/facets/method/composition.rb#51
  def arity; end

  # source://facets//lib/core/facets/method/composition.rb#62
  def call(*x); end

  # source://facets//lib/core/facets/method/composition.rb#19
  def inspect; end

  # source://facets//lib/core/facets/method/composition.rb#41
  def owner; end

  # source://facets//lib/core/facets/method/composition.rb#46
  def receiver; end

  # source://facets//lib/core/facets/method/composition.rb#56
  def to_proc; end
end

# source://facets//lib/core/facets/module/abstract.rb#1
class Module
  # Rename methods.
  #
  #   module AStar
  #     def a; "a"; end
  #   end
  #
  #   BStar = AStar * { :a => :b }
  #
  #   class XStar; include BStar; end
  #
  #   XStar.new.b    #=> "a"
  #
  # CREDIT: Thomas Sawyer, Robert Dober
  #
  # source://facets//lib/core/facets/module/op.rb#95
  def *(rename_map); end

  # Combine modules.
  #
  #   module APlus
  #     def a; "a"; end
  #   end
  #
  #   module BPlus
  #     def b; "b"; end
  #   end
  #
  #   CPlus = APlus + BPlus
  #
  #   class XPlus; include CPlus; end
  #
  #   XPlus.new.a    #=> "a"
  #   XPlus.new.b    #=> "b"
  #
  # Note that in the old version of traits.rb we cloned
  # modules and altered their copies...
  #
  #   def +(other)
  #     mod1 = other.clone
  #     mod2 = clone
  #     mod1.module_eval{ include mod2 }
  #   end
  #
  # Later it was realized that this thwarted the main
  # benefit that Ruby's concept of modules has over
  # traditional traits, inheritance.
  #
  # CREDIT: Thomas Sawyer, Robert Dober
  #
  # source://facets//lib/core/facets/module/op.rb#35
  def +(other); end

  # Subtract modules.
  #
  #   module AMinus
  #     def a; "a"; end
  #     def b; "b"; end
  #   end
  #
  #   CMinus = AMinus - [:a]
  #
  #   class XMinus; include CMinus; end
  #
  #   expect NameError do
  #     XMinus.new.a  #=> "a"
  #   end
  #
  #   XMinus.new.b    #=> "b"
  #
  # TODO: Should this use all instance methods, not just public?
  #
  # CREDIT: Thomas Sawyer, Robert Dober
  #
  # source://facets//lib/core/facets/module/op.rb#64
  def -(other); end

  # Create an abstract method. If it is not overridden, it will
  # raise a TypeError when called.
  #
  #   class AbstractExample
  #     abstract :a
  #   end
  #
  #   c = AbstractExample.new
  #
  #   expect TypeError do
  #     c.a
  #   end
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/abstract.rb#18
  def abstract(*sym); end

  # Encapsulates the common pattern of ...
  #
  #   alias_method :foo_without_feature, :foo
  #   alias_method :foo, :foo_with_feature
  #
  # With this, you simply do ...
  #
  #   alias_method_chain :foo, :feature
  #
  # For example
  #
  #   class AliasMethodChainExample
  #     def foo
  #       "foo"
  #     end
  #
  #     def foo_with_feature
  #       "foo!"
  #     end
  #
  #     alias_method_chain :foo, :feature
  #   end
  #
  # And both aliases are set up for you.
  #
  #   example = AliasMethodChainExample.new
  #   example.foo #=> "foo!"
  #   example.foo_without_feature #=> "foo"
  #
  # Query and bang methods (foo?, foo!) keep the same punctuation ...
  #
  #   alias_method_chain :foo?, :feature
  #
  # is equivalent to ...
  #
  #   alias_method :foo_without_feature?, :foo?
  #   alias_method :foo?, :foo_with_feature?
  #
  # so you can safely chain foo, foo?, and foo! with the same feature.
  #
  # CREDIT: Bitsweat, Rails Team
  #
  # @yield [aliased_target, punctuation]
  #
  # source://facets//lib/core/facets/module/alias_method_chain.rb#45
  def alias_method_chain(target, feature); end

  # Alias an accessor. This create an alias for
  # both a reader and a writer.
  #
  #   class AttrSetterExample
  #     attr_setter :a
  #     alias_setter :b, :a
  #   end
  #
  #   x = AttrSetterExample.new
  #   x.b(1)
  #   x.a        #=> 1
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/attr_setter.rb#49
  def alias_setter(_arg0, _arg1); end

  # List all instance methods, equivalent to
  #
  #   public_instance_methods +
  #   protected_instance_methods +
  #   private_instance_methods
  #
  # TODO: Better name for #all_instance_methods?
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/all_instance_methods.rb#13
  def all_instance_methods(include_super = T.unsafe(nil)); end

  # Is a given class or module an ancestor of
  # this class or module?
  #
  #  class X ; end
  #  class Y < X ; end
  #
  #   X.ancestor?(Y)
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/module/ancestor.rb#11
  def ancestor?(mod); end

  # A module may or may not have a name.
  #
  # module M; end
  # M.name # => "M"
  #
  # m = Module.new
  # m.name # => ""
  #
  # A module gets a name when it is first assigned to a constant. Either
  # via the +module+ or +class+ keyword or by an explicit assignment:
  #
  # m = Module.new # creates an anonymous module
  # M = m # => m gets a name here as a side-effect
  # m.name # => "M"
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/module/anonymous.rb#18
  def anonymous?; end

  # Create an attribute method for both getting
  # and setting an instance variable:
  #
  #   attr_setter :a
  #
  # is equivalent to:
  #
  #   def a(*args)
  #     if args.size > 0
  #       @a = args[0]
  #       self
  #     else
  #       @a
  #     end
  #   end
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/attr_setter.rb#21
  def attr_setter(*args); end

  # Returns the root name of the module/class.
  #
  #   module ::BaseName
  #     class Example
  #     end
  #   end
  #
  #   BaseName::Example.name       #=> "BaseName::Example"
  #   BaseName::Example.lastname   #=> "Example"
  #
  # Returns nil when module is anonymous.
  #
  # CREDIT: Trans
  # Original name, but conflicts with File.basename, so is
  # mildly deprecated.
  #
  # source://facets//lib/core/facets/module/lastname.rb#27
  def basename; end

  # An alias for #extend.
  #
  #   module EgCan
  #     def foo; "foo"; end
  #   end
  #
  #   class EgCanClass
  #     can EgCan
  #   end
  #
  #   EgCanClass.foo  #=> 'foo'
  #
  # BTW, why is Forwardable an -able? It's not a mixin!
  #
  # source://facets//lib/core/facets/module/can.rb#17
  def can(*mod, &blk); end

  # Alias for #===. This provides a verbal method
  # for inquery.
  #
  #   s = "HELLO"
  #   String.class?(s)  #=> true
  #
  # source://facets//lib/core/facets/module/class.rb#9
  def class?(_arg0); end

  # Defines an instance method within a class/module.
  #
  # CREDIT: WhyTheLuckyStiff
  #
  # source://facets//lib/core/facets/module/module_def.rb#7
  def class_def(name, &blk); end

  # Query whether a normal (singleton) method is defined for the module.
  #
  # CREDIT: Gavin Sinclair, Noah Gibbs
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/module/instance_method_defined.rb#21
  def class_method_defined?(meth); end

  # Returns the module or class containing the receiver.
  #
  #   module ::HomeExample
  #     module M
  #       module N
  #       end
  #     end
  #   end
  #
  #   HomeExample::M::N.home  #=> HomeExample::M
  #
  # The home of a top-level module/class is Object.
  #
  #   HomeExample.home   #=> Object
  #
  # This method is called *home* because techinally a module or class
  # is just a constant reference, and as such can reside with multiple
  # namespaces, like any variable. For example:
  #
  #   module OtherPlace
  #     M = ::HomeExample::M
  #   end
  #
  # In this example, you might think that +OtherPlace::M+'s home would be
  # +OtherPlace+, but +OtherPlace::M+ is the same object as +HomeExample::M+,
  # and it can have only one "home" --the original location of it's definition.
  #
  # source://facets//lib/core/facets/module/home.rb#29
  def home; end

  # Returns the name of module or class containing the receiver.
  #
  #   module ::HomeExample
  #     module M
  #       module N
  #       end
  #     end
  #   end
  #
  #   HomeExample::M::N.homename  #=> "HomeExample::M"
  #
  # See also Module#basename.
  #
  # source://facets//lib/core/facets/module/home.rb#57
  def homename; end

  # Returns all the namespaces of this module according ordered from
  # nearest and moving outwards. The receiver is not contained within
  # the result.
  #
  #   module ::HouseExample
  #     module M
  #       module N
  #       end
  #     end
  #   end
  #
  #   HouseExample.housing        #=> [Object]
  #   HouseExample::M.housing     #=> [HouseExample, Object]
  #   HouseExample::M::N.housing  #=> [HouseExample::M, HouseExample, Object]
  #
  # Compare this to +Module.nesting+.
  #
  # source://facets//lib/core/facets/module/home.rb#80
  def housing; end

  # Access method as a singleton object and retain state.
  #
  #   module ::K
  #     def hello
  #       puts "Hello World!"
  #     end
  #   end
  #
  #   K.instance_method!(:hello).inspect   #=> "#<UnboundMethod: K#hello>"
  #
  # NOTE: This is limited to the scope of the current module/class.
  #
  # source://facets//lib/core/facets/module/instance_method.rb#18
  def instance_method!(s); end

  # Query whether a public instance method is defined for the module.
  #
  # CREDIT: Gavin Sinclair, Noah Gibbs
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/module/instance_method_defined.rb#7
  def instance_method_defined?(meth); end

  # Using integrate is just like using include except the
  # module included is a reconstruction of the one given
  # altered by the commands given in the block.
  #
  # Convenient commands available are: #rename, #redef,
  # #remove, #nodef and #wrap. But any module method
  # can be used.
  #
  #   module IntegrateExampleModule
  #     def q ; "q" ; end
  #     def y ; "y" ; end
  #   end
  #
  #   class InegrateExampleClass
  #     integrate IntegrateExampleModule do
  #       undef_method :y
  #     end
  #   end
  #
  #   x = InegrateExampleClass.new
  #   x.q  #=> "q"
  #
  #   expect NameError do
  #     x.y
  #   end
  #
  # This is like #revisal, but #revisal only
  # returns the reconstructred module. It does not
  # include it.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/integrate.rb#41
  def integrate(mod, &block); end

  # An alias for #include.
  #
  #   class IsExample
  #     is Enumerable
  #   end
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/is.rb#25
  def is(*mods); end

  # Is a given class or module an ancestor of this
  # class or module?
  #
  #   class IsX ; end
  #   class IsY < IsX ; end
  #
  #   IsY.is?(IsX)  #=> true
  #
  # CREDIT: Trans
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/module/is.rb#13
  def is?(base); end

  # Returns the root name of the module/class.
  #
  #   module ::BaseName
  #     class Example
  #     end
  #   end
  #
  #   BaseName::Example.name       #=> "BaseName::Example"
  #   BaseName::Example.lastname   #=> "Example"
  #
  # Returns nil when module is anonymous.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/lastname.rb#17
  def lastname; end

  # Translate a module name to a suitable method name.
  #
  #   module ::EgMethodize
  #     module Eg
  #     end
  #   end
  #
  #   EgMethodize.methodize      #=> "eg_methodize"
  #   EgMethodize::Eg.methodize  #=> "eg_methodize__eg"
  #
  # source://facets//lib/core/facets/module/methodize.rb#15
  def methodize; end

  # Returns the name of module or class containing the receiver.
  #
  #   module ::HomeExample
  #     module M
  #       module N
  #       end
  #     end
  #   end
  #
  #   HomeExample::M::N.homename  #=> "HomeExample::M"
  #
  # See also Module#basename.
  # Original name for #homename.
  #
  # source://facets//lib/core/facets/module/home.rb#62
  def modname; end

  # Defines an instance method within a class/module.
  #
  # CREDIT: WhyTheLuckyStiff
  #
  # source://facets//lib/core/facets/module/module_def.rb#15
  def module_def(name, &blk); end

  # Query whether a normal (singleton) method is defined for the module.
  #
  # CREDIT: Gavin Sinclair, Noah Gibbs
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/module/instance_method_defined.rb#20
  def module_method_defined?(meth); end

  # Converts a class name to a unix path.
  #
  #   module ::ExamplePathize
  #     module Example
  #     end
  #   end
  #
  #   ExamplePathize.pathize           #=> "example_pathize"
  #   ExamplePathize::Example.pathize  #=> "example_pathize/example"
  #
  # source://facets//lib/core/facets/module/pathize.rb#15
  def pathize; end

  # Creates a new method for a pre-existing method.
  #
  # If _aka_ is given, then the method being redefined will
  # first be aliased to this name.
  #
  #   class Greeter
  #     def hello ; "Hello" ; end
  #   end
  #
  #   Greeter.new.hello   #=> "Hello"
  #
  #   class Greeter
  #     redefine_method( :hello, :hi ) do
  #       hi + ", friend!"
  #     end
  #   end
  #
  #   Greeter.new.hello   #=> "Hello, friend!"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/redefine_method.rb#35
  def redef(sym, aka = T.unsafe(nil), &blk); end

  # Creates a new method for a pre-existing method.
  #
  # If _aka_ is given, then the method being redefined will
  # first be aliased to this name.
  #
  #   class Greeter
  #     def hello ; "Hello" ; end
  #   end
  #
  #   Greeter.new.hello   #=> "Hello"
  #
  #   class Greeter
  #     redefine_method( :hello, :hi ) do
  #       hi + ", friend!"
  #     end
  #   end
  #
  #   Greeter.new.hello   #=> "Hello, friend!"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/redefine_method.rb#26
  def redefine_method(sym, aka = T.unsafe(nil), &blk); end

  # Return a new module based on another. This includes the original module
  # into the new revised module.
  #
  #   module ReviseExample
  #     def foo; "foo"; end
  #   end
  #
  #   ReviseExample2 = ReviseExample.revise do
  #     alias_method :bar, :foo
  #   end
  #
  #   object = Object.new
  #   object.extend ReviseExample2
  #   object.bar  #=> 'foo'
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/revise.rb#33
  def revisal(&blk); end

  # Return a new module based on another. This includes the original module
  # into the new revised module.
  #
  #   module ReviseExample
  #     def foo; "foo"; end
  #   end
  #
  #   ReviseExample2 = ReviseExample.revise do
  #     alias_method :bar, :foo
  #   end
  #
  #   object = Object.new
  #   object.extend ReviseExample2
  #   object.bar  #=> 'foo'
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/revise.rb#26
  def revise(&blk); end

  # Sets an option to the given value. If the value is a proc,
  # the proc will be called every time the option is accessed.
  #
  # CREDIT: Blake Mizerany (Sinatra)
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/module/set.rb#10
  def set(option, value = T.unsafe(nil), &block); end

  # Query whether a normal (singleton) method is defined for the module.
  #
  # CREDIT: Gavin Sinclair, Noah Gibbs
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/module/instance_method_defined.rb#15
  def singleton_method_defined?(meth); end

  # Returns the name of module's container module.
  #
  #   module ::SpaceName
  #     class Example
  #     end
  #   end
  #
  #   SpaceName::Example.name         #=> "SpaceName::Example"
  #   SpaceName::Example.spacename    #=> "SpaceName"
  #
  # This used to be called +dirname+.
  #
  # See also Module#basename.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/spacename.rb#19
  def spacename; end

  # Create an instance of Object and extend it with +self+.
  #
  #   mod = Module.new do
  #     def foo; "foo"; end
  #   end
  #
  #   obj = mod.to_obj
  #
  #   obj.foo #=> "foo"
  #
  # source://facets//lib/core/facets/module/to_obj.rb#13
  def to_obj; end

  # Creates a new method wrapping the previous of the same name.
  # Reference to the old method is passed into the new definition
  # block as the first parameter.
  #
  #   class WrapExample
  #     def foo
  #       "foo"
  #     end
  #
  #     wrap_method(:foo) do |old_meth, *args|
  #       old_meth.call + '!'
  #     end
  #   end
  #
  #   example = WrapExample.new
  #   example.foo #=> 'foo!'
  #
  # Keep in mind that this cannot be used to wrap methods
  # that take a block.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/wrap_method.rb#32
  def wrap(sym, &blk); end

  # Creates a new method wrapping the previous of the same name.
  # Reference to the old method is passed into the new definition
  # block as the first parameter.
  #
  #   class WrapExample
  #     def foo
  #       "foo"
  #     end
  #
  #     wrap_method(:foo) do |old_meth, *args|
  #       old_meth.call + '!'
  #     end
  #   end
  #
  #   example = WrapExample.new
  #   example.foo #=> 'foo!'
  #
  # Keep in mind that this cannot be used to wrap methods
  # that take a block.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/wrap_method.rb#27
  def wrap_method(sym, &blk); end

  protected

  # Alias for undef_method. This has been called "nodef" instead of
  # undef to help clarify that it doesn't get rid of the method, but
  # rather represses repsonse.
  #
  # source://facets//lib/core/facets/module/nodef.rb#6
  def nodef(*_arg0); end

  # Alias for remove_method. This method actually "undefines" a method
  # and will raise an error is the method is not defined in receiver.
  #
  # source://facets//lib/core/facets/module/nodef.rb#10
  def remove(*_arg0); end

  private

  # As with alias_method, but alias both reader and writer.
  #
  #   attr_accessor :x
  #   self.x = 1
  #   alias_accessor :y, :x
  #   y #=> 1
  #   self.y = 2
  #   x #=> 2
  #
  # source://facets//lib/core/facets/module/alias_accessor.rb#14
  def alias_accessor(*args); end

  # Alias a module function so that the alias is also
  # a module function. The typical #alias_method
  # does not do this.
  #
  #   module AliasExample
  #     module_function
  #     def hello
  #       "Hello"
  #     end
  #   end
  #
  #   AliasExample.hello  #=> 'Hello'
  #
  #   module AliasExample
  #     alias_module_function( :hi , :hello )
  #   end
  #
  #   AliasExample.hi     #=> 'Hello'
  #
  # source://facets//lib/core/facets/module/alias_module_function.rb#24
  def alias_module_function(new, old); end

  # As with alias_accessor, but just for the reader.
  # This is basically the same as alias_method.
  #
  # source://facets//lib/core/facets/module/alias_accessor.rb#26
  def alias_reader(*args); end

  # As with alias_method but does the writer instead.
  #
  # source://facets//lib/core/facets/module/alias_accessor.rb#36
  def alias_writer(*args); end

  # Include module and apply module_fuction to the
  # included methods.
  #
  #   module Utils
  #     module_function
  #     def foo; "foo"; end
  #   end
  #
  #   module UtilsPlus
  #     include_function_module Utils
  #   end
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/include_function_module.rb#19
  def include_function_module(*mod); end

  # Redirect methods to other methods. This simply
  # defines methods by the name of a hash key which
  # calls the method with the name of the hash's value.
  #
  #   class RedirectExample
  #     redirect_method :hi => :hello, :hey => :hello
  #     def hello(name)
  #       "Hello, #{name}."
  #     end
  #   end
  #
  #   e = RedirectExample.new
  #   e.hello("Bob")    #=> "Hello, Bob."
  #   e.hi("Bob")       #=> "Hello, Bob."
  #   e.hey("Bob")      #=> "Hello, Bob."
  #
  # The above class definition is equivalent to ...
  #
  #   class RedirectExample
  #     def hi(*args)
  #       hello(*args)
  #     end
  #     def hey(*args)
  #       hello(*args)
  #     end
  #     def hello
  #       puts "Hello"
  #     end
  #   end
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/redirect_method.rb#44
  def redirect(method_hash); end

  # Redirect methods to other methods. This simply
  # defines methods by the name of a hash key which
  # calls the method with the name of the hash's value.
  #
  #   class RedirectExample
  #     redirect_method :hi => :hello, :hey => :hello
  #     def hello(name)
  #       "Hello, #{name}."
  #     end
  #   end
  #
  #   e = RedirectExample.new
  #   e.hello("Bob")    #=> "Hello, Bob."
  #   e.hi("Bob")       #=> "Hello, Bob."
  #   e.hey("Bob")      #=> "Hello, Bob."
  #
  # The above class definition is equivalent to ...
  #
  #   class RedirectExample
  #     def hi(*args)
  #       hello(*args)
  #     end
  #     def hey(*args)
  #       hello(*args)
  #     end
  #     def hello
  #       puts "Hello"
  #     end
  #   end
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/module/redirect_method.rb#37
  def redirect_method(method_hash); end

  # Aliases a method and undefines the original.
  #
  #   class RenameExample
  #     def foo; "foo"; end
  #     rename_method(:bar, :foo)
  #   end
  #
  #   example = RenameExample.new
  #   example.bar  #=> 'foo'
  #
  #   expect NoMethodError do
  #     example.foo
  #   end
  #
  # CREDIT: Trans
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/module/rename_method.rb#27
  def rename(to_sym, from_sym); end

  # Aliases a method and undefines the original.
  #
  #   class RenameExample
  #     def foo; "foo"; end
  #     rename_method(:bar, :foo)
  #   end
  #
  #   example = RenameExample.new
  #   example.bar  #=> 'foo'
  #
  #   expect NoMethodError do
  #     example.foo
  #   end
  #
  # CREDIT: Trans
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/module/rename_method.rb#21
  def rename_method(to_sym, from_sym); end
end

# source://facets//lib/core/facets/boolean.rb#50
class NilClass
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/blank.rb#44
  def blank?; end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#34
  def clone?; end

  # Since NilClass is immutable it cannot be duplicated.
  # For this reason #try_dup returns +self+.
  #
  #   nil.dup!  #=> nil
  #
  # source://facets//lib/core/facets/object/dup.rb#32
  def dup!; end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#33
  def dup?; end

  # Compliments Kernel#ergo.
  #
  #   "a".ergo{ |o| o.upcase } #=> "A"
  #   nil.ergo{ |o| o.bar }    #=> nil
  #
  # CREDIT: Daniel DeLorme
  #
  # source://facets//lib/core/facets/kernel/ergo.rb#38
  def ergo; end

  # source://facets//lib/core/facets/boolean.rb#51
  def to_bool; end

  # See Kernel#try.
  #
  # source://facets//lib/core/facets/kernel/try.rb#49
  def try(method = T.unsafe(nil), *args); end
end

# source://facets//lib/core/facets/kernel/ergo.rb#29
NilClass::FUNCTOR = T.let(T.unsafe(nil), Functor)

# source://facets//lib/core/facets/boolean.rb#56
class Numeric
  include ::Comparable

  # Determines if another number is approximately equal within a given
  # _n_th degree. Defaults to 100ths if the degree is not specified.
  #
  # Currently defaults to 1/10,000,000 if the degree is not specified.
  # But this may change once a "most commonly useful" factor is determined.
  #
  # This is the same a {#close?} but has a different defualt.
  #
  # @author Gavin Sinclair
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/numeric/approx.rb#13
  def approx?(x, n = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/blank.rb#80
  def blank?; end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#78
  def clone?; end

  # Determines if another number is approximately equal
  # within a given +epsilon+.
  #
  # This is the same a {#approx?} but has a different default.
  # In this case it is 1/100th.
  #
  # @author Gavin Sinclair
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/numeric/approx.rb#24
  def close?(number, epsilon = T.unsafe(nil)); end

  # Returns the distance between self an another value.
  # This is the same as #- but it provides an alternative
  # for common naming between variant classes.
  #
  #   4.distance(3)  #=> 1
  #
  # source://facets//lib/core/facets/numeric/distance.rb#9
  def distance(other); end

  # Since Numeric is immutable it cannot be duplicated.
  # For this reason #try_dup returns +self+.
  #
  #   1.dup!  #=> 1
  #
  # source://facets//lib/core/facets/object/dup.rb#76
  def dup!; end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#77
  def dup?; end

  # Returns +self+, useful for polymorphic cases.
  #
  # source://facets//lib/core/facets/numeric/length.rb#5
  def length; end

  # Is a number less than zero.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/numeric/positive.rb#11
  def negative?; end

  # Is a number greater than zero.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/numeric/positive.rb#5
  def positive?; end

  # Conceptually, rounding is expected to apply to floating point numbers.
  # However it can actually be applied to pretty much any Numeric object.
  # For example, one could round an Integer to the nearest kilo.
  #
  # See Float#round_to.
  #
  # source://facets//lib/core/facets/numeric/round_to.rb#9
  def round_to(*args); end

  # Returns the size of the string representation of
  # a numerical value.
  #
  #      1.spacing   #=> 1
  #     10.spacing   #=> 2
  #    100.spacing   #=> 3
  #   -100.spacing   #=> 4
  #    1.2.spacing   #=> 3
  #
  # CREDIT: Victor H. Goff III
  #
  # source://facets//lib/core/facets/numeric/spacing.rb#14
  def spacing; end

  # Provides a boolean interpretation of self.
  # If self == 0 then false else true.
  #
  #   0.to_b    #=> false
  #   1.to_b    #=> true
  #   2.3.to_b  #=> true
  #
  # source://facets//lib/core/facets/boolean.rb#64
  def to_b; end
end

# source://facets//lib/core/facets/object/dup.rb#1
class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#23
  def clone?; end

  # Override this in a child class if it cannot be dup'ed.
  #
  #   obj1 = Object.new
  #   obj2 = obj1.dup!
  #   obj2.equal?(obj1)    #=> false
  #
  # CREDIT: Dan Kubb (extlib)
  #
  # source://facets//lib/core/facets/object/dup.rb#9
  def dup!; end

  # Can you safely call #dup on this object?
  #
  # Returns +false+ for +nil+, +false+, +true+, symbols, and numbers;
  # +true+ otherwise.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#22
  def dup?; end

  # An identity method that provides access to an object's 'self'.
  #
  # Example
  #
  #   [1,2,3,4,5,1,2,2,3].group_by(&:itself)
  #   #=> {1=>[1, 1], 2=>[2, 2, 2], 3=>[3, 3], 4=>[4], 5=>[5]}
  #
  # CREDIT: Michael Kohl
  #
  # source://facets//lib/core/facets/object/itself.rb#12
  def itself; end

  # Get or set state of object. You can think of #object_state as an in-code
  # form of marshalling.
  #
  #   class StateExample
  #     attr_reader :a, :b
  #     def initialize(a,b)
  #       @a, @b = a, b
  #     end
  #   end
  #
  #   obj = StateExample.new(1,2)
  #   obj.a  #=> 1
  #   obj.b  #=> 2
  #
  #   obj.object_state  #=> {:a=>1, :b=>2}
  #
  #   obj.object_state(:a=>3, :b=>4)
  #   obj.a  #=> 3
  #   obj.b  #=> 4
  #
  # For most object's this is essentially the same as <code>instance.to_h</code>.
  # But for data structures like Array and Hash it returns a snapshot of their
  # contents, not the state of their instance variables.
  # --
  # TODO: Should this be in module Kernel ?
  # ++
  #
  # source://facets//lib/core/facets/object/object_state.rb#28
  def object_state(data = T.unsafe(nil)); end

  # Alternative name for #dup!
  #
  # source://facets//lib/core/facets/object/dup.rb#14
  def try_dup; end
end

# source://facets//lib/core/facets/objectspace/classes.rb#1
module ObjectSpace
  class << self
    # source://facets//lib/core/facets/objectspace/op_fetch.rb#2
    def [](_arg0); end

    # @return [Array[Class]] All the classes in the object space.
    #
    # source://facets//lib/core/facets/objectspace/classes.rb#4
    def classes; end
  end
end

class ObjectSpace::WeakMap
  include ::Enumerable
end

# source://facets//lib/core/facets/proc/bind.rb#3
class Proc
  # Operator for Proc#compose and Integer#times_collect/of.
  #
  #   a = lambda { |x| x + 4 }
  #   b = lambda { |y| y / 2 }
  #
  #   (a * b).call(4)  #=> 6
  #   (b * a).call(4)  #=> 4
  #
  # CREDIT: Dave
  #
  # source://facets//lib/core/facets/proc/compose.rb#29
  def *(x); end

  # Bind a Proc to an object returning a Method.
  #
  # NOTE: This version comes from Rails. The old Facets
  # version used thread.rb, but I no longer think
  # the implementaiton is thread critical. Please
  # make a bug report if this proves wrong.
  #
  # source://facets//lib/core/facets/proc/bind.rb#12
  def bind(object); end

  # Bind a procedure to an object. This works by
  # wrapping instance_eval on the Proc object and
  # then wrapping this in a new Proc.
  #
  #    a = [1,2,3]
  #    p1 = Proc.new{ join(' ') }
  #    p2 = p1.bind_to(a)
  #    p2.call  #=> '1 2 3'
  #
  # source://facets//lib/core/facets/proc/bind_to.rb#12
  def bind_to(object); end

  # Returns a new proc that is the functional
  # composition of two procs, in order.
  #
  #   a = lambda { |x| x + 4 }
  #   b = lambda { |y| y / 2 }
  #
  #   a.compose(b).call(4)  #=> 6
  #   b.compose(a).call(4)  #=> 4
  #
  # CREDIT: Dave
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/proc/compose.rb#14
  def compose(g); end

  # Convert a Proc object into new partial Proc object.
  #
  #   a = proc { |a,b,c| a+b+c }
  #   b = a.partial(NA,2,NA)
  #   b[1,3] #=> 6
  #
  # Note, the #__ method, which used to be used in stay of NA,
  # has been deprecated.
  #
  # --
  #   a = proc { |a,b,c| a+b+c }
  #   b = a.partial(__,2,__)
  #   b[1,3] #=> 6
  # ++
  #
  # This method is similar to Proc#curry.
  #
  # CREDT Trans
  #
  # source://facets//lib/core/facets/proc/partial.rb#24
  def partial(*args); end

  # Convert Proc to method.
  #
  #   object = Object.new
  #
  #   function = lambda { |x| x + 1 }
  #
  #   function.to_method(object, 'foo')
  #
  #   object.foo(1)  #=> 2
  #
  # source://facets//lib/core/facets/proc/to_method.rb#16
  def to_method(object, name = T.unsafe(nil)); end

  # Use a Proc as an observable.
  #
  # CREDIT: Tim Pease
  #
  # source://facets//lib/core/facets/proc/update.rb#7
  def update(*_arg0); end
end

# source://facets//lib/core/facets/range/combine.rb#1
class Range
  include ::Enumerable

  # Combine ranges.
  #
  #   (1..2).combine(2..4)   #=> [1..4]
  #   (1..2).combine(3..4)   #=> [1..2, 3..4]
  #
  # TODO: Incorporate end-sentinal inclusion vs. exclusion.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/range/combine.rb#12
  def combine(*intervals); end

  # Do two ranges overlap?
  #
  # CREDIT: Daniel Schierbeck, Brandon Keepers
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/range/overlap.rb#7
  def overlap?(other); end

  # A thing really should know itself.
  # This simply returns _self_.
  #
  # Note: This does not internally effect the Ruby
  # interpretor such that it can coerce Range-like
  # objects into a Range.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/range/to_rng.rb#21
  def to_range; end

  # A thing really should know itself.
  # This simply returns _self_.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/range/to_rng.rb#8
  def to_rng; end

  # Returns a two element array of the relationship
  # between two Ranges.
  #
  # Diagram ...
  #
  #     Relationship     Returns
  #
  #   self |-----------|
  #   r    |-----------|    [0,0]
  #
  #   self |-----------|
  #   r     |---------|     [-1,-1]
  #
  #   self  |---------|
  #   r    |-----------|    [1,1]
  #
  #   self |-----------|
  #   r     |----------|    [-1,0]
  #
  #   self |-----------|
  #   r     |-----------|   [-1,1]
  #
  #   etc.
  #
  # Example:
  #
  #   (0..3).umbrella(1..2)  #=>  [-1,-1]
  #
  # CREDIT: Trans, Chris Kappler
  #
  # source://facets//lib/core/facets/range/within.rb#49
  def umbrella(r); end

  # Uses the Range#umbrella method to determine
  # if another Range is _anywhere_ within this Range.
  #
  #   (1..3).within?(0..4)  #=> true
  #
  # CREDIT: Trans
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/range/within.rb#10
  def within?(rng); end

  class << self
    # Combine intervals.
    #
    #   Range.combine(1..2, 2..4)   #=> [1..4]
    #   Range.combine(1..2, 3..4)   #=> [1..2, 3..4]
    #
    # CREDIT: Trans
    #
    # source://facets//lib/core/facets/range/combine.rb#23
    def combine(*intervals); end
  end
end

# source://facets//lib/core/facets/regexp/arity.rb#1
class Regexp
  # Add regular expressions.
  #
  #   /a/ + /b/ == /(?-mix:a)(?-mix:b)/
  #
  # Functionally equivalent to:
  #
  #   /ab/
  #
  # CREDIT: Tyler Rick
  #
  # source://facets//lib/core/facets/regexp/op_add.rb#12
  def +(other); end

  # Returns the number of backreferencing subexpressions.
  #
  #   /(a)(b)(c)/.arity  #=> 3
  #   /(a(b(c)))/.arity  #=> 3
  #
  # Note that this is not perfect, especially with regards to \x
  # and embedded comments.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/regexp/arity.rb#13
  def arity; end

  # Is a regular expression multiline?
  #
  #   /x/.multiline?   #=> false
  #   /x/m.multiline?  #=> true
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/regexp/multiline.rb#8
  def multiline?; end

  # Simply returns itself. Helpful when converting
  # strings to regular expressions, where regexp
  # might occur as well --in the same vien as using
  # #to_s on symbols. The parameter is actaully a
  # dummy parameter to coincide with String#to_re.
  #
  #   /abc/.to_re  #=> /abc/
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/regexp/to_re.rb#24
  def to_re(esc = T.unsafe(nil)); end

  # Like #to_re, but following Ruby's formal definitions,
  # only a Regular expression type object will respond to this.
  #
  # Note that to be of much real use this should be defined in core Ruby.
  #
  # CREDIT: Florian Gross
  #
  # source://facets//lib/core/facets/regexp/to_re.rb#10
  def to_regexp; end

  # Operator form of `Regexp.union`.
  #
  #   /a/ | /b/  #=> /(?-mix:a)|(?-mix:b)/
  #
  # If +other+ is not a Regexp it is passed to Regexp.escape.
  #
  # source://facets//lib/core/facets/regexp/op_or.rb#9
  def |(other); end
end

# source://facets//lib/core/facets/boolean.rb#69
class String
  include ::Comparable

  # Removes occurances of a string or regexp. This is an operator
  # form for the #remove method.
  #
  #   ("HELLO HELLO" - "LL")    #=> "HEO HEO"
  #   ("HELLO PERL" - /L\S/)    #=> "HEO PERL"
  #
  # Returns a new [String] with all pattern matches removed.
  #
  # CREDIT: Benjamin David Oakes
  #
  # source://facets//lib/core/facets/string/remove.rb#26
  def -(pattern); end

  # Treats +self+ and +path+ as representations
  # of pathnames, joining thme together as a
  # single path.
  #
  #   ('home' / 'trans')  #=> 'home/trans'
  #
  # source://facets//lib/core/facets/string/op_div.rb#9
  def /(path); end

  # Binary XOR of two strings.
  #
  #   a = "\000\000\001\001" ^ "\000\001\000\001"
  #   b = "\003\003\003" ^ "\000\001\002"
  #
  #   a  #=> "\000\001\001\000"
  #   b  #=> "\003\002\001"
  #
  # source://facets//lib/core/facets/string/xor.rb#11
  def ^(aString); end

  # Transform a string into an acronym.
  #
  # CREDIT: Robert Fey
  #
  # source://facets//lib/core/facets/string/acronym.rb#7
  def acronym; end

  # Alignment method dispatches to #align_right, #align_left
  # or #align_center, accorging to the first +direction+ parameter.
  #
  #   s = <<-EOS
  #   This is a test
  #     and
  #     so on
  #   EOS
  #
  #   s.align(:right, 14)
  #
  # _produces_ ...
  #
  #   This is a test
  #              and
  #            so on
  #
  # Returns a String aligned right, left or center.
  #
  # source://facets//lib/core/facets/string/align.rb#21
  def align(direction, n, sep = T.unsafe(nil), c = T.unsafe(nil)); end

  # Centers each line of a string.
  #
  # The default alignment separation is a new line ("\n").
  # This can be changed as can be the padding string which
  # defaults to a single space (' ').
  #
  #   s = <<-EOS
  #     This is a test
  #     and
  #     so on
  #   EOS
  #
  #   s.align_center(14)
  #
  # _produces_ ...
  #
  #   This is a test
  #        and
  #       so on
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/align.rb#116
  def align_center(n, sep = T.unsafe(nil), c = T.unsafe(nil)); end

  # Align a string to the left.
  #
  # The default alignment separation is a new line ("\n").
  # This can be changed as can be the padding string which
  # defaults to a single space (' ').
  #
  #   s = <<-EOS
  #   This is a test
  #     and
  #     so on
  #   EOS
  #
  #   s.align_left(20, "\n", '.')
  #
  # _produces_ ...
  #
  #   This is a test......
  #   and.................
  #   so on...............
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/align.rb#86
  def align_left(n, sep = T.unsafe(nil), c = T.unsafe(nil)); end

  # Align a string to the right.
  #
  # The default alignment separation is a new line ("\n").
  # This can be changed as can be the padding string which
  # defaults to a single space (' ').
  #
  #   s = <<-EOS
  #   This is a test
  #     and
  #     so on
  #   EOS
  #
  #   s.align_right(14)
  #
  # _produces_ ...
  #
  #   This is a test
  #              and
  #            so on
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/align.rb#56
  def align_right(n, sep = T.unsafe(nil), c = T.unsafe(nil)); end

  # Is this string just whitespace?
  #
  #   "abc".blank?  #=> false
  #   "   ".blank?  #=> true
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/blank.rb#74
  def blank?; end

  # Return a new string embraced by given brackets.
  # If only one bracket char is given it will be placed
  # on either side.
  #
  #   "wrap me".bracket('{')        #=> "{wrap me}"
  #   "wrap me".bracket('--','!')   #=> "--wrap me!"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/bracket.rb#14
  def bracket(bra, ket = T.unsafe(nil)); end

  # Inplace version of #bracket.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/bracket.rb#24
  def bracket!(bra, ket = T.unsafe(nil)); end

  # Transform a string into a sentence like form.
  #
  #   "This Is A String".briefcase
  #   #=> "This is a string"
  #
  # source://facets//lib/core/facets/string/titlecase.rb#22
  def briefcase; end

  # Converts a string to camelcase. This method leaves the first character
  # as given. This allows other methods to be used first, such as #uppercase
  # and #lowercase.
  #
  #   "camel_case".camelcase          #=> "camelCase"
  #   "Camel_case".camelcase          #=> "CamelCase"
  #
  # Custom +separators+ can be used to specify the patterns used to determine
  # where capitalization should occur. By default these are underscores (`_`)
  # and space characters (`\s`).
  #
  #   "camel/case".camelcase('/')     #=> "camelCase"
  #
  # If the first separator is a symbol, either `:lower` or `:upper`, then
  # the first characters of the string will be downcased or upcased respectively.
  #
  #   "camel_case".camelcase(:upper)  #=> "CamelCase"
  #
  # Note that this implementation is different from ActiveSupport's.
  # If that is what you are looking for you may want {#modulize}.
  #
  # source://facets//lib/core/facets/string/camelcase.rb#24
  def camelcase(*separators); end

  # Return true if the string is capitalized, otherwise false.
  #
  #   "This".capitalized?  #=> true
  #   "THIS".capitalized?  #=> false
  #   "this".capitalized?  #=> false
  #
  # Note Ruby's strange concept of capitalized. See capitalcase
  # for the more command conception.
  #
  # CREDIT: Phil Tomson
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/string/capitalized.rb#14
  def capitalized?; end

  # Returns an array of characters.
  #
  #   "abc".characters.to_a  #=> ["a","b","c"]
  #
  # TODO: Probably should make this an enumerator. With #scan?
  #
  # source://facets//lib/core/facets/string/characters.rb#8
  def characters; end

  # Returns an Enumerator for iterating over each
  # line of the string, stripped of whitespace on
  # either side.
  #
  #   "this\nthat\nother\n".cleanlines.to_a  #=> ['this', 'that', 'other']
  #
  # source://facets//lib/core/facets/string/cleanlines.rb#11
  def cleanlines(&block); end

  # Cleave a string. Break a string in two parts at
  # the nearest whitespace.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/cleave.rb#8
  def cleave(threshold = T.unsafe(nil), len = T.unsafe(nil)); end

  # Compare method that takes length into account.
  # Unlike #<=>, this is compatible with #succ.
  #
  #   "abc".cmp("abc")   #=>  0
  #   "abcd".cmp("abc")  #=>  1
  #   "abc".cmp("abcd")  #=> -1
  #   "xyz".cmp("abc")   #=>  1
  #
  # CREDIT: Peter Vanbroekhoven
  #
  # TODO: Move String#cmp to string/ directory.
  #
  # source://facets//lib/core/facets/comparable/cmp.rb#34
  def cmp(other); end

  # Matches any whitespace (including newline) and replaces with a single space
  #
  #   string = <<-QUERY.compress_lines
  #     SELECT name
  #     FROM users
  #   QUERY
  #
  #   string  #=> "SELECT name FROM users"
  #
  # source://facets//lib/core/facets/string/compress_lines.rb#12
  def compress_lines(spaced = T.unsafe(nil)); end

  # Breaks a string up into an array based on a regular expression.
  # Similar to scan, but includes the matches.
  #
  #   s = "<p>This<b>is</b>a test.</p>"
  #   s.divide( /\<.*?\>/ )
  #   #=> ["<p>This", "<b>is", "</b>a test.", "</p>"]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/divide.rb#12
  def divide(re); end

  # Return true if the string is lowercase (downcase), otherwise false.
  #
  #   "THIS".downcase?  #=> false
  #   "This".downcase?  #=> false
  #   "this".downcase?  #=> true
  #
  # CREDIT: Phil Tomson
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/string/capitalized.rb#26
  def downcase?; end

  # Like #scan but returns MatchData ($~) rather
  # then matched string ($&).
  #
  # CREDIT: Trans
  # Alias for #mscan.
  #
  # source://facets//lib/core/facets/string/mscan.rb#19
  def each_match(re); end

  # Iterate through each word of a string.
  #
  #   a = []
  #
  #   "list of words".each_word { |word| a << word }
  #
  #   a  #=> ['list', 'of', 'words']
  #
  # source://facets//lib/core/facets/string/each_word.rb#13
  def each_word(&block); end

  # Levenshtein distance algorithm implementation for Ruby, with UTF-8 support.
  #
  # The Levenshtein distance is a measure of how similar two strings s and t are,
  # calculated as the number of deletions/insertions/substitutions needed to
  # transform s into t. The greater the distance, the more the strings differ.
  #
  # The Levenshtein distance is also sometimes referred to as the
  # easier-to-pronounce-and-spell 'edit distance'.
  #
  # Calculate the Levenshtein distance between two strings +self+ and +str2+.
  # +self+ and +str2+ should be ASCII, UTF-8, or a one-byte-per character encoding
  # such as ISO-8859-*.
  #
  # The strings will be treated as UTF-8 if $KCODE is set appropriately (i.e. 'u').
  # Otherwise, the comparison will be performed byte-by-byte. There is no specific support
  # for Shift-JIS or EUC strings.
  #
  # When using Unicode text, be aware that this algorithm does not perform normalisation.
  # If there is a possibility of different normalised forms being used, normalisation
  # should be performed beforehand.
  #
  # CREDIT: Paul Battley
  #
  # source://facets//lib/core/facets/string/edit_distance.rb#85
  def edit_distance(str2); end

  # source://facets//lib/core/facets/string/starts_with.rb#3
  def ends_with?(*_arg0); end

  # The inverse of include?.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/string/exclude.rb#5
  def exclude?(str); end

  # Expands tabs to +n+ spaces. Non-destructive. If +n+ is 0,
  # then tabs are simply removed. Raises an exception if +n+
  # is negative.
  #
  #   "\t\tHey".expand_tabs(2)  #=> "    Hey"
  #
  # Thanks to GGaramuno for a more efficient algorithm. Very nice.
  #
  # CREDIT: Gavin Sinclair, Noah Gibbs, GGaramuno
  #
  # TODO: Don't much care for the name String#expand_tabs.
  # What about a more concise name like #detab?
  # Singular form of #expand_tabs.
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/string/expand_tab.rb#32
  def expand_tab(n = T.unsafe(nil)); end

  # Expands tabs to +n+ spaces. Non-destructive. If +n+ is 0,
  # then tabs are simply removed. Raises an exception if +n+
  # is negative.
  #
  #   "\t\tHey".expand_tabs(2)  #=> "    Hey"
  #
  # Thanks to GGaramuno for a more efficient algorithm. Very nice.
  #
  # CREDIT: Gavin Sinclair, Noah Gibbs, GGaramuno
  #
  # TODO: Don't much care for the name String#expand_tabs.
  # What about a more concise name like #detab?
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/string/expand_tab.rb#16
  def expand_tabs(n = T.unsafe(nil)); end

  # Use fluent notation for making file directives.
  #
  # For instance, if we had a file 'foo.txt',
  #
  #    'foo.txt'.file.mtime
  #
  # source://facets//lib/core/facets/string/file.rb#13
  def file; end

  # Returns a new string with all new lines removed from
  # adjacent lines of text.
  #
  #     s = "This is\na test.\n\nIt clumps\nlines of text."
  #     s.fold
  #
  # _produces_
  #
  #     "This is a test.\n\nIt clumps lines of text. "
  #
  # TODO: One arguable flaw with this that might need a fix:
  # if the given string ends in a newline, it is replaced with
  # a single space.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/fold.rb#19
  def fold(ignore_indented = T.unsafe(nil)); end

  # Indent left or right by `n` spaces, or `n` number of `c` string.
  #
  # n - The number of spaces to indent. [Integer]
  # c - Character to use, if other then space. [String]
  #
  # Returns a new string with the indention. [String]
  #
  # Credit: Gavin Sinclair
  # Credit: Trans
  # Credit: Tyler Rick
  #
  # source://facets//lib/core/facets/string/indent.rb#14
  def indent(n, c = T.unsafe(nil)); end

  # Equivalent to String#indent, but modifies the receiver in place.
  #
  # n - The number of spaces to indent. [Integer]
  # c - Character to use, if other then space. [String]
  #
  # Returns this string with the indention. [String]
  #
  # source://facets//lib/core/facets/string/indent.rb#29
  def indent!(n, c = T.unsafe(nil)); end

  # Like index but returns an array of all index locations.
  # The reuse flag allows the trailing portion of a match to be
  # reused for subsquent matches.
  #
  #   "abcabcabc".index_all('a')  #=> [0,3,6]
  #
  #   "bbb".index_all('bb', false)  #=> [0]
  #   "bbb".index_all('bb', true)   #=> [0,1]
  #
  # TODO: Culd probably be defined for Indexable in general too.
  #
  # source://facets//lib/core/facets/string/index_all.rb#14
  def index_all(s, reuse = T.unsafe(nil)); end

  # Left chomp.
  #
  #   "help".lchomp("h")  #=> "elp"
  #   "help".lchomp("k")  #=> "help"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/lchomp.rb#10
  def lchomp(match); end

  # In-place left chomp.
  #
  #   "help".lchomp("h")  #=> "elp"
  #   "help".lchomp("k")  #=> "help"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/lchomp.rb#25
  def lchomp!(match); end

  # Line wrap at width.
  #
  #   s = "1234567890".line_wrap(5)
  #
  #   s  #=> "12345\n67890\n"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/line_wrap.rb#11
  def line_wrap(width, tabs = T.unsafe(nil)); end

  # Like `#newlines` but returns a Functor instead.
  #
  #   "a \n b \n c".linear.strip   #=> "a\nb\nc"
  #
  # source://facets//lib/core/facets/string/linear.rb#11
  def linear; end

  # Same as +#camelcase+ but converts first letter to lowercase.
  #
  #   "camel_case".lower_camelcase   #=> "camelCase"
  #   "Camel_case".lower_camelcase   #=> "camelCase"
  #
  # @deprecated Use `#camelcase(:lower)` instead.
  #
  # source://facets//lib/core/facets/string/camelcase.rb#68
  def lower_camelcase(*separators); end

  # Downcase first letter.
  #
  # source://facets//lib/core/facets/string/uppercase.rb#17
  def lowercase; end

  # Preserve relative tabbing such that the line with the least amount
  # of white space ends up with the given number of spaces before non-space
  # and all other lines move relative to it.
  #
  # Because of the nature of this method, leading tab characters (`\t`) must
  # be converted to spaces. The size of a tab can be set via the `:tab` option.
  # The default size is 2.
  #
  # If the `:lead` option is set, then the relative margin is determined
  # by the first non-blank line, instead of the minimum white-space for all
  # lines.
  #
  # Arguments
  #
  #   num   - The size of the desired margin. [Integer]
  #   opts  - Margin options. [Hash]
  #
  # Options
  #
  #   :tab  - Size of tab character in spaces. [Integer]
  #   :lead - Use first non-blank line as relative marker. [Boolean]
  #
  # Returns a new String with adjusted margin. [String]
  #
  # Author: Gavin Sinclair
  # Author: Trans
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/string/margin.rb#32
  def margin(num = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Translate a class or module name to a suitable method name.
  #
  #   "My::CoolClass".methodize  #=> "my__cool_class"
  #
  # source://facets//lib/core/facets/string/methodize.rb#7
  def methodize; end

  # Converts a string to module name representation.
  #
  # This is essentially #camelcase, but it also converts
  # '/' to '::' which is useful for converting paths to
  # namespaces.
  #
  # Examples
  #
  #   "method_name".modulize    #=> "MethodName"
  #   "method/name".modulize    #=> "Method::Name"
  #
  # source://facets//lib/core/facets/string/modulize.rb#14
  def modulize; end

  # Like #scan but returns MatchData ($~) rather
  # then matched string ($&).
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/mscan.rb#8
  def mscan(re); end

  # 'Natural order' comparison of strings, e.g. ...
  #
  #   "my_prog_v1.1.0" < "my_prog_v1.2.0" < "my_prog_v1.10.0"
  #
  # which does not follow alphabetically. A secondary
  # parameter, if set to _true_, makes the comparison
  # case insensitive.
  #
  #   "Hello.1".natcmp("Hello.10")  #=> -1
  #
  # TODO: Invert case flag?
  #
  # @author Alan Davies
  # @author Martin Pool
  #
  # source://facets//lib/core/facets/string/natcmp.rb#47
  def natcmp(str2, caseInsensitive = T.unsafe(nil)); end

  # Returns _n_ characters of the string. If _n_ is positive
  # the characters are from the beginning of the string.
  # If _n_ is negative from the end of the string.
  #
  #    str = "this is text"
  #
  #    str.nchar(4)            #=> "this"
  #    str.nchar(-4)           #=> "text"
  #
  # Alternatively a replacement string can be given, which will
  # replace the _n_ characters.
  #
  #    str.nchar(4, 'that')    #=> "that is text"
  #
  # The original string remains unaffected.
  #
  #    str  #=> "this is text"
  #
  # source://facets//lib/core/facets/string/nchar.rb#21
  def nchar(n, replacement = T.unsafe(nil)); end

  # Returns an Enumerator for iterating over each
  # line of the string, void of the termining newline
  # character, in contrast to #lines which retains it.
  #
  #   "a\nb\nc".newlines.class.assert == Enumerator
  #   "a\nb\nc".newlines.to_a.assert == %w{a b c}
  #
  #   a = []
  #   "a\nb\nc".newlines{|nl| a << nl}
  #   a.assert == %w{a b c}
  #
  # source://facets//lib/core/facets/string/newlines.rb#16
  def newlines(&block); end

  # Returns true if it's a decimal digits.
  #
  #   "123_456_789_123_456_789.123_456_000_111".number?  # => true
  #   "1.23".number?  # => true
  #   "1.23a".number? # => false
  #
  # CREDIT: u2
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/string/number.rb#11
  def number?; end

  # source://facets//lib/core/facets/object/object_state.rb#54
  def object_state(data = T.unsafe(nil)); end

  # Transforms a namespace, i.e. a class or module name, into a viable
  # file path.
  #
  #   "ExamplePathize".pathize           #=> "example_pathize"
  #   "ExamplePathize::Example".pathize  #=> "example_pathize/example"
  #
  # Compare this method to {String#modulize) and {String#methodize).
  #
  # source://facets//lib/core/facets/string/pathize.rb#11
  def pathize; end

  # Return a new string embraced by given +type+ and +count+
  # of quotes. The arguments can be given in any order.
  #
  # If no type is given, double quotes are assumed.
  #
  #   "quote me".quote     #=> '"quote me"'
  #
  # If no type but a count is given then :mixed is assumed.
  #
  #   "quote me".quote(1)  #=> %q{'quote me'}
  #   "quote me".quote(2)  #=> %q{"quote me"}
  #   "quote me".quote(3)  #=> %q{'"quote me"'}
  #
  # Symbols can be used to describe the type.
  #
  #   "quote me".quote(:single)    #=> %q{'quote me'}
  #   "quote me".quote(:double)    #=> %q{"quote me"}
  #   "quote me".quote(:back)      #=> %q{`quote me`}
  #   "quote me".quote(:bracket)   #=> %q{`quote me'}
  #
  # Or the character itself.
  #
  #   "quote me".quote("'")     #=> %q{'quote me'}
  #   "quote me".quote('"')     #=> %q{"quote me"}
  #   "quote me".quote("`")     #=> %q{`quote me`}
  #   "quote me".quote("`'")    #=> %q{`quote me'}
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/quote.rb#32
  def quote(type = T.unsafe(nil), count = T.unsafe(nil)); end

  # Like #index but returns a Range.
  #
  #   "This is a test!".range('test')  #=> (10..13)
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/range.rb#9
  def range(pattern, offset = T.unsafe(nil)); end

  # Like #index_all but returns an array of Ranges.
  #
  #   "abc123abc123".range_all('abc')  #=> [0..2, 6..8]
  #
  # TODO: Add offset ?
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/range.rb#28
  def range_all(pattern, reuse = T.unsafe(nil)); end

  # Returns an array of ranges mapping
  # the characters per line.
  #
  #   "this\nis\na\ntest".range_of_line
  #   #=> [0..4, 5..7, 8..9, 10..13]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/range.rb#50
  def range_of_line; end

  # Removes all occurrences of a pattern in a string.
  #
  # Returns a new [String] with all occurrences of the pattern removed.
  #
  # source://facets//lib/core/facets/string/remove.rb#6
  def remove(pattern); end

  # Removes all occurrences of a pattern in a string.
  #
  # Returns the [String] with all occurrences of the pattern removed.
  #
  # source://facets//lib/core/facets/string/remove.rb#13
  def remove!(pattern); end

  # Apply a set of rules in the form of regular expression matches
  # to the string.
  #
  # * rules - The array containing rule-pairs (match, write).
  #
  # Keep in mind that the order of rules is significant.
  #
  # Returns the rewritten String.
  #
  # CREDIT: George Moschovitis
  #
  # @raise [ArgumentError]
  #
  # source://facets//lib/core/facets/string/rewrite.rb#14
  def rewrite(rules); end

  # Rotate string to the left with count.
  # Specifying negative number indicates rotation to the right.
  #
  #   'abcdefgh'.rotate(2)  #=> 'cdefghab'
  #   'abcdefgh'.rotate(-2) #=> 'ghabcdef'
  #
  # CREDIT: T. Yamada
  #
  # source://facets//lib/core/facets/string/rotate.rb#10
  def rotate(count = T.unsafe(nil)); end

  # Destructive version of String#rotate
  #
  #   s='abcdefgh'
  #   s.rotate!(2)
  #   s.should eq 'cdefghab'
  #
  # CREDIT: T. Yamada
  #
  # source://facets//lib/core/facets/string/rotate.rb#22
  def rotate!(count = T.unsafe(nil)); end

  # Breaks a string up into an array based on a regular expression.
  # Similar to scan, but includes the matches.
  #
  #   s = "<p>This<b>is</b>a test.</p>"
  #   s.shatter( /\<.*?\>/ )
  #
  # _produces_
  #
  #   ["<p>", "This", "<b>", "is", "</b>", "a test.", "</p>"]
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/shatter.rb#15
  def shatter(re); end

  # A fuzzy matching mechanism. Returns a score from 0-1, based
  # on the number of shared edges. To be effective, the strings
  # must be of length 2 or greater.
  #
  #     "Alexsander".similarity("Aleksander")  #=> 0.9
  #
  # The way it works:
  #
  # 1. Converts each string into a "graph like" object, with edges ...
  #
  #        "alexsander" -> [ alexsander, alexsand, alexsan ... lexsand ... san ... an, etc ]
  #        "aleksander" -> [ aleksander, aleksand ... etc. ]
  #
  # 2. Perform match, then remove any subsets from this matched set (i.e. a hit
  # on "san" is a subset of a hit on "sander") ...
  #
  #        Above example, once reduced -> [ ale, sander ]
  #
  # 3. See's how many of the matches remain, and calculates a score based
  # on how many matches, their length, and compare to the length of the
  # larger of the two words.
  #
  # Still a bit rough. Any suggestions for improvement are welcome.
  #
  # CREDIT: Derek Lewis
  #
  # source://facets//lib/core/facets/string/similarity.rb#29
  def similarity(str_in); end

  # Underscore a string such that camelcase, dashes and spaces are
  # replaced by underscores. This is the reverse of {#camelcase},
  # albeit not an exact inverse.
  #
  #   "SnakeCase".snakecase         #=> "snake_case"
  #   "Snake-Case".snakecase        #=> "snake_case"
  #   "Snake Case".snakecase        #=> "snake_case"
  #   "Snake  -  Case".snakecase    #=> "snake_case"
  #
  # Note, this method no longer converts `::` to `/`, in that case
  # use the {#pathize} method instead.
  #
  # source://facets//lib/core/facets/string/snakecase.rb#15
  def snakecase; end

  # String#slice is essentially the same as #store.
  #
  #   a = "HELLO"
  #   a.splice(1, "X")
  #   a                #=> "HXLLO"
  #
  # But it acts like #slice! when given a single argument.
  #
  #   a = "HELLO"
  #   a.splice(1)    #=> "E"
  #   a              #=> "HLLO"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/splice.rb#19
  def splice(idx, sub = T.unsafe(nil)); end

  # Returns the string, first removing all whitespace on both ends of
  # the string, and then changing remaining consecutive whitespace
  # groups into one space each.
  #
  #   %{ Multi-line
  #      string }.squish                   # => "Multi-line string"
  #
  #   " foo   bar    \n   \t   boo".squish # => "foo bar boo"
  #
  # source://facets//lib/core/facets/string/squish.rb#11
  def squish; end

  # Performs a destructive squish. See String#squish.
  #
  # source://facets//lib/core/facets/string/squish.rb#16
  def squish!; end

  # source://facets//lib/core/facets/string/starts_with.rb#2
  def starts_with?(*_arg0); end

  # Alias for []=.
  #
  # source://facets//lib/core/facets/string/store.rb#4
  def store(*_arg0); end

  # Transform a string into a form that makes for an acceptable title.
  #
  #   "this is a string".titlecase
  #   #=> "This Is A String"
  #
  # @author Eliazar Parra
  # @author Angelo Lakra (apostrophe fix)
  #
  # source://facets//lib/core/facets/string/titlecase.rb#11
  def titlecase; end

  # Interpret common affirmative string meanings as true,
  # otherwise nil or false. Blank space and case are ignored.
  # The following strings that will return true ...
  #
  #   true
  #   yes
  #   on
  #   t
  #   1
  #   y
  #   ==
  #
  # The following strings will return nil ...
  #
  #   nil
  #   null
  #
  # All other strings return false.
  #
  # Here are some exmamples.
  #
  #   "true".to_b   #=> true
  #   "yes".to_b    #=> true
  #   "no".to_b     #=> false
  #   "123".to_b    #=> false
  #
  # source://facets//lib/core/facets/boolean.rb#96
  def to_b; end

  # Turns a string into a regular expression.
  #
  #   "a?".to_re  #=> /a?/
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/to_re.rb#9
  def to_re(esc = T.unsafe(nil)); end

  # Turns a string into a regular expression.
  # By default it will escape all characters.
  # Use <tt>false</tt> argument to turn off escaping.
  #
  #   "[".to_rx  #=> /\[/
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/to_re.rb#21
  def to_rx(esc = T.unsafe(nil)); end

  # Return a new string with the given brackets removed.
  # If only one bracket char is given it will be removed
  # from either side.
  #
  #   "{unwrap me}".unbracket('{')        #=> "unwrap me"
  #   "--unwrap me!".unbracket('--','!')  #=> "unwrap me"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/bracket.rb#37
  def unbracket(bra = T.unsafe(nil), ket = T.unsafe(nil)); end

  # Inplace version of #unbracket.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/bracket.rb#57
  def unbracket!(bra = T.unsafe(nil), ket = T.unsafe(nil)); end

  # Underscore a string such that camelcase, dashes and spaces are
  # replaced by underscores. This is the reverse of {#camelcase},
  # albeit not an exact inverse.
  #
  #   "SnakeCase".snakecase         #=> "snake_case"
  #   "Snake-Case".snakecase        #=> "snake_case"
  #   "Snake Case".snakecase        #=> "snake_case"
  #   "Snake  -  Case".snakecase    #=> "snake_case"
  #
  # Note, this method no longer converts `::` to `/`, in that case
  # use the {#pathize} method instead.
  #
  # source://facets//lib/core/facets/string/snakecase.rb#26
  def underscore; end

  # Unfold paragraphs such that new lines are removed from between
  # sentences of the same paragraph.
  #
  # Note that #rstrip is called on the final result, but this may
  # change in the future.
  #
  # FIXME: Sometimes adds one too many blank lines, which is why we are
  #         using rstrip. Fix and probably remove the rstrip.
  #
  # source://facets//lib/core/facets/string/unfold.rb#12
  def unfold; end

  # Remove excessive indentation. Useful for multi-line strings
  # embeded in already indented code.
  #
  # size - The number of spaces to indent. [Integer]
  #
  # Examples
  #
  #     <<-END.unindent
  #         ohaie
  #           wurld
  #     END
  #     #=> "ohaie\n  wurld"
  #
  # Returns a new unindented string. [String]
  #
  # Credit: Noah Gibbs
  # Credit: mynyml
  #
  # source://facets//lib/core/facets/string/indent.rb#51
  def unindent(size = T.unsafe(nil)); end

  # Equivalent to String#unindent, but modifies the receiver in place.
  #
  # Returns this string unindented. [String]
  #
  # Credit: mynyml
  #
  # source://facets//lib/core/facets/string/indent.rb#73
  def unindent!; end

  # Remove quotes from string.
  #
  #   "'hi'".unquote    #=> "hi"
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/string/quote.rb#76
  def unquote; end

  # Is the string upcase/uppercase?
  #
  #   "THIS".upcase?  #=> true
  #   "This".upcase?  #=> false
  #   "this".upcase?  #=> false
  #
  # CREDIT: Phil Tomson
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/string/capitalized.rb#41
  def upcase?; end

  # Same as +#camelcase+ but converts first letter to uppercase.
  #
  #   "camel_case".upper_camelcase   #=> "CamelCase"
  #   "Camel_case".upper_camelcase   #=> "CamelCase"
  #
  # @deprecated Use `#camelcase(:upper)` instead.
  #
  # source://facets//lib/core/facets/string/camelcase.rb#56
  def upper_camelcase(*separators); end

  # Upcase first letter.
  #
  # NOTE: One might argue that this method should behave the same as
  # +#upcase+ and rather this behavior should be in place of +#captialize+.
  # Probably so, but since Matz has already defined +#captialize+ the way
  # it is, this name seems most fitting to the missing behavior.
  #
  # source://facets//lib/core/facets/string/uppercase.rb#10
  def uppercase; end

  # Prepend an "@" to the beginning of a string
  # to make a instance variable name. This also replaces
  # non-valid characters with underscores.
  #
  # source://facets//lib/core/facets/string/variablize.rb#7
  def variablize; end

  # Word wrap a string not exceeding max width.
  #
  #   "this is a test".word_wrap(4)
  #
  # _produces_ ...
  #
  #   this
  #   is a
  #   test
  #
  # This is basic implementation of word wrap, but smart
  # enough to suffice for most use cases.
  #
  # CREDIT: Gavin Kistner, Dayne Broderson
  #
  # source://facets//lib/core/facets/string/word_wrap.rb#18
  def word_wrap(col_width = T.unsafe(nil)); end

  # As with #word_wrap, but modifies the string in place.
  #
  # CREDIT: Gavin Kistner, Dayne Broderson
  #
  # source://facets//lib/core/facets/string/word_wrap.rb#26
  def word_wrap!(col_width = T.unsafe(nil)); end

  # Returns an array of characters.
  #
  #   "abc 123".words  #=> ["abc","123"]
  #
  # source://facets//lib/core/facets/string/words.rb#7
  def words; end

  class << self
    # Interpolate provides a means of externally using Ruby string
    # interpolation mechinism.
    #
    #   try = "hello"
    #   str = "\#{try}!!!"
    #   String.interpolate{ str }    #=> "hello!!!"
    #
    # Note this uses #eval under the hood. We do not recommend that
    # it serve in place of a good templating system. But, it can be
    # useful for simple cases.
    #
    # The block is neccessary in order to get then binding of the caller.
    #
    # CREDIT: Trans
    #
    # source://facets//lib/core/facets/string/interpolate.rb#18
    def interpolate(&str); end

    # Create a random String of given length, using given character set
    #
    # Character set is an Array which can contain Ranges, Arrays, Characters
    #
    # Examples
    #
    #     String.random
    #     => "D9DxFIaqR3dr8Ct1AfmFxHxqGsmA4Oz3"
    #
    #     String.random(10)
    #     => "t8BIna341S"
    #
    #     String.random(10, ['a'..'z'])
    #     => "nstpvixfri"
    #
    #     String.random(10, ['0'..'9'] )
    #     => "0982541042"
    #
    #     String.random(10, ['0'..'9','A'..'F'] )
    #     => "3EBF48AD3D"
    #
    #     BASE64_CHAR_SET =  ["A".."Z", "a".."z", "0".."9", '_', '-']
    #     String.random(10, BASE64_CHAR_SET)
    #     => "xM_1t3qcNn"
    #
    #     SPECIAL_CHARS = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "-", "_", "=", "+", "|", "/", "?", ".", ",", ";", ":", "~", "`", "[", "]", "{", "}", "<", ">"]
    #     BASE91_CHAR_SET =  ["A".."Z", "a".."z", "0".."9", SPECIAL_CHARS]
    #     String.random(10, BASE91_CHAR_SET)
    #      => "S(Z]z,J{v;"
    #
    # CREDIT: Tilo Sloboda
    #
    # SEE: https://gist.github.com/tilo/3ee8d94871d30416feba
    #
    # TODO: Move to random.rb in standard library?
    #
    # source://facets//lib/core/facets/string/random.rb#39
    def random(len = T.unsafe(nil), character_set = T.unsafe(nil)); end
  end
end

# source://facets//lib/core/facets/string/bracket.rb#3
String::BRA2KET = T.let(T.unsafe(nil), Hash)

# source://facets//lib/core/facets/object/object_state.rb#66
class Struct
  include ::Enumerable

  # Returns a hash containing the names and values
  # for all instance settings in the Struct.
  #
  # This will eventually be deprecated in favor of #to_h.
  #
  # source://facets//lib/core/facets/struct/attributes.rb#8
  def attributes; end

  # source://facets//lib/core/facets/object/object_state.rb#68
  def object_state(data = T.unsafe(nil)); end

  # Struct#replace can take any +source+ that responds to #each_pair.
  #
  # source://facets//lib/core/facets/struct/replace.rb#4
  def replace(source); end
end

# source://facets//lib/core/facets/object/dup.rb#59
class Symbol
  include ::Comparable

  # Join with _path_ as a file path.
  #
  # * path - The path component(s) to append. [#to_s]
  #
  # Examples
  #
  #   (:merb / "string")   #=> "merb/string"
  #   (:merb / :symbol)    #=> "merb/symbol"
  #
  # Returns String of the receiver (as a path string), concatenated
  # with _path_.
  #
  # source://facets//lib/core/facets/symbol/op_div.rb#16
  def /(path); end

  # Convert symbol to string, apply string method and convert
  # back to symbol via a fluent interface.
  #
  #   :HELLO.as_s.chomp('O')  #=> :HELL
  #
  # source://facets//lib/core/facets/symbol/as_s.rb#12
  def as_s; end

  # Symbol ends in `!`.
  #
  #   :a!.bang? #=> true
  #   :a.bang?  #=> false
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/symbol/plain.rb#46
  def bang?; end

  # Useful extension for &:symbol which makes it possible
  # to pass arguments for method in block
  #
  #   ['abc','','','def','ghi'].tap(&:delete.(''))
  #   #=> ['abc','def','ghi']
  #
  #   [1,2,3].map(&:to_s.(2))
  #   #=> ['1','10','11']
  #
  #   ['abc','cdef','xy','z','wwww'].select(&:size.() == 4)
  #   #=> ['cdef', 'wwww']
  #
  #   ['abc','aaA','AaA','z'].count(&:upcase.().succ == 'AAB')
  #   #=> 2
  #
  #   [%w{1 2 3 4 5},%w{6 7 8 9}].map(&:join.().length)
  #   #=> [5,4]
  #
  # CREDIT: Ilya Vorontsov, Nobuyoshi Nakada
  #
  # source://facets//lib/core/facets/symbol/call.rb#23
  def call(*args, &block); end

  # Just like String#chomp.
  #
  #   :ab.chomp(:b)  #=> :a
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/symbol/chomp.rb#9
  def chomp(seperator); end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#67
  def clone?; end

  # Since Symbol is immutable it cannot be duplicated.
  # For this reason #try_dup returns +self+.
  #
  #   :a.dup!  #=> :a
  #
  # source://facets//lib/core/facets/object/dup.rb#65
  def dup!; end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#66
  def dup?; end

  # Just like String#lchomp.
  #
  #   :ab.lchomp(:a)  #=> :b
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/symbol/chomp.rb#19
  def lchomp(seperator); end

  # Does a symbol have a "not" sign?
  #
  #   "friend".to_sym.not?   #=> false
  #   "~friend".to_sym.not?  #=> true
  #
  # CREDIT: Trans
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/symbol/not.rb#10
  def not?; end

  # Symbol does not end in `!`, `=`, or `?`.
  #
  #   :a.plain?   #=> true
  #   :a?.plain?  #=> false
  #   :a!.plain?  #=> false
  #   :a=.plain?  #=> false
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/symbol/plain.rb#10
  def plain?; end

  # Symbol ends in `?`.
  #
  #   :a?.query? #=> true
  #   :a.query?  #=> false
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/symbol/plain.rb#37
  def query?; end

  # Symbol does not end in `!`, `=`, or `?`.
  #
  #   :a.plain?   #=> true
  #   :a?.plain?  #=> false
  #   :a!.plain?  #=> false
  #   :a=.plain?  #=> false
  # Alias for `#plain?` method. Likely this should have been the original
  # and only name, but such is life.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/symbol/plain.rb#17
  def reader?; end

  # Symbol ends in `=`.
  #
  #   :a=.setter? #=> true
  #   :a.setter?  #=> false
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/symbol/plain.rb#24
  def setter?; end

  # Returns truew if the given block throws the symbol, otherwise false.
  # Note that +throw+ inside the block must be used in one-argument form.
  #
  # @return [true, false]
  #
  # source://facets//lib/core/facets/symbol/thrown.rb#7
  def thrown?; end

  # Prepend an "@" to the beginning of a symbol to make a instance
  # variable name. This also replaces non-valid characters with underscores.
  #
  #   :a.variablize  #=> :"@a"
  #
  # source://facets//lib/core/facets/symbol/variablize.rb#8
  def variablize; end

  # Symbol ends in `=`.
  #
  #   :a=.setter? #=> true
  #   :a.setter?  #=> false
  # Alias for `#setter?` method. Likely this should have been the original
  # and only name, but such is life.
  #
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/symbol/plain.rb#30
  def writer?; end

  # source://facets//lib/core/facets/symbol/not.rb#20
  def ~; end

  class << self
    # Generate a unique symbol.
    #
    #   Symbol.generate  #=> :"-1"
    #
    # If +key+ is given the new symbol will be prefixed with it.
    #
    #   Symbol.generate(:foo)  #=> :"foo-1"
    #
    # TODO: Is the generated symbol format acceptable?
    #
    # CREDIT: Trans
    #
    # source://facets//lib/core/facets/symbol/generate.rb#15
    def generate(key = T.unsafe(nil)); end
  end
end

# source://facets//lib/core/facets/time/set.rb#1
class Time
  include ::Comparable

  # Returns a new Time where one or more of the elements
  # have been changed according to the +options+ parameter.
  # The time options (hour, minute, sec, usec) reset
  # cascadingly, so if only the hour is passed, then
  # minute, sec, and usec is set to 0. If the hour and
  # minute is passed, then sec and usec is set to 0.
  #
  #   t1 = Time.at(10000)
  #   t1.ctime   #=> "Wed Dec 31 21:46:40 1969"
  #
  #   t2 = t1.change(:hour => 11)
  #   t2.ctime   #=> "Wed Dec 31 11:00:00 1969"
  #
  # source://facets//lib/core/facets/time/change.rb#16
  def change(options); end

  # Adjust DST
  #
  # TODO: Can't seem to get this to pass ActiveSupport tests,
  # even though it is essentially identical to the ActiveSupport
  # code (see Time#since in time/calculations.rb). It handles
  # all but 4 tests.
  #
  # source://facets//lib/core/facets/time/dst_adjustment.rb#11
  def dst_adjustment(time); end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/time/future.rb#11
  def future?(other = T.unsafe(nil)); end

  # Returns a new Time representing the time shifted by the time-units given.
  # Positive number shift the time forward, negative number shift the time
  # backward.
  #
  #   t = Time.utc(2010,10,10,0,0,0)
  #   t.shift( 4, :days)            #=>  Time.utc(2010,10,14,0,0,0)
  #   t.shift(-4, :days)            #=>  Time.utc(2010,10,6,0,0,0)
  #
  # More than one unit of time can be given.
  #
  #   t.shift(4, :days, 3, :hours)  #=>  Time.utc(2010,10,14,3,0,0)
  #
  # The #shift method can also take a hash.
  #
  #   t.shift(:days=>4, :hours=>3)  #=>  Time.utc(2010,10,14,3,0,0)
  # Alias for #shift.
  #
  # source://facets//lib/core/facets/time/shift.rb#70
  def hence(*time_units); end

  # Returns a new Time representing the time shifted by the time-units given.
  # Positive number shift the time forward, negative number shift the time
  # backward.
  #
  #   t = Time.utc(2010,10,10,0,0,0)
  #   t.shift( 4, :days)            #=>  Time.utc(2010,10,14,0,0,0)
  #   t.shift(-4, :days)            #=>  Time.utc(2010,10,6,0,0,0)
  #
  # More than one unit of time can be given.
  #
  #   t.shift(4, :days, 3, :hours)  #=>  Time.utc(2010,10,14,3,0,0)
  #
  # The #shift method can also take a hash.
  #
  #   t.shift(:days=>4, :hours=>3)  #=>  Time.utc(2010,10,14,3,0,0)
  # Alias for #shift.
  #
  # source://facets//lib/core/facets/time/shift.rb#67
  def in(*time_units); end

  # Returns a new Time representing the time a number of time-units ago.
  # This is just like #shift, but reverses the direction.
  #
  #   t = Time.utc(2010,10,10,0,0,0)
  #
  #   t.less(4, :days)             #=>  Time.utc(2010,10,6,0,0,0)
  #
  # source://facets//lib/core/facets/time/shift.rb#79
  def less(*time_units); end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/time/future.rb#7
  def past?(other = T.unsafe(nil)); end

  # Round time at the nearest range (in seconds).
  #
  #   t1 = Time.now
  #   t2 = t1.round_to(60*60)
  #   t2.min #=> 0
  #   t2.sec #=> 0
  #
  # TODO: What about `round(:minute)`?
  #
  # TODO: Fractional seconds should round the usec.
  #
  # source://facets//lib/core/facets/time/round_to.rb#16
  def round_to(seconds); end

  # Like change but does not reset earlier times.
  #
  # NOTE: It would be better, probably if this were called "change".
  # and that #change were called "reset".
  #
  # source://facets//lib/core/facets/time/set.rb#8
  def set(options); end

  # Returns a new Time representing the time shifted by the time-units given.
  # Positive number shift the time forward, negative number shift the time
  # backward.
  #
  #   t = Time.utc(2010,10,10,0,0,0)
  #   t.shift( 4, :days)            #=>  Time.utc(2010,10,14,0,0,0)
  #   t.shift(-4, :days)            #=>  Time.utc(2010,10,6,0,0,0)
  #
  # More than one unit of time can be given.
  #
  #   t.shift(4, :days, 3, :hours)  #=>  Time.utc(2010,10,14,3,0,0)
  #
  # The #shift method can also take a hash.
  #
  #   t.shift(:days=>4, :hours=>3)  #=>  Time.utc(2010,10,14,3,0,0)
  #
  # source://facets//lib/core/facets/time/shift.rb#24
  def shift(*time_units); end

  # Create a time stamp.
  #
  #   t = Time.at(10000)
  #   t.stamp(:short)    #=> "31 Dec 21:46"
  #
  # Supported formats come from the Time::FORMAT constant.
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/time/stamp.rb#39
  def stamp(fmt = T.unsafe(nil)); end

  # Truncate time at give range (in seconds).
  #
  #   t = Time.now
  #   t = t.trunc(60*60)
  #   t.min #=> 0
  #   t.sec #=> 0
  #
  # source://facets//lib/core/facets/time/trunc.rb#10
  def trunc(amount); end

  class << self
    # source://facets//lib/core/facets/time/future.rb#3
    def current; end

    # Tracks the elapse time of a code block.
    #
    #   e = Time.elapse { sleep 1 }
    #
    #   e.assert > 1
    #
    # CREDIT: Hal Fulton
    #
    # source://facets//lib/core/facets/time/elapse.rb#11
    def elapse; end

    # Produce time stamp for Time.now. See #stamp.
    #
    # CREDIT: Trans
    #
    # source://facets//lib/core/facets/time/stamp.rb#26
    def stamp(*args); end
  end
end

# source://facets//lib/core/facets/time/stamp.rb#5
Time::FORMAT = T.let(T.unsafe(nil), Hash)

# source://facets//lib/core/facets/boolean.rb#38
class TrueClass
  # @return [Boolean]
  #
  # source://facets//lib/core/facets/kernel/blank.rb#56
  def blank?; end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#56
  def clone?; end

  # Since TrueClass is immutable it cannot be duplicated.
  # For this reason #try_dup returns +self+.
  #
  #   true.dup!  #=> true
  #
  # source://facets//lib/core/facets/object/dup.rb#54
  def dup!; end

  # @return [Boolean]
  #
  # source://facets//lib/core/facets/object/dup.rb#55
  def dup?; end

  # source://facets//lib/core/facets/boolean.rb#39
  def to_bool; end
end

URI::Hash = Hash
URI::Kernel = Kernel

# source://facets//lib/core/facets/unboundmethod/arguments.rb#1
class UnboundMethod
  # Resolves the arguments of the method to have an
  # identical signiture --useful for preserving arity.
  #
  #   class X
  #     def foo(a, b); end
  #     def bar(a, b=1); end
  #   end
  #
  #   foo_method = X.instance_method(:foo)
  #   foo_method.arguments   #=> "a0, a1"
  #
  #   bar_method = X.instance_method(:bar)
  #   bar_method.arguments   #=> "a0, *args"
  #
  # When defaults are used the arguments must end in "*args".
  #
  # CREDIT: Trans
  #
  # source://facets//lib/core/facets/unboundmethod/arguments.rb#21
  def arguments; end
end

class Zlib::GzipReader < ::Zlib::GzipFile
  include ::Enumerable
end

class Zlib::InProgressError < ::Zlib::Error; end
