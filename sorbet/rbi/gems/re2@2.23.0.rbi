# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `re2` gem.
# Please instead update this file by running `bin/tapioca gem re2`.


# source://re2//lib/re2/regexp.rb#12
module RE2
  private

  # source://re2//lib/re2.rb#13
  def GlobalReplace(_arg0, _arg1, _arg2); end

  # source://re2//lib/re2.rb#13
  def QuoteMeta(_arg0); end

  # source://re2//lib/re2.rb#13
  def Replace(_arg0, _arg1, _arg2); end

  class << self
    # source://re2//lib/re2.rb#13
    def GlobalReplace(_arg0, _arg1, _arg2); end

    # source://re2//lib/re2.rb#13
    def QuoteMeta(_arg0); end

    # source://re2//lib/re2.rb#13
    def Replace(_arg0, _arg1, _arg2); end
  end
end

class RE2::MatchData
  # source://re2//lib/re2.rb#13
  def [](*_arg0); end

  # source://re2//lib/re2.rb#13
  def begin(_arg0); end

  # source://re2//lib/re2.rb#13
  def deconstruct; end

  # source://re2//lib/re2.rb#13
  def deconstruct_keys(_arg0); end

  # source://re2//lib/re2.rb#13
  def end(_arg0); end

  # source://re2//lib/re2.rb#13
  def inspect; end

  # source://re2//lib/re2.rb#13
  def length; end

  # source://re2//lib/re2.rb#13
  def regexp; end

  # source://re2//lib/re2.rb#13
  def size; end

  # source://re2//lib/re2.rb#13
  def string; end

  # source://re2//lib/re2.rb#13
  def to_a; end

  # source://re2//lib/re2.rb#13
  def to_s; end
end

# source://re2//lib/re2/regexp.rb#13
class RE2::Regexp
  # source://re2//lib/re2.rb#13
  def initialize(*_arg0); end

  # source://re2//lib/re2.rb#13
  def ===(_arg0); end

  # source://re2//lib/re2.rb#13
  def =~(_arg0); end

  # source://re2//lib/re2.rb#13
  def case_insensitive?; end

  # source://re2//lib/re2.rb#13
  def case_sensitive?; end

  # source://re2//lib/re2.rb#13
  def casefold?; end

  # source://re2//lib/re2.rb#13
  def error; end

  # source://re2//lib/re2.rb#13
  def error_arg; end

  # Match the pattern against the given `text` exactly and return a
  # {RE2::MatchData} instance with the specified number of submatches
  # (defaults to the total number of capturing groups) or a boolean (if no
  # submatches are required).
  #
  # The number of submatches has a significant impact on performance: requesting
  # one submatch is much faster than requesting more than one and requesting
  # zero submatches is faster still.
  #
  # @example
  #   r = RE2::Regexp.new('w(o)(o)')
  #   r.full_match('woo')                #=> #<RE2::MatchData "woo" 1:"o" 2:"o">
  #   r.full_match('woot')               #=> nil
  #   r.full_match('woo', submatches: 1) #=> #<RE2::MatchData "woo" 1:"o">
  #   r.full_match('woo', submatches: 0) #=> true
  # @option options
  # @param options [Hash] the options with which to perform the match
  # @param text [String] the text to search
  # @raise [ArgumentError] if given a negative number of submatches
  # @raise [NoMemoryError] if there was not enough memory to allocate the
  #   matches
  # @raise [TypeError] if given non-numeric submatches or non-hash options
  # @return [RE2::MatchData, nil] if extracting any submatches
  # @return [Boolean] if not extracting any submatches
  #
  # source://re2//lib/re2/regexp.rb#68
  def full_match(text, options = T.unsafe(nil)); end

  # source://re2//lib/re2.rb#13
  def full_match?(_arg0); end

  # source://re2//lib/re2.rb#13
  def inspect; end

  # source://re2//lib/re2.rb#13
  def literal?; end

  # source://re2//lib/re2.rb#13
  def log_errors?; end

  # source://re2//lib/re2.rb#13
  def longest_match?; end

  # source://re2//lib/re2.rb#13
  def match(*_arg0); end

  # source://re2//lib/re2.rb#13
  def match?(_arg0); end

  # source://re2//lib/re2.rb#13
  def max_mem; end

  # source://re2//lib/re2.rb#13
  def named_capturing_groups; end

  # source://re2//lib/re2.rb#13
  def never_nl?; end

  # source://re2//lib/re2.rb#13
  def number_of_capturing_groups; end

  # source://re2//lib/re2.rb#13
  def ok?; end

  # source://re2//lib/re2.rb#13
  def one_line?; end

  # source://re2//lib/re2.rb#13
  def options; end

  # Match the pattern against any substring of the given `text` and return a
  # {RE2::MatchData} instance with the specified number of submatches
  # (defaults to the total number of capturing groups) or a boolean (if no
  # submatches are required).
  #
  # The number of submatches has a significant impact on performance: requesting
  # one submatch is much faster than requesting more than one and requesting
  # zero submatches is faster still.
  #
  # @example
  #   r = RE2::Regexp.new('w(o)(o)')
  #   r.partial_match('woot')                #=> #<RE2::MatchData "woo" 1:"o" 2:"o">
  #   r.partial_match('nope')                #=> nil
  #   r.partial_match('woot', submatches: 1) #=> #<RE2::MatchData "woo" 1:"o">
  #   r.partial_match('woot', submatches: 0) #=> true
  # @option options
  # @param options [Hash] the options with which to perform the match
  # @param text [String] the text to search
  # @raise [ArgumentError] if given a negative number of submatches
  # @raise [NoMemoryError] if there was not enough memory to allocate the
  #   matches
  # @raise [TypeError] if given non-numeric submatches or non-hash options
  # @return [RE2::MatchData, nil] if extracting any submatches
  # @return [Boolean] if not extracting any submatches
  #
  # source://re2//lib/re2/regexp.rb#39
  def partial_match(text, options = T.unsafe(nil)); end

  # source://re2//lib/re2.rb#13
  def partial_match?(_arg0); end

  # source://re2//lib/re2.rb#13
  def pattern; end

  # source://re2//lib/re2.rb#13
  def perl_classes?; end

  # source://re2//lib/re2.rb#13
  def posix_syntax?; end

  # source://re2//lib/re2.rb#13
  def program_size; end

  # source://re2//lib/re2.rb#13
  def scan(_arg0); end

  # source://re2//lib/re2.rb#13
  def source; end

  # source://re2//lib/re2.rb#13
  def to_s; end

  # source://re2//lib/re2.rb#13
  def to_str; end

  # source://re2//lib/re2.rb#13
  def utf8?; end

  # source://re2//lib/re2.rb#13
  def word_boundary?; end

  class << self
    # source://re2//lib/re2.rb#13
    def compile(*_arg0); end

    # source://re2//lib/re2.rb#13
    def escape(_arg0); end

    # source://re2//lib/re2.rb#13
    def match_has_endpos_argument?; end

    # source://re2//lib/re2.rb#13
    def quote(_arg0); end
  end
end

class RE2::Regexp::UnsupportedError < ::StandardError; end

# source://re2//lib/re2/scanner.rb#13
class RE2::Scanner
  include ::Enumerable

  # source://re2//lib/re2/scanner.rb#16
  def each; end

  # source://re2//lib/re2.rb#13
  def eof?; end

  # source://re2//lib/re2.rb#13
  def regexp; end

  # source://re2//lib/re2.rb#13
  def rewind; end

  # source://re2//lib/re2.rb#13
  def scan; end

  # source://re2//lib/re2.rb#13
  def string; end
end

class RE2::Set
  # source://re2//lib/re2.rb#13
  def initialize(*_arg0); end

  # source://re2//lib/re2.rb#13
  def add(_arg0); end

  # source://re2//lib/re2.rb#13
  def compile; end

  # source://re2//lib/re2.rb#13
  def length; end

  # source://re2//lib/re2.rb#13
  def match(*_arg0); end

  # source://re2//lib/re2.rb#13
  def size; end

  class << self
    # source://re2//lib/re2.rb#13
    def match_raises_errors?; end

    # source://re2//lib/re2.rb#13
    def size?; end
  end
end

class RE2::Set::MatchError < ::StandardError; end
class RE2::Set::UnsupportedError < ::StandardError; end

# source://re2//lib/re2/version.rb#13
RE2::VERSION = T.let(T.unsafe(nil), String)
