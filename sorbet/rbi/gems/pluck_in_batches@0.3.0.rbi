# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pluck_in_batches` gem.
# Please instead update this file by running `bin/tapioca gem pluck_in_batches`.


# source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#3
module PluckInBatches; end

# source://pluck_in_batches//lib/pluck_in_batches/extensions.rb#4
module PluckInBatches::Extensions; end

# source://pluck_in_batches//lib/pluck_in_batches/extensions.rb#5
module PluckInBatches::Extensions::ModelExtension
  # source://pluck_in_batches//lib/pluck_in_batches/extensions.rb#6
  def pluck_each(*_arg0, **_arg1, &_arg2); end

  # source://pluck_in_batches//lib/pluck_in_batches/extensions.rb#6
  def pluck_in_batches(*_arg0, **_arg1, &_arg2); end
end

# source://pluck_in_batches//lib/pluck_in_batches/extensions.rb#9
module PluckInBatches::Extensions::RelationExtension
  # Yields each set of values corresponding to the specified columns that was found
  # by the passed options. If one column specified - returns its value, if an array of columns -
  # returns an array of values.
  #
  # See #pluck_in_batches for all the details.
  #
  # source://pluck_in_batches//lib/pluck_in_batches/extensions.rb#16
  def pluck_each(*columns, start: T.unsafe(nil), finish: T.unsafe(nil), of: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil), cursor_column: T.unsafe(nil), &block); end

  # Yields each batch of values corresponding to the specified columns that was found
  # by the passed options as an array.
  #
  #   User.where("age > 21").pluck_in_batches(:email) do |emails|
  #     jobs = emails.map { |email| PartyReminderJob.new(email) }
  #     ActiveJob.perform_all_later(jobs)
  #   end
  #
  # If you do not provide a block to #pluck_in_batches, it will return an Enumerator
  # for chaining with other methods:
  #
  #   User.pluck_in_batches(:name, :email).with_index do |group, index|
  #     puts "Processing group ##{index}"
  #     jobs = group.map { |name, email| PartyReminderJob.new(name, email) }
  #     ActiveJob.perform_all_later(jobs)
  #   end
  #
  # ==== Options
  # * <tt>:batch_size</tt> - Specifies the size of the batch. Defaults to 1000.
  # * <tt>:of</tt> - Same as +:batch_size+.
  # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
  # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
  # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
  #   an order is present in the relation.
  # * <tt>:cursor_column</tt> - Specifies the column(s) on which the iteration should be done.
  #   This column(s) should be orderable (e.g. an integer or string). Defaults to primary key.
  # * <tt>:order</tt> - Specifies the cursor column(s) order (can be +:asc+ or +:desc+ or an array consisting
  #   of :asc or :desc). Defaults to +:asc+.
  #
  #     class Book < ActiveRecord::Base
  #       self.primary_key = [:author_id, :version]
  #     end
  #
  #     Book.pluck_in_batches(:title, order: [:asc, :desc])
  #
  #   In the above code, +author_id+ is sorted in ascending order and +version+ in descending order.
  #
  # Limits are honored, and if present there is no requirement for the batch
  # size: it can be less than, equal to, or greater than the limit.
  #
  # The options +start+ and +finish+ are especially useful if you want
  # multiple workers dealing with the same processing queue. You can make
  # worker 1 handle all the records between id 1 and 9999 and worker 2
  # handle from 10000 and beyond by setting the +:start+ and +:finish+
  # option on each worker.
  #
  #   # Let's process from record 10_000 on.
  #   User.pluck_in_batches(:email, start: 10_000) do |emails|
  #     jobs = emails.map { |email| PartyReminderJob.new(email) }
  #     ActiveJob.perform_all_later(jobs)
  #   end
  #
  # NOTE: Order can be ascending (:asc) or descending (:desc). It is automatically set to
  # ascending on the primary key ("id ASC").
  # This also means that this method only works when the primary key is
  # orderable (e.g. an integer or string).
  #
  # NOTE: By its nature, batch processing is subject to race conditions if
  # other processes are modifying the database.
  #
  # source://pluck_in_batches//lib/pluck_in_batches/extensions.rb#81
  def pluck_in_batches(*columns, start: T.unsafe(nil), finish: T.unsafe(nil), of: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), cursor_column: T.unsafe(nil), order: T.unsafe(nil), &block); end
end

# source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#4
class PluckInBatches::Iterator
  # @return [Iterator] a new instance of Iterator
  #
  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#8
  def initialize(relation); end

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#13
  def each(*columns, start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), cursor_column: T.unsafe(nil), order: T.unsafe(nil), &block); end

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#29
  def each_batch(*columns, start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), cursor_column: T.unsafe(nil), order: T.unsafe(nil)); end

  private

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#132
  def act_on_ignored_order(error_on_ignore); end

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#166
  def apply_finish_limit(relation, columns, finish, batch_orders); end

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#153
  def apply_limits(relation, columns, start, finish, batch_orders); end

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#159
  def apply_start_limit(relation, columns, start, batch_orders); end

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#198
  def ar_version; end

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#173
  def batch_condition(relation, columns, values, operators); end

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#188
  def build_attribute_predicate(column, value, operator); end

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#192
  def build_batch_orders(cursor_columns, order); end

  # source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#124
  def cursor_column_indexes(columns, cursor_column); end
end

# source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#6
PluckInBatches::Iterator::DEFAULT_ORDER = T.let(T.unsafe(nil), Symbol)

# source://pluck_in_batches//lib/pluck_in_batches/iterator.rb#5
PluckInBatches::Iterator::VALID_ORDERS = T.let(T.unsafe(nil), Array)

# source://pluck_in_batches//lib/pluck_in_batches/version.rb#4
PluckInBatches::VERSION = T.let(T.unsafe(nil), String)
