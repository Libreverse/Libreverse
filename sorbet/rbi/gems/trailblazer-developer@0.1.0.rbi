# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `trailblazer-developer` gem.
# Please instead update this file by running `bin/tapioca gem trailblazer-developer`.


# NOTE: The Graph API might get deprecated and replaced.
#
# source://trailblazer-developer//lib/trailblazer/developer/version.rb#1
module Trailblazer; end

# Operation-specific circuit rendering. This is optimized for a linear railway circuit.
#
# NOTE: this is absolutely to be considered as prototyping and acts more like a test helper ATM as
#
# @private
#
# source://trailblazer-developer//lib/trailblazer/developer.rb#4
module Trailblazer::Developer
  private

  # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#5
  def render(activity, path: T.unsafe(nil), **options); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#4
  def wtf(activity, *args, **circuit_options); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#9
    def railway(*args, **kws); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/circuit.rb#5
    def render(activity, path: T.unsafe(nil), **options); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#4
    def wtf(activity, *args, **circuit_options); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#9
    def wtf?(activity, *args, **circuit_options); end
  end
end

# Code in Debugger is only executed if the user wants to render the stack.
#
# source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#4
module Trailblazer::Developer::Debugger
  class << self
    # Public entry point to add Debugger::Node normalizer steps.
    #
    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/debugger/normalizer.rb#6
    def add_normalizer_step!(step, id:, normalizer: T.unsafe(nil), **options); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#5
Trailblazer::Developer::Debugger::ATTRS = T.let(T.unsafe(nil), Array)

# The {Debugger::Node} is an abstraction between Trace::Node and the actual rendering layer (why?)
#
# TODO: class, "type",
# which track, return signal, etc
#
# source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#25
class Trailblazer::Developer::Debugger::Node < ::Struct
  class << self
    # we always key options for specific nodes by Stack::Captured::Input, so we don't confuse activities if they were called multiple times.
    #
    # @return [Debugger::Node] array of Debugger::Node
    #
    # source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#29
    def build(trace_nodes, node_options: T.unsafe(nil), normalizer: T.unsafe(nil), **options_for_nodes); end
  end
end

# TODO: remove once macro is 2.2
#
# source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#59
class Trailblazer::Developer::Debugger::Node::DeprecatedCapturedNode
  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#60
    def method_missing(*_arg0); end
  end
end

# Run at runtime when preparing a Trace::Nodes for presentation.
#
# source://trailblazer-developer//lib/trailblazer/developer/debugger/normalizer.rb#19
module Trailblazer::Developer::Debugger::Normalizer
  class << self
    # TODO: we could keep this in the {activity} gem.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/debugger/normalizer.rb#20
    def Task(user_step); end
  end
end

# Default steps for the Debugger::Node options pipeline, following the step-interface.
#
# source://trailblazer-developer//lib/trailblazer/developer/debugger/normalizer.rb#25
module Trailblazer::Developer::Debugger::Normalizer::Default
  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/debugger/normalizer.rb#26
    def compile_id(ctx, activity:, task:, **_arg3); end

    # source://trailblazer-developer//lib/trailblazer/developer/debugger/normalizer.rb#38
    def data(ctx, data: T.unsafe(nil), **_arg2); end

    # @return [Boolean]
    #
    # source://trailblazer-developer//lib/trailblazer/developer/debugger/normalizer.rb#42
    def incomplete?(ctx, trace_node:, **_arg2); end

    # source://trailblazer-developer//lib/trailblazer/developer/debugger/normalizer.rb#34
    def label(ctx, runtime_id:, label: T.unsafe(nil), **_arg3); end

    # source://trailblazer-developer//lib/trailblazer/developer/debugger/normalizer.rb#30
    def runtime_id(ctx, compile_id:, **_arg2); end
  end
end

# we do mutate this constant at compile-time. Maybe # DISCUSS and find a better way.
#
# source://trailblazer-developer//lib/trailblazer/developer/debugger/normalizer.rb#56
Trailblazer::Developer::Debugger::Normalizer::PIPELINES = T.let(T.unsafe(nil), Array)

# Interface for data (nodes, versions, etc) between tracing code and presentation layer.
# We have no concept of {Stack} here anymore. Nodes and arbitrary objects such as "versions".
# Debugger::Trace interface abstracts away the fact we have two snapshots. Here,
# we only have a node per task.
#
# source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#71
class Trailblazer::Developer::Debugger::Trace
  # @return [Trace] a new instance of Trace
  #
  # source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#83
  def initialize(nodes:, variable_versions:); end

  # source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#91
  def to_a; end

  # source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#87
  def to_h; end

  class << self
    # Called in {Trace::Present}.
    # Design note: goal here is to have as little computation as possible.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/debugger.rb#74
    def build(stack, trace_nodes, **options_for_debugger_nodes); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/introspect.rb#3
module Trailblazer::Developer::Introspect
  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#78
    def Graph(*args); end

    # find the path for Strategy subclasses.
    # FIXME: will be removed
    #
    # source://trailblazer-developer//lib/trailblazer/developer/introspect.rb#6
    def find_path(activity_class, segments); end
  end
end

# TODO: Remove Graph. This is only useful to render the full circuit
# Some thoughts here:
# * where do we need Schema.outputs? and where task.outputs?
#
# @private This API is still under construction.
#
# source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#13
class Trailblazer::Developer::Introspect::Graph
  # @return [Graph] a new instance of Graph
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#14
  def initialize(activity); end

  # TODO: convert to {#to_a}.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#28
  def collect(strategy: T.unsafe(nil)); end

  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#21
  def find(id = T.unsafe(nil), &block); end

  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#32
  def stop_events; end

  private

  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#60
  def Node(*args); end

  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#38
  def find_by_id(id); end

  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#43
  def find_with_block; end

  # Build a {Graph::Node} with outputs etc.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#50
  def node_for(node_attributes); end

  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#67
  def outgoings_for(node); end
end

# source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
class Trailblazer::Developer::Introspect::Graph::Node < ::Struct
  # Returns the value of attribute data
  #
  # @return [Object] the current value of data
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
  def data; end

  # Sets the attribute data
  #
  # @param value [Object] the value to set the attribute data to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
  def data=(_); end

  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
  def id=(_); end

  # Returns the value of attribute outgoings
  #
  # @return [Object] the current value of outgoings
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
  def outgoings; end

  # Sets the attribute outgoings
  #
  # @param value [Object] the value to set the attribute outgoings to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
  def outgoings=(_); end

  # Returns the value of attribute outputs
  #
  # @return [Object] the current value of outputs
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
  def outputs; end

  # Sets the attribute outputs
  #
  # @param value [Object] the value to set the attribute outputs to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
  def outputs=(_); end

  # Returns the value of attribute task
  #
  # @return [Object] the current value of task
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
  def task; end

  # Sets the attribute task
  #
  # @param value [Object] the value to set the attribute task to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
  def task=(_); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
    def [](*_arg0); end

    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
    def inspect; end

    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
    def keyword_init?; end

    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
    def members; end

    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#64
    def new(*_arg0); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#65
class Trailblazer::Developer::Introspect::Graph::Outgoing < ::Struct
  # Returns the value of attribute output
  #
  # @return [Object] the current value of output
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#65
  def output; end

  # Sets the attribute output
  #
  # @param value [Object] the value to set the attribute output to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#65
  def output=(_); end

  # Returns the value of attribute task
  #
  # @return [Object] the current value of task
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#65
  def task; end

  # Sets the attribute task
  #
  # @param value [Object] the value to set the attribute task to.
  # @return [Object] the newly set value
  #
  # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#65
  def task=(_); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#65
    def [](*_arg0); end

    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#65
    def inspect; end

    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#65
    def keyword_init?; end

    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#65
    def members; end

    # source://trailblazer-developer//lib/trailblazer/developer/introspect/graph.rb#65
    def new(*_arg0); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#13
module Trailblazer::Developer::Render; end

# source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#14
module Trailblazer::Developer::Render::Linear
  private

  # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#17
  def call(operation, style: T.unsafe(nil)); end

  # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#35
  def inspect_func(step); end

  # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#41
  def inspect_line(names); end

  # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#46
  def inspect_rows(names); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#17
    def call(operation, style: T.unsafe(nil)); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#35
    def inspect_func(step); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#41
    def inspect_line(names); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#46
    def inspect_rows(names); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/render/linear.rb#39
Trailblazer::Developer::Render::Linear::Operator = T.let(T.unsafe(nil), Hash)

# source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#4
module Trailblazer::Developer::Render::TaskWrap
  class << self
    # @param activity Trailblazer::Activity
    #
    # source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#6
    def render_for(activity, node); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#48
    def render_input(row, level); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#24
    def render_pipeline(pipeline, level); end

    # source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#42
    def render_task_wrap_step(row, level); end

    # @param activity Activity
    #
    # source://trailblazer-developer//lib/trailblazer/developer/render/task_wrap.rb#20
    def task_wrap_for_activity(activity, **_arg1); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot.rb#2
module Trailblazer::Developer::Trace
  private

  # It's important to understand that {flow[:stack]} is mutated by design. This is needed so
  # in case of exceptions we still have a "global" trace - unfortunately Ruby doesn't allow
  # us a better way.
  # taskWrap step to capture incoming arguments of a step.
  #
  # Note that we save the created {Snapshot::Before} in the wrap_ctx.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#56
  def capture_args(wrap_config, original_args); end

  # taskWrap step to capture outgoing arguments from a step.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#68
  def capture_return(wrap_config, _arg1); end

  # @private
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#43
  def task_wrap_extensions; end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#17
    def arguments_for_call(activity, _arg1, **original_circuit_options); end

    # Build array of {Trace::Node} from a snapshots stack.
    #
    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/node.rb#6
    def build_nodes(snapshots); end

    # Public entry point to run an activity with tracing.
    # It returns the accumulated stack of Snapshots, along with the original return values.
    # Note that {Trace.invoke} does not do any rendering.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#7
    def call(activity, _arg1, **circuit_options); end

    # It's important to understand that {flow[:stack]} is mutated by design. This is needed so
    # in case of exceptions we still have a "global" trace - unfortunately Ruby doesn't allow
    # us a better way.
    # taskWrap step to capture incoming arguments of a step.
    #
    # Note that we save the created {Snapshot::Before} in the wrap_ctx.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#56
    def capture_args(wrap_config, original_args); end

    # taskWrap step to capture outgoing arguments from a step.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#68
    def capture_return(wrap_config, _arg1); end

    # Public entry point to run an activity with tracing.
    # It returns the accumulated stack of Snapshots, along with the original return values.
    # Note that {Trace.invoke} does not do any rendering.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#15
    def invoke(activity, _arg1, **circuit_options); end

    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#43
    def task_wrap_extensions; end

    # source://trailblazer-developer//lib/trailblazer/developer/trace.rb#38
    def value_snapshooter; end
  end
end

# FIXME: deprecate constant!
#
# source://trailblazer-developer//lib/trailblazer/developer.rb#27
Trailblazer::Developer::Trace::Debugger = Trailblazer::Developer::Debugger

# Datastructure representing a trace.
#
# source://trailblazer-developer//lib/trailblazer/developer/trace/node.rb#15
class Trailblazer::Developer::Trace::Node < ::Struct
  class << self
    # Called per snapshot_before   "process_branch"
    # 1. Find, for snapshot_before, the matching snapshot_after in the stack
    # 2. Extract snapshots inbetween those two. These are min. 1 level deeper in!
    # 3. Run process_siblings for 2.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/node.rb#60
    def node_and_instructions_for(snapshot_before, descendants, level:); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/node.rb#19
    def pop_from_instructions!(instructions); end

    # def self.BLA(instructions)
    #   instructions.collect do |(level, remaining_snapshots)|
    #     [
    #       level,
    #       remaining_snapshots.collect { |snap| [snap.class, snap.task] }
    #     ]
    #   end
    # end
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/node.rb#39
    def process_instructions(instructions); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/trace/node.rb#16
class Trailblazer::Developer::Trace::Node::Incomplete < ::Trailblazer::Developer::Trace::Node; end

# Map each {Node} instance to its parent {Node}.
#
# source://trailblazer-developer//lib/trailblazer/developer/trace/parent_map.rb#5
module Trailblazer::Developer::Trace::ParentMap
  class << self
    # DISCUSS: where does this belong?
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/parent_map.rb#6
    def build(trace_nodes); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/parent_map.rb#17
    def path_for(parent_map, node); end
  end
end

# DISCUSS: rename to Debugger?
#
# source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#5
module Trailblazer::Developer::Trace::Present
  private

  # Entry point for rendering a {Trace::Stack}.
  # Used in `#wtf?`.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#25
  def call(stack, render_method: T.unsafe(nil), **options, &block); end

  # @private
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#9
  def default_renderer(debugger_node:, **_arg1); end

  # TODO: remove in 0.2.0.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#57
  def deprecate_node_options!(node_options: T.unsafe(nil), **_arg1); end

  # @private
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#65
  def merge_local_options(options, local_options); end

  # Returns the console output string.
  #
  # @private
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#15
  def render(debugger_trace:, renderer: T.unsafe(nil), **options_for_renderer); end

  class << self
    # Entry point for rendering a {Trace::Stack}.
    # Used in `#wtf?`.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#25
    def call(stack, render_method: T.unsafe(nil), **options, &block); end

    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#9
    def default_renderer(debugger_node:, **_arg1); end

    # TODO: remove in 0.2.0.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#57
    def deprecate_node_options!(node_options: T.unsafe(nil), **_arg1); end

    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#65
    def merge_local_options(options, local_options); end

    # Returns the console output string.
    #
    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/present.rb#15
    def render(debugger_trace:, renderer: T.unsafe(nil), **options_for_renderer); end
  end
end

# WARNING:  the interfaces here are subject to change, we're still experimenting
#           with the architecture of tracing, and a healthy balance of performance/memory
#           and clean design.
# A Snapshot comprises of data captured before of after a "step". This usually
# includes a ctx snapshot, variable versions and a returned signal for after-step
# snapshots.
#
# Note that {Before} and {After} are generic concepts know to Trace::Present and Debugger.
#
# Snapshot::After{
#   signal: <End.Success>
#   ctx_snapshot: Snapshot::Ctx{
#     variable_versions: [:current_user, 0], [:model, 0]
#   }
# }
#
# source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot.rb#18
class Trailblazer::Developer::Trace::Snapshot < ::Struct
  class << self
    # Serialize all ctx variables at the very end of taskWrap, after Out().
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot.rb#49
    def after_snapshooter(wrap_ctx, _); end

    # Serialize all ctx variables before {call_task}.
    # This is run just before {call_task}, after In().
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot.rb#38
    def before_snapshooter(wrap_ctx, _arg1); end

    # This is called from {Trace.capture_args} and {Trace.capture_return} in the taskWrap.
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot.rb#23
    def call(ctx_snapshooter, wrap_config, _arg2); end

    # Snapshot::Ctx keeps an inspected version of each ctx variable.
    # We figure out if a variable has changed by using `variable.hash` (works
    # even with deeply nested structures).
    #
    # Key idea here is to have minimum work at operation-runtime. Specifics like
    # figuring out what has changed can be done when using the debugger.
    #
    # By keeping "old" versions, we get three benefits.
    # 1. We only need to call {inspect} once on a traced variable. Especially
    #    when variables are complex structures or strings, this dramatically speeds
    #    up tracing, from same-ish to factor 5!
    # 2. The content sent to our debugger is much smaller which reduces network load
    #    and storage space.
    # 3. Presentation becomes simpler as we "know" what variable has changed.
    #
    # Possible problems: when {variable.hash} returns the same key even though the
    #                    data has changed.
    #
    # DISCUSS: speed up by checking mutable, only?
    # DISCUSS: we currently only use this for testing.
    # DISCUSS: this has knowledge about {Stack} internals.
    #
    # This is for the "rendering" layer.
    #
    # @private
    #
    # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/versions.rb#28
    def snapshot_ctx_for(snapshot, variable_versions); end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot.rb#64
    def snapshot_for(ctx, value_snapshooter:, stack:, **_arg3); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot.rb#20
class Trailblazer::Developer::Trace::Snapshot::After < ::Trailblazer::Developer::Trace::Snapshot; end

# source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot.rb#19
class Trailblazer::Developer::Trace::Snapshot::Before < ::Trailblazer::Developer::Trace::Snapshot; end

# {Value} serializes the variable value using with custom logic, e.g. {value.inspect}.
# A series of matchers decide which snapshooter is used.
#
# source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/value.rb#6
class Trailblazer::Developer::Trace::Snapshot::Value
  # @return [Value] a new instance of Value
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/value.rb#7
  def initialize(matchers); end

  # DISCUSS: this could be a compiled pattern matching `case/in` block here.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/value.rb#12
  def call(name, value, **options); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/value.rb#26
    def build; end

    # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/value.rb#22
    def default_variable_inspect(name, value, ctx:); end
  end
end

# A table of all ctx variables, their hashes and serialized values.
#
#   {:current_user=>
#     {3298051090906520533=>"#<TraceTest::User:0x000055b2e3424460 @id=1>",
#      3764938782671692590=>"#<TraceTest::User:0x000055b2e33e45b8 @id=2>"},
#    :params=>
#     {2911818769466875657=>"{:name=>\"Q & I\"}",
#      2238394858183550663=>"{:name=>\"Q & I\", :song=>{...}}"},
#    :seq=>
#     {-105020188158523405=>"[]",
#      -2281497291400788995=>"[:authenticate]",
#      150926802063554866=>"[:authenticate, :authorize]",
#      3339595138798116233=>"[:authenticate, :authorize, :model]",
#      -3395325862879242711=>
#       "[:authenticate, :authorize, :model, :screw_params!]"},
#    :model=>{348183403054247453=>"Object"}}
#
# source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/versions.rb#58
class Trailblazer::Developer::Trace::Snapshot::Versions
  # @return [Versions] a new instance of Versions
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/versions.rb#59
  def initialize; end

  # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/versions.rb#86
  def add_changes!(new_versions); end

  # @private
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/versions.rb#93
  def add_variable_version!(name, hash, value); end

  # DISCUSS: problem with changeset is, we have to go through variables twice.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/versions.rb#64
  def changeset_for(ctx, value_snapshooter:); end

  # source://trailblazer-developer//lib/trailblazer/developer/trace/snapshot/versions.rb#99
  def to_h; end
end

# The stack is a linear one-dimensional array. Per traced task two {Trace::Captured}
# elements get pushed onto it (unless there's an Exception).
#
# The Stack object maintains the snapshots and the variable versions. It should probably
# be named "Trace" :D
# It is by design coupled to both Snapshot and Ctx::Versions.
#
# source://trailblazer-developer//lib/trailblazer/developer/trace/stack.rb#10
class Trailblazer::Developer::Trace::Stack
  # @return [Stack] a new instance of Stack
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/stack.rb#11
  def initialize(snapshots = T.unsafe(nil), variable_versions = T.unsafe(nil)); end

  # source://trailblazer-developer//lib/trailblazer/developer/trace/stack.rb#18
  def add!(snapshot, new_variable_versions); end

  # source://trailblazer-developer//lib/trailblazer/developer/trace/stack.rb#28
  def to_a; end

  # TODO: the accessor sucks. But I guess to_h[:variable_versions] is slower.
  #
  # source://trailblazer-developer//lib/trailblazer/developer/trace/stack.rb#16
  def variable_versions; end
end

# Insertions for the trace tasks that capture the arguments just before calling the task,
# and before the TaskWrap is finished.
#
# source://trailblazer-developer//lib/trailblazer/developer/trace.rb#80
Trailblazer::Developer::Trace::TASK_WRAP_EXTENSION = T.let(T.unsafe(nil), Trailblazer::Activity::TaskWrap::Extension)

# source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#12
module Trailblazer::Developer::Wtf
  private

  # Run {activity} with tracing enabled and inject a mutable {Stack} instance.
  # This allows to display the trace even when an exception happened
  #
  # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#17
  def invoke(activity, _arg1, present_options: T.unsafe(nil), **circuit_options); end

  class << self
    # Run {activity} with tracing enabled and inject a mutable {Stack} instance.
    # This allows to display the trace even when an exception happened
    #
    # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#17
    def invoke(activity, _arg1, present_options: T.unsafe(nil), **circuit_options); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#69
module Trailblazer::Developer::Wtf::Exception
  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/wtf.rb#70
    def find_exception_source(stack, exception); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#4
module Trailblazer::Developer::Wtf::Renderer
  private

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#30
  def apply_style(label, debugger_node, style:, **_arg3); end

  # {options} can be {style: {#<Debugger::Node> => [:red, :bold]}}
  #
  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#18
  def call(debugger_trace:, debugger_node:, style: T.unsafe(nil), **options); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#37
  def fmt(line, style); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#45
  def signal_of(debugger_node); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#24
  def styled_label(debugger_trace, debugger_node, color_map:, **options); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#30
    def apply_style(label, debugger_node, style:, **_arg3); end

    # {options} can be {style: {#<Debugger::Node> => [:red, :bold]}}
    #
    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#18
    def call(debugger_trace:, debugger_node:, style: T.unsafe(nil), **options); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#37
    def fmt(line, style); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#45
    def signal_of(debugger_node); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#24
    def styled_label(debugger_trace, debugger_node, color_map:, **options); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#5
Trailblazer::Developer::Wtf::Renderer::DEFAULT_COLOR_MAP = T.let(T.unsafe(nil), Hash)

# source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#7
Trailblazer::Developer::Wtf::Renderer::SIGNALS_MAP = T.let(T.unsafe(nil), Hash)

# Stolen from https://stackoverflow.com/questions/1489183/colorized-ruby-output
#
# TODO: this is just prototyping
#
# source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#55
module Trailblazer::Developer::Wtf::Renderer::String
  private

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#66
  def bg_black(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#70
  def bg_blue(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#69
  def bg_brown(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#72
  def bg_cyan(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#73
  def bg_gray(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#68
  def bg_green(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#71
  def bg_magenta(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#67
  def bg_red(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#57
  def black(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#61
  def blue(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#75
  def bold(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#60
  def brown(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#63
  def cyan(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#64
  def gray(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#59
  def green(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#76
  def italic(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#62
  def magenta(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#58
  def red(str); end

  # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#77
  def underline(str); end

  class << self
    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#66
    def bg_black(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#70
    def bg_blue(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#69
    def bg_brown(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#72
    def bg_cyan(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#73
    def bg_gray(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#68
    def bg_green(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#71
    def bg_magenta(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#67
    def bg_red(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#57
    def black(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#61
    def blue(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#75
    def bold(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#60
    def brown(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#63
    def cyan(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#64
    def gray(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#59
    def green(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#76
    def italic(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#62
    def magenta(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#58
    def red(str); end

    # source://trailblazer-developer//lib/trailblazer/developer/wtf/renderer.rb#77
    def underline(str); end
  end
end

# source://trailblazer-developer//lib/trailblazer/developer/version.rb#2
module Trailblazer::Version; end

# source://trailblazer-developer//lib/trailblazer/developer/version.rb#3
module Trailblazer::Version::Developer; end

# source://trailblazer-developer//lib/trailblazer/developer/version.rb#4
Trailblazer::Version::Developer::VERSION = T.let(T.unsafe(nil), String)
